## Introduction

> ＃＃ 介绍

In this appendix we concentrate on instruction set architecture—the portion of the computer visible to the programmer or compiler writer. Most of this material should be review for readers of this book; we include it here for background. This appendix introduces the wide variety of design alternatives available to the instruction set architect. In particular, we focus on four topics. First, we present a taxonomy of instruction set alternatives and give some qualitative assessment of the advantages and disadvantages of various approaches. Second, we present and analyze some instruction set measurements that are largely independent of a specific instruction set. Third, we address the issue of languages and compilers and their bearing on instruction set architecture. Finally, the “Putting It All Together” section shows how these ideas are reflected in the RISC-V instruction set, which is typical of RISC architectures. We conclude with fallacies and pitfalls of instruction set design.

> 在本附录中，我们专注于指令集体系结构，这是计算机或编译器作者可见的一部分。这些材料大部分都应对本书的读者进行回顾；我们在这里包括它以供背景。该附录介绍了指令集架构师可用的各种设计替代方案。特别是，我们专注于四个主题。首先，我们提出了教学套装替代方案的分类法，并对各种方法的优势和缺点进行一些定性评估。其次，我们介绍和分析一些主要独立于特定指令集的指令集测量。第三，我们解决了语言和编译器的问题及其对教学集架构的影响。最后，“将所有内容放在一起”部分显示了这些想法是如何反映在 RISC-V 指令集中的，RISC-V 指令集是 RISC 架构的典型代表。我们以谬论和指导集设计的陷阱结束。

To illustrate the principles further and to provide a comparison with RISC-V, Appendix K also gives four examples of other general-purpose RISC architectures (MIPS, Power ISA, SPARC, and Armv8), four embedded RISC processors (ARM Thumb2, RISC-V Compressed, microMIPS), and three older architectures (80x86, IBM 360/370, and VAX). Before we discuss how to classify architectures, we need to say something about instruction set measurement.

> 为了进一步说明原理并与 RISC-V 进行比较，附录 K 还提供了其他通用 RISC 架构(MIPS，Power ISA，SPARC 和 ARMV8)的四个示例 V 压缩，Micromips)和三个较旧的体系结构(80x86，IBM 360/370 和 VAX)。在讨论如何对体系结构进行分类之前，我们需要对指令设置测量进行一些讨论。

Throughout this appendix, we examine a wide variety of architectural measure- ments. Clearly, these measurements depend on the programs measured and on the compilers used in making the measurements. The results should not be interpreted as absolute, and you might see different data if you did the measurement with a different compiler or a different set of programs. We believe that the measurements in this appendix are reasonably indicative of a class of typical applications. Many of the measurements are presented using a small set of benchmarks, so that the data can be reasonably displayed and the differences among programs can be seen. An architect for a new computer would want to analyze a much larger collection of programs before making architectural decisions. The measurements shown are usually _dynamic_—that is, the frequency of a measured event is weighed by the number of times that event occurs during execution of the measured program.

> 在整个附录中，我们检查了各种各样的建筑测量。显然，这些测量值取决于测量的程序以及用于进行测量的编译器。结果不应将其解释为绝对，如果您使用不同的编译器或另一组程序进行测量，则可能会看到不同的数据。我们认为，本附录中的测量值合理地指示了一类典型应用程序。许多测量方法是使用一小部分基准进行的，以便可以合理地显示数据，并且可以看到程序之间的差异。一台新计算机的工程师希望在做出架构决策之前分析更多的程序。所示的测量值通常为_DYNAMIC_  - 也就是说，测量事件的频率是在执行测量程序执行过程中发生的事件的数量。

Before starting with the general principles, let’s review the three application areas from [Chapter 1](#_bookmark2). _Desktop computing_ emphasizes the performance of pro- grams with integer and floating-point data types, with little regard for program size. For example, code size has never been reported in the five generations of SPEC benchmarks. _Servers_ today are used primarily for database, file server, and Web applications, plus some time-sharing applications for many users. Hence, floating-point performance is much less important for performance than integers and character strings, yet virtually every server processor still includes floating- point instructions. _Personal mobile devices_ and _embedded applications_ value cost and energy, so code size is important because less memory is both cheaper and lower energy, and some classes of instructions (such as floating point) may be optional to reduce chip costs, and a compressed version of the instructions set designed to save memory space may be used.

> 从一般原则开始之前，让我们回顾一下[第 1 章](#_ bookmark2)的三个应用程序区域。_DESKTOP Computing_强调了具有整数和浮点数据类型的程序的性能，而对程序大小则几乎没有考虑。例如，在五代规格基准测试中，从未报告过代码大小。_servers _今天主要用于数据库，文件服务器和 Web 应用程序，以及许多用户的时间共享应用程序。因此，对于整数和字符字符串，浮点性能对性能的重要性要小得多，但是实际上，每个服务器处理器仍然包含浮点指令。_个人移动设备_和_embedded 应用程序_值成本和能源，因此代码大小很重要，因为更少的内存既便宜又较低，并且某些类别的指令(例如浮点)可能是可选的，可以降低芯片成本，并且是压缩版本可以使用旨在节省内存空间的说明集。

Thus, instruction sets for all three applications are very similar. In fact, archi- tectures similar to RISC-V, which we focus on here, have been used successfully in desktops, servers, and embedded applications.

> 因此，所有三个应用程序的指令集都非常相似。实际上，我们在此关注的 Archtures 类似于 RISC-V，已成功地用于台式机，服务器和嵌入式应用程序中。

One successful architecture very different from RISC is the 80x86 (see Appen- dix K). Surprisingly, its success does not necessarily belie the advantages of a RISC instruction set. The commercial importance of binary compatibility with PC soft- ware combined with the abundance of transistors provided by Moore’s Law led Intel to use a RISC instruction set internally while supporting an 80x86 instruction set externally. Recent 80x86 microprocessors, including all the Intel Core micropro- cessors built in the past decade, use hardware to translate from 80x86 instructions to RISC-like instructions and then execute the translated operations inside the chip. They maintain the illusion of 80x86 architecture to the programmer while allowing the computer designer to implement a RISC-style processor for performance. There remain, however, serious disadvantages for a complex instruction set like the 80x86, and we discuss these further in the conclusions.

> 与 RISC 完全不同的一个成功的架构是 80x86(请参阅 Appen-Dix K)。令人惊讶的是，它的成功并不一定相信 RISC 指导集的优势。二进制兼容性与 PC 软件的商业重要性结合了摩尔法律提供的大量晶体管，使英特尔在内部使用 RISC 指令，同时支持外部的 80x86 指令集。最近的 80x86 微处理器，包括过去十年构建的所有 Intel Core 微型处理器，使用硬件从 80x86 的说明转换为 RISC 式说明，然后在芯片中执行翻译的操作。他们将 80x86 体系结构的幻想向程序员保持，同时允许计算机设计人员实施 RISC 风格的处理器以进行性能。但是，对于像 80x86 这样的复杂指导集，仍然存在严重的缺点，我们在结论中进一步讨论了这些内容。

Now that the background is set, we begin by exploring how instruction set architectures can be classified.

> 现在设置了背景，我们首先探索如何将指令集架构分类。
