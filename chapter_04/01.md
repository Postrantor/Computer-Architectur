## Introduction

A question for the single instruction multiple data (SIMD) architecture, which [Chapter 1](#_bookmark2) introduced, has always been just how wide a set of applications has significant data-level parallelism (DLP). Five years after the SIMD classification was proposed (Flynn, 1966), the answer is not only the matrix-oriented computations of scientific computing but also the media-oriented image and sound processing and machine learning algorithms, as we will see in [Chapter 7](#_bookmark322). Since a multiple instruction multiple data (MIMD) architecture needs to fetch one instruction per data operation, single instruction multiple data (SIMD) is potentially more energy-efficient since a single instruction can launch many data operations. These two answers make SIMD attractive for personal mobile devices as well as for servers. Finally, perhaps the biggest advantage of SIMD versus MIMD is that the programmer continues to think sequentially yet achieves parallel speedup by having parallel data operations. This chapter covers three variations of SIMD: vector architectures, multimedia SIMD instruction set extensions, and graphics processing units (GPUs).[<sup>1]](#_bookmark168) The first variation, which predates the other two by more than 30 years, extends pipelined execution of many data operations. These \_vector architectures_ are easier to understand and to compile to than other SIMD variations, but they were considered too expensive for microprocessors until recently. Part of that expense was in transistors, and part was in the cost of sufficient dynamic random access memory (DRAM) bandwidth, given the widespread reliance on caches to meet memory performance demands on conventional microprocessors.

> [第 1 章](#_bookmark2)引入的单个指令的一个问题(SIMD)体系结构一直是一组应用程序具有多大数据级并行性(DLP)的宽度。提出了 SIMD 分类五年(Flynn，1966)，答案不仅是针对矩阵的科学计算计算的计算，而且是面向媒体的图像和声音处理以及机器学习算法，正如我们将在[第 7 章中看到的那样](#_bookmark322)。由于多个指导多个数据(MIMD)体系结构需要每个数据操作获取一项指令，因此单个指令多个数据(SIMD)可能会更节能，因为单个指令可以启动许多数据操作。这两个答案使 SIMD 对个人移动设备以及服务器具有吸引力。最后，也许 SIMD 与 MIMD 的最大优势是，程序员继续顺序思考，但通过并行数据操作来实现并行的加速。
> 本章介绍了 SIMD 的三个变体：**向量体系结构**，**多媒体 SIMD 指令集扩展名**和**图形处理单元(GPU)**。[1]是第一个变体，该变量将其他两种变体。在 30 年的时间里，扩展了许多数据操作的管道执行。这些 _vector Architectures_ 比其他 SIMD 变体更容易理解和编译，但是直到最近，它们对微处理器来说太昂贵了。这笔费用的一部分是在晶体管中，并且鉴于对缓存的广泛依赖以满足传统微处理器的记忆力需求，部分费用为足够的动态随机访问记忆(DRAM)带宽。

The second SIMD variation borrows from the SIMD name to mean basically simultaneous parallel data operations and is now found in most instruction set architectures that support multimedia applications. For x86 architectures, the SIMD instruction extensions started with the MMX (multimedia extensions) in 1996, which were followed by several SSE (streaming SIMD extensions) versions in the next decade, and they continue until this day with AVX (advanced vector extensions). To get the highest computation rate from an x86 computer, you often need to use these SIMD instructions, especially for floating-point programs.

> 第二个 SIMD 变体从 SIMD 名称借用了基本上同时并行数据操作，现在可以在支持多媒体应用程序的大多数指令集体系中找到。对于 X86 体系结构，SIMD 指令扩展始于 1996 年的 MMX(多媒体扩展)，随后是未来十年的几个 SSE(流式 SIMD 扩展)版本，它们一直持续到这一天，直到今天使用 AVX(Advation Vector Extensions)。为了从 X86 计算机获得最高的计算率，您通常需要使用这些 SIMD 说明，尤其是用于浮点程序。

The third variation on SIMD comes from the graphics accelerator community, offering higher potential performance than is found in traditional multicore computers today. Although GPUs share features with vector architectures, they have their own distinguishing characteristics, in part because of the ecosystem in which they evolved. This environment has a system processor and system memory in addition to the GPU and its graphics memory. In fact, to recognize those distinctions, the GPU community refers to this type of architecture as _heterogeneous_.

> SIMD 的第三个变化来自图形加速器社区，其潜在性能比当今传统的多核心计算机所发现的更高。尽管 GPU 与矢量体系结构共享特征，但它们具有自己的区别特征，部分原因是它们进化的生态系统。除 GPU 及其图形内存外，该环境还具有系统处理器和系统内存。实际上，为了识别这些区别，GPU 社区将这种类型的架构称为 _heterogeneous_。

[1] This chapter is based on material in Appendix F, "Vector Processors," by Krste Asanovic, and Appendix G, "Hardware and Software for VLIW and EPIC" from the 5th edition of this book; on material in Appendix A, "Graphics and Computing GPUs," by John Nickolls and David Kirk, from the 5th edition of _Computer Organization and Design_; and to a lesser extent on material in "Embracing and Extending 20th-Century Instruction Set Architectures," by Joe Gebis and David Patterson, _IEEE Computer_, April 2007.

> [ 1 ]本章基于附录 F 中的材料，"矢量处理器" ，Krste Asanovic 和附录 G，"硬件" 和 Vliw 和 Epic 的软件" 本书的第五版；约翰·尼克尔斯(John Nickolls)和戴维·柯克(David Kirk)的附录 A 中的材料，摘自\_computer 组织和 Design\*的第 5 版；乔·盖比斯(Joe Gebis)和戴维·帕特森(David Patterson)，_ieee Computer_，在 "拥抱和扩展 20 世纪的指导套装架构" 中的材料较小程度上，2007 年 4 月。

For problems with lots of data parallelism, all three SIMD variations share the advantage of being easier on the programmer than classic parallel MIMD programming.

> 对于许多数据并行性的问题，所有三个 SIMD 变体都具有比经典平行 MIMD 编程更容易在程序员身上更容易的优势。

The goal of this chapter is for architects to understand why vector is more general than multimedia SIMD, as well as the similarities and differences between vector and GPU architectures. Because vector architectures are supersets of the multimedia SIMD instructions, including a better model for compilation, and because GPUs share several similarities with vector architectures, we start with vector architectures to set the foundation for the following two sections. The next section introduces vector architectures, and Appendix G goes much deeper into the subject.

> 本章的目的是使架构师了解为什么向量比多媒体 SIMD 更一般，以及向量和 GPU 架构之间的相似性和差异。由于向量体系结构是多媒体 SIMD 指令的超集，包括更好的编译模型，并且 GPU 与向量体系结构共享几个相似之处，因此我们从向量体系结构开始，为以下两个部分奠定基础。下一节介绍向量体系结构，附录 G 对此主题更深入。
