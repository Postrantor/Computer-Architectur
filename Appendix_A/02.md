## Classifying Instruction Set Architectures

> ##分类指令集体系结构

The type of internal storage in a processor is the most basic differentiation, so in this section we will focus on the alternatives for this portion of the architecture. The major choices are a stack, an accumulator, or a set of registers. Operands may be named explicitly or implicitly: The operands in a _stack architecture_ are implicitly on the top of the stack, and in an _accumulator architecture_ one operand is implicitly the accumulator. The _general-purpose register architectures_ have only explicit operands—either registers or memory locations. [Figure A.1](#_bookmark395) shows a block diagram of such architectures, and [Figure A.2](#_bookmark396) shows how the code sequence C A+B would typically appear in these three classes of instruction sets. The explicit operands may be accessed directly from memory or may need to be first loaded into temporary storage, depending on the class of architecture and choice of specific instruction. As the figures show, there are really two classes of register computers. One class can access memory as part of any instruction, called _register-memory_ archi- tecture, and the other can access memory only with load and store instructions, called _load-store_ architecture. A third class, not found in computers shipping today, keeps all operands in memory and is called a _memory-memory_ architecture. Some instruction set architectures have more registers than a single accumulator but place restrictions on uses of these special registers. Such an architecture is sometimes called an _extended accumulator_ or _special-purpose register_ computer. Although most early computers used stack or accumulator-style architectures, virtually every new architecture designed after 1980 uses a load-store register archi- tecture. The major reasons for the emergence of general-purpose register (GPR) computers are twofold. First, registers—like other forms of storage internal to the processor—are faster than memory. Second, registers are more efficient for a compiler to use than other forms of internal storage. For example, on a register com- puter the expression (A \* B) +(B \* C) – (A \* D) may be evaluated by doing the multiplications in any order, which may be more efficient because of the location of the operands or because of pipelining concerns (see [Chapter 3](#_bookmark93)). Nevertheless, on a stack computer the hardware must evaluate the expression in only one order, because operands are hidden on the stack, and it may have to load an operand multiple times. More importantly, registers can be used to hold variables. When variables are allocated to registers, the memory traffic reduces, the program speeds up (because registers are faster than memory), and the code density improves (because a register can be named with fewer bits than can a memory location).

> 处理器中内部存储的类型是最基本的差异化，因此在本节中，我们将重点介绍该部分体系结构的替代方案。主要选择是堆栈，累加器或一组寄存器。操作数可以显式或隐式命名：_Stack Architecture 中的操作数隐含在堆栈顶部，并且在_accumulator 架构_中，一个操作数隐含地是累加器。_ general-Purpose 寄存器架构_仅具有明确的操作数 - 寄存器或内存位置。[图 A.1](#_ bookmark395)显示了此类体系结构的框图，[图 A.2](#_ bookmark396)显示了代码序列 C A+B 通常会出现在这三类指令集中。可以直接从内存访问显式操作数，也可以首先将其加载到临时存储中，具体取决于体系结构的类别和特定指令的选择。如图所示，实际上有两类的寄存器计算机。一个类可以作为任何指令的一部分访问内存，称为_register-memory_ aCr-tecture，另一个可以使用加载和存储指令访问内存，称为_load-store-store_架构。今天在计算机运输中未发现的第三类可以使所有操作数保持在内存中，并称为_memory-memory_架构。某些指令集架构比单个蓄能器具有更多的登记册，但对这些特殊寄存器的用途进行了限制。这样的架构有时称为_Extended accomulator_或_special-Purpose 寄存器_计算机。尽管大多数早期计算机都使用堆栈或累加器式体系结构，但实际上，1980 年以后设计的每个新体系结构都使用负载商店的寄存器档案。出现通用寄存器(GPR)计算机的主要原因是双重的。首先，寄存器(例如处理器内部的其他形式的存储)比内存快。其次，寄存器比其他形式的内部存储更有效地使用编译器。例如，在寄存器上，可以通过按任何顺序进行乘法来评估表达式(a \* b) +(b \* c) - (a \* d)操作数的位置或由于管道问题的原因(请参阅[[第 3 章](#_ bookmark93))。但是，在堆栈计算机上，硬件必须仅以一个顺序评估表达式，因为操作数隐藏在堆栈上，并且可能必须多次加载操作数。更重要的是，寄存器可用于容纳变量。当变量分配给寄存器时，存储器流量减少，程序会加快(因为寄存器比内存快)，并且代码密度会提高(因为寄存器的命名可以比内存位置少的位命名)。

Figure A.1 Operand locations for four instruction set architecture classes. The arrows indicate whether the oper- and is an input or the result of the arithmetic-logical unit (ALU) operation, or both an input and result. Lighter shades indicate inputs, and the dark shade indicates the result. In (A), a top of stack (TOS) register points to the top input operand, which is combined with the operand below. The first operand is removed from the stack, the result takes the place of the second operand, and TOS is updated to point to the result. All operands are implicit. In (B), the accu- mulator is both an implicit input operand and a result. In (C), one input operand is a register, one is in memory, and the result goes to a register. All operands are registers in (D) and, like the stack architecture, can be transferred to memory only via separate instructions: push or pop for (A) and load or store for (D).

> 图 A.1 四个指令集体系结构类的操作数位置。箭头指示操作和算术单元(ALU)操作的输入和结果，还是输入和结果。较浅的阴影表示输入，深色阴影表示结果。在(a)中，堆栈的顶部(TOS)寄存器指向顶部输入操作数，该操作数与下面的操作数结合在一起。从堆栈中删除了第一台操作数，结果取代了第二操作数，而 TOS 已更新以指向结果。所有操作数都是隐式的。在(b)中，授予既是隐式输入操作数，又是结果。在(c)中，一个输入操作数为寄存器，一个在内存中，结果转到寄存器。所有操作数均为(d)中的寄存器，就像堆栈体系结构一样，只能通过单独的说明传输到内存：(a)的按下或弹出(a)和加载或存储(d)。

Figure A.2 The code sequence for C 5 A+B for four classes of instruction sets. Note that the Add instruction has implicit operands for stack and accumulator architectures and explicit operands for register architectures. It is assumed that A, B, and C all belong in memory and that the values of A and B cannot be destroyed. [Figure A.1](#_bookmark395) shows the Add operation for each class of architecture.

> 图 A.2 四类指令集 C 5 A+B 的代码序列。请注意，添加指令具有用于堆栈和累加器架构的隐式操作数，以及用于注册体系结构的明确操作数。假定 A，B 和 C 都属于记忆，并且 A 和 B 的值不能被破坏。[图 A.1](#_ bookmark395)显示了每类体系结构的添加操作。

As explained in [Section A.8](#cross-cutting-issues-the-role-of-compilers), compiler writers would prefer that all registers be equivalent and unreserved. Older computers compromise this desire by dedicating registers to special uses, effectively decreasing the number of general-purpose reg- isters. If the number of truly general-purpose registers is too small, trying to allo- cate variables to registers will not be profitable. Instead, the compiler will reserve all the uncommitted registers for use in expression evaluation.

> 正如[A.8 节](＃交叉剪切 - 兼容器的互补符)所述，编译器作家更希望所有寄存器都是等效的和没有保留的。较旧的计算机通过将寄存器专用于特殊用途来损害这种愿望，从而有效地减少了通用重量的数量。如果真正的通用寄存器的数量太少了，则试图将变量分配给寄存器将不会有利可图。相反，编译器将保留所有未承诺的寄存器用于表达评估。

How many registers are sufficient? The answer, of course, depends on the effec- tiveness of the compiler. Most compilers reserve some registers for expression eval- uation, use somefor parameter passing, and allow the remainder tobeallocated tohold variables. Modern compiler technology and its ability to effectively use larger num- bers of registers has led to an increase in register counts in more recent architectures. Two major instruction set characteristics divide GPR architectures. Both char- acteristics concern the nature of operands for a typical arithmetic or logical instruc- tion (ALU instruction). The first concerns whether an ALU instruction has two or three operands. In the three-operand format, the instruction contains one result operand and two source operands. In the two-operand format, one of the operands is both a source and a result for the operation. The second distinction among GPR architectures concerns how many of the operands may be memory addresses in ALU instructions. The number of memory operands supported by a typical ALU instruction may vary from none to three. [Figure A.3](#_bookmark397) shows combinations of these two attributes with examples of computers. Although there are seven possible combinations, three serve to classify nearly all existing computers. As we mentioned earlier, these three are load-store (also called register-register), register- memory, and memory-memory.

> 多少寄存器足够？当然，答案取决于编译器的效率。大多数编译器都保留一些寄存器进行表达评估，使用某个参数传递，并允许其余的 tobealCealCealCeled toberceled toshord 变量。现代编译器技术及其有效使用较大数量寄存器的能力导致了最新架构中的寄存器计数增加。两个主要的指令集特征划分了 GPR 体系结构。两种志愿者都涉及典型算术或逻辑指导的操作数的性质(ALU 指令)。首先是 Alu 指令是否有两个或三个操作数。在三项手术格式中，该指令包含一个结果操作数和两个源操作数。在两动作格式中，操作数之一既是操作的源和结果。GPR 体系结构之间的第二个区别是涉及在 Alu 指示中可能是多少操作数。由典型的 ALU 指令支持的内存操作数可能从无好到三个。[图 A.3](#_ bookmark397)显示了这两个属性与计算机示例的组合。尽管有七个可能的组合，但三个用于对几乎所有现有计算机进行分类。如前所述，这三个是负载商店(也称为寄存器登记册)，寄存器内存和内存记忆。

Figure A.3 Typical combinations of memory operands and total operands per typical ALU instruction with examples of computers. Computers with no memory reference per ALU instruction are called load-store or register-register computers. Instructions with multiple memory operands per typical ALU instruction are called register-memory or memory-memory, according to whether they have one or more than one memory operand.

> 图 A.3 每个典型的 ALU 指令的内存操作数和总操作数的典型组合与计算机的示例。根据 ALU 指令没有内存参考的计算机称为负载商店或寄存器注册计算机。每个典型的 ALU 指令具有多个内存操作数的说明称为寄存器记忆或内存记忆，根据它们是否具有一个或多个内存操作数。

Figure A.4 Advantages and disadvantages of the three most common types of general-purpose register com- puters. The notation (_m_, _n_) means _m_ memory operands and _n_ total operands. In general, computers with fewer alter- natives simplify the compiler’s task because there are fewer decisions for the compiler to make (see [Section A.8](#cross-cutting-issues-the-role-of-compilers)). Computers with a wide variety of flexible instruction formats reduce the number of bits required to encode the pro- gram. The number of registers also affects the instruction size because you need log<sub>2</sub> (number of registers) for each register specifier in an instruction. Thus, doubling the number of registers takes three extra bits for a register-register architecture, or about 10% of a 32-bit instruction.

> 图 A.4 三种最常见类型的通用寄存器计算机的优点和缺点。符号(_m_，_n_)表示_m_内存操作数和_n_总操作数。一般而言，具有较少代理商的计算机简化了编译器的任务，因为编译器的决策较少(请参阅[A.8]第(＃cross-Cutting-issues-the-the-the-the-the compilers))。具有多种灵活说明格式的计算机减少了编码程序所需的位数。寄存器的数量还会影响指令大小，因为您需要在指令中为每个寄存器指定符的日志<ub> 2 </sub>(寄存器数)。因此，将寄存器的数量加倍用于注册登记架构，约为 32 位指令的 10％。

[Figure A.4](#_bookmark398) shows the advantages and disadvantages of each of these alter- natives. Of course, these advantages and disadvantages are not absolutes: they are qualitative and their actual impact depends on the compiler and implemen- tation strategy. A GPR computer with memory-memory operations could eas- ily be ignored by the compiler and used as a load-store computer. One of the most pervasive architectural impacts is on instruction encoding and the num- ber of instructions needed to perform a task. We see the impact of these archi- tectural alternatives on implementation approaches in [Appendix C](#_bookmark481) and [Chapter 3](#_bookmark93).

> [图 A.4](#_ bookmark398)显示了这些替代方案中每一个的优点和缺点。当然，这些优势和缺点不是绝对的：它们是定性的，其实际影响取决于编译器和实施策略。编译器可以忽略具有内存内存操作的 GPR 计算机，并用作负载店计算机。最普遍的体系结构影响之一是对执行任务的指令编码和所需的指令数量。我们看到了这些档案替代方案对[附录 C](#_ bookmark481)和[第 3 章](#_ bookmark93)中实现方法的影响。

### Summary: Classifying Instruction Set Architectures

> ###摘要：分类指令集体系结构

Here and at the end of [Sections A.3–A.8](#memory-addressing) we summarize those characteristics we would expect to find in a new instruction set architecture, building the foundation for the RISC-V architecture introduced in [Section A.9](#putting-it-all-together-the-risc-v-architecture). From this section we should clearly expect the use of general-purpose registers. [Figure A.4](#_bookmark398), combined with [Appendix C](#_bookmark481) on pipelining, leads to the expectation of a load-store version of a general-purpose register architecture.

> 在[A.3 – A.8 节]的末尾(＃内存 - 地址)，我们总结了我们期望在新的指令集架构中找到的那些特征，从而为 RISC-V 架构建立基础[A.9](＃putting-it-it-all-the-the-the-the-risc-v-Architecture)。从本节中，我们应该明确期望使用通用登记册。[图 A.4](#_ bookmark398)与管道上的[附录 C](#_ bookmark481)相结合，导致期望通用寄存器架构的负载商店版本。

With the class of architecture covered, the next topic is addressing operands.

> 涵盖了架构类别，下一个主题是解决操作数。
