## Historical Perspective and References

The earliest computers used fixed point rather than floating point. In "Preliminary Discussion of the Logical Design of an Electronic Computing Instrument," [Burks,](#_bookmark810) [Goldstine, and von Neumann [1946]](#_bookmark810) put it like this:

> 最早的计算机使用固定点而不是浮点。在 "电子计算工具的逻辑设计的初步讨论" 中，[Burks，](#_bookmark810)[Goldstine 和 von Neumann [1946 ]](#_bookmark810)这样说：

_There appear to be two major purposes in a "floating" decimal point system both of which arise from the fact that the number of digits in a word is a constant fixed by design considerations for each particular machine. The first of these purposes is to retain in a sum or product as many significant digits as possible and the second of these is to free the human operator from the burden of estimating and inserting into a problem "scale factors" —multiplicative constants which serve to keep numbers within the limits of the machine._

> _在 "浮动" 小数点系统中似乎有两个主要目的，这两个目的都源于这样一个事实，即一个字中的位数是由每个特定机器的设计考虑固定的常数。这些目的中的第一个是在求和或乘积中保留尽可能多的有效数字，第二个是使操作员免于估计和插入问题 "比例因子" 的负担——乘法常数，用于 将数字保持在机器的范围内。_

_There is, of course, no denying the fact that human time is consumed in arrang- ing for the introduction of suitable scale factors. We only argue that the time so consumed is a very small percentage of the total time we will spend in preparing an interesting problem for our machine. The first advantage of the floating point is, we feel, somewhat illusory. In order to have such a floating point, one must waste memory capacity that could otherwise be used for carrying more digits per word. It would therefore seem to us not at all clear whether the modest advan- tages of a floating binary point offset the loss of memory capacity and the increased complexity of the arithmetic and control circuits._

> _当然，不可否认的是，人类的时间消耗在安排合适的比例因子的引入上。我们只是争辩说，如此消耗的时间只占我们为机器准备有趣问题所花费的总时间的很小一部分。我们觉得浮点数的第一个优点是有点虚幻。为了拥有这样一个浮点数，必须浪费内存容量，否则这些容量可以用于每个字携带更多数字。因此，在我们看来，浮点二进制小数点的适度优势是否抵消了存储容量的损失以及算术和控制电路复杂性的增加，这一点似乎一点也不清楚_ 。

This enables us to see things from the perspective of early computer designers, who believed that saving computer time and memory were more important than saving programmer time.

> 这使我们能够从早期的计算机设计师的角度看待事物，他们认为节省计算机时间和内存比节省程序员时间更重要。

The original papers introducing the Wallace tree, Booth recoding, SRT divi- sion, overlapped triplets, and so on are reprinted in [Swartzlander [1990]](#_bookmark834). A good explanation of an early machine (the IBM 360/91) that used a pipelined Wallace tree, Booth recoding, and iterative division is in [Anderson et al. [1967]](#_bookmark806). A discus- sion of the average time for single-bit SRT division is in [Freiman [1961]](#_bookmark814); this is one of the few interesting historical papers that does not appear in Swartzlander.

> [Swartzlander [1990]](#_bookmark834) 转载了介绍 Wallace 树、Booth 重新编码、SRT 划分、重叠三元组等的原始论文。在 [Anderson 等人。[1967]](#_bookmark806)。[Freiman [1961]](#_bookmark814) 中讨论了单位 SRT 划分的平均时间；这是少数没有出现在 Swartzlander 中的有趣历史论文之一。

The standard book of [Mead and Conway [1980]](#_bookmark827) discouraged the use of CLAs as not being cost effective in VLSI. The important paper by [Brent and Kung [1982]](#_bookmark809) helped combat that view. An example of a detailed layout for CLAs can be found in [Ngai and Irwin [1985]](#_bookmark829) or in [Weste and Eshraghian [1993]](#_bookmark837), and a more theoretical treatment is given by [Leighton [1992]](#_bookmark824). [Takagi, Yasuura, and Yajima [1985]](#_bookmark835) pro- vide a detailed description of a signed-digit tree multiplier.

> [Mead 和 Conway [1980]](#_bookmark827) 的标准书籍不鼓励使用 CLA，因为在 VLSI 中不符合成本效益。[Brent 和 Kung [1982]](#_bookmark809) 的重要论文帮助驳斥了这种观点。在 [Ngai 和 Irwin [1985]](#_bookmark829) 或 [Weste 和 Eshraghian [1993]](#_bookmark837) 中可以找到 CLA 详细布局的示例，[Leighton [ 1992]](#_bookmark824)。[Takagi、Yasuura 和 Yajima [1985]](#_bookmark835) 提供了带符号数字树乘法器的详细描述。

Before the ascendancy of IEEE arithmetic, many different floating-point for- mats were in use. Three important ones were used by the IBM 370, the DEC VAX, and the Cray. Here is a brief summary of these older formats. The VAX format is closest to the IEEE standard. Its single-precision format (F format) is like IEEE single precision in that it has a hidden bit, 8 bits of exponent, and 23 bits of fraction. However, it does not have a sticky bit, which causes it to round halfway cases up instead of to even. The VAX has a slightly different exponent range from IEEE single: \_E_min is 128 rather than 126 as in IEEE, and \_E_max is 126 instead of 127. The main differences between VAX and IEEE are the lack of special values and gradual underflow. The VAX has a reserved operand, but it works like a signaling NaN: It traps whenever it is referenced. Originally, the VAX’s double precision (D format) also had 8 bits of exponent. However, as this is too small for many applications, a G format was added; like the IEEE standard, this format has 11 bits of exponent. The VAX also has an H format, which is 128 bits long.

> 在 IEEE 算法兴起之前，使用了许多不同的浮点格式。IBM 370、DEC VAX 和 Cray 使用了三个重要的。以下是这些旧格式的简要总结。VAX 格式最接近 IEEE 标准。其单精度格式(F 格式)与 IEEE 单精度类似，具有隐藏位、8 位指数和 23 位小数。但是，它没有粘性位，这导致它会将中途的情况四舍五入而不是均匀。VAX 与 IEEE 单指数范围略有不同：\_E_min 是 128 而不是 IEEE 中的 126，\_E_max 是 126 而不是 127。VAX 和 IEEE 之间的主要区别是缺少特殊值和逐渐下溢。VAX 有一个保留的操作数，但它的工作方式就像一个信号 NaN：只要它被引用就会陷入陷阱。最初，VAX 的双精度(D 格式)也有 8 位指数。但是，由于这对于许多应用程序来说太小了，因此添加了 G 格式；与 IEEE 标准一样，这种格式有 11 位指数。VAX 也有一个 H 格式，它有 128 位长。

The IBM 370 floating-point format uses base 16 rather than base 2. This means it cannot use a hidden bit. In single precision, it has 7 bits of exponent and 24 bits (6 hex digits) of fraction. Thus, the largest representable number is 1627 24 27 229, compared with 228 for IEEE. However, a number that is normalized in the hexadec- imal sense only needs to have a nonzero leading digit. When interpreted in binary, the three most-significant bits could be zero. Thus, there are potentially fewer than 24 bits of significance. The reason for using the higher base was to minimize the amount of shifting required when adding floating-point numbers. However, this is less signifi- cant in current machines, where the floating-point add time is usually fixed indepen- dently of the operands. Another difference between 370 arithmetic and IEEE arithmetic is that the 370 has neither a round digit nor a sticky digit, which effectively means that it truncates rather than rounds. Thus, in many computations, the result will systematically be too small. Unlike the VAX and IEEE arithmetic, every bit pattern is a valid number. Thus, library routines must establish conventi,onsfor what to return in

> IBM 370 浮点格式使用 16 进制而不是 2 进制。这意味着它不能使用隐藏位。在单精度中，它有 7 位指数和 24 位(6 个十六进制数字)的小数。因此，最大可表示数是 1627 24 27 229，而 IEEE 为 228。然而，在十六进制意义上标准化的数字只需要有一个非零的前导数字。当以二进制解释时，三个最高有效位可能为零。因此，有效位可能少于 24 位。使用较高基数的原因是为了最大限度地减少添加浮点数时所需的移位量。然而，这在当前的机器中并不那么重要，其中浮点加法时间通常是固定的，与操作数无关。370 算法和 IEEE 算法之间的另一个区别是 370 既没有舍入数字也没有粘性数字，这实际上意味着它截断而不是舍入。因此，在许多计算中，结果系统地会太小。与 VAX 和 IEEE 算法不同，每个位模式都是有效数字。因此，库例程必须为返回的内容建立约定

Arithmetic on Cray computers is interesting because it is driven by a motiva- tion for the highest possible floating-point performance. It has a 15-bit exponent field and a 48-bit fraction field. Addition on Cray computers does not have a guard digit, and multiplication is even less accurate than addition. Thinking of multipli- cation as a sum of `p` numbers, each 2*p* bits long, Cray computers drop the low-order bits of each summand. Thus, analyzing the exact error characteristics of the mul- tiply operation is not easy. Reciprocals are computed using iteration, and division of `a` by `b` is done by multiplying `a` times 1/_b_. The errors in multiplication and recip- rocation combine to make the last three bits of a divide operation unreliable. At least Cray computers serve to keep numerical analysts on their toes!

> Cray 计算机上的算术很有趣，因为它是由尽可能高的浮点性能驱动的。它有一个 15 位的指数字段和一个 48 位的小数字段。Cray 计算机上的加法没有保护位，乘法甚至不如加法准确。将乘法视为 "p" 数的总和，每个 2*p* 位长，Cray 计算机丢弃每个被加数的低位。因此，分析乘法运算的准确误差特征并不容易。倒数是使用迭代计算的，将 `a` 除以 `b` 是通过将 `a` 乘以 1/_b_ 来完成的。乘法和往复运算中的错误结合起来使得除法运算的最后三位不可靠。至少 Cray 计算机可以让数值分析师保持警惕！

The IEEE standardization process began in 1977, inspired mainly by W. Kahan and based partly on Kahan’s work with the IBM 7094 at the University of Toronto [[Kahan 1968](#_bookmark819)]. The standardization process was a lengthy affair, with gradual underflow causing the most controversy. (According to Cleve Moler, visitors to the United States were advised that the sights not to be missed were Las Vegas, the Grand Canyon, and the IEEE standards committee meeting.) The standard was finally approved in 1985. The Intel 8087 was the first major commercial IEEE implementation and appeared in 1981, before the standard was finalized. It con- tains features that were eliminated in the final standard, such as projective bits. According to Kahan, the length of double-extended precision was based on what could be implemented in the 8087. Although the IEEE standard was not based on any existing floating-point system, most of its features were present in some other system. For example, the CDC 6600 reserved special bit patterns for INDEFINITE and INFINITY, while the idea of denormal numbers appears in [Goldberg [1967]](#_bookmark816) as well as in [Kahan [1968]](#_bookmark819). Kahan was awarded the 1989 Turing prize in recognition of his work on floating point.

> IEEE 标准化过程始于 1977 年，主要受到 W. Kahan 的启发，部分基于 Kahan 在多伦多大学使用 IBM 7094 的工作 [[Kahan 1968](#_bookmark819)]。标准化过程是一个漫长的过程，逐渐下溢引起的争议最多。(根据 Cleve Moler 的说法，到美国的游客被告知不可错过的景点是拉斯维加斯、大峡谷和 IEEE 标准委员会会议。)该标准最终于 1985 年获得批准。Intel 8087 是第一个 主要的商业 IEEE 实施并出现在 1981 年，在标准定稿之前。它包含在最终标准中被删除的功能，例如投影位。根据 Kahan 的说法，双精度扩展的长度是基于 8087 中可以实现的长度。虽然 IEEE 标准不是基于任何现有的浮点系统，但它的大部分功能都存在于其他一些系统中。例如，CDC 6600 为 INDEFINITE 和 INFINITY 保留了特殊的位模式，而非正规数的概念出现在 [Goldberg [1967]](#_bookmark816) 以及 [Kahan [1968]](#_bookmark819) 中。Kahan 因其在浮点数方面的工作而获得 1989 年的图灵奖。

Although floating point rarely attracts the interest of the general press, news- papers were filled with stories about floating-point division in November 1994. A bug in the division algorithm used on all of Intel’s Pentium chips had just come to light. It was discovered by Thomas Nicely, a math professor at Lynchburg College in Virginia. Nicely found the bug when doing calculations involving reciprocals of prime numbers. News of Nicely’s discovery first appeared in the press on the front page of the November 7 issue of `Electronic Engineering Times.` Intel’s immediate response was to stonewall, asserting that the bug would only affect theoretical mathematicians. Intel told the press, "This doesn’t even qualify as an errata … even if you’re an engineer, you’re not going to see this."

> 尽管浮点数很少引起一般媒体的兴趣，但在 1994 年 11 月，报纸上充斥着关于浮点除法的报道。用于所有英特尔奔腾芯片的除法算法中的一个错误刚刚曝光。它是由弗吉尼亚州林奇堡学院的数学教授 Thomas Nicely 发现的。在进行涉及素数倒数的计算时很好地发现了这个错误。Nicely 发现的消息最先出现在 11 月 7 日的《电子工程时报》头版。英特尔的立即反应是石墙，声称该漏洞只会影响理论数学家。英特尔告诉媒体，"这甚至不属于勘误……即使你是一名工程师，你也不会看到这个。"

Under more pressure, Intel issued a white paper, dated November 30, explain- ing why they didn’t think the bug was significant. One of their arguments was based on the fact that if you pick two floating-point numbers at random and divide one into the other, the chance that the resulting quotient will be in error is about 1 in 9 billion. However, Intel neglected to explain why they thought that the typical customer accessed floating-point numbers randomly.

> 在更大的压力下，英特尔发布了一份日期为 11 月 30 日的白皮书，解释了为什么他们认为该错误并不严重。他们的一个论点是基于这样一个事实，即如果你随机选择两个浮点数并将一个除以另一个，则所得商出错的可能性约为 90 亿分之一。然而，英特尔忽略了解释为什么他们认为典型客户会随机访问浮点数。

Pressure continued to mount on Intel. One sore point was that Intel had known about the bug before Nicely discovered it, but had decided not to make it public. Finally, on December 20, Intel announced that they would unconditionally replace any Pentium chip that used the faulty algorithm and that they would take an unspe- cified charge against earnings, which turned out to be $300 million.

> 英特尔的压力继续增加。一个痛点是英特尔在 Nicely 发现它之前就知道了这个错误，但决定不公开它。最后，在 12 月 20 日，英特尔宣布他们将无条件更换任何使用错误算法的奔腾芯片，并且他们将从收益中扣除一笔未指明的费用，最终为 3 亿美元。

The Pentium uses a simple version of SRT division as discussed in [Section J.9](#speeding-up-integer-multiplication-and-division). The bug was introduced when they converted the quotient lookup table to a PLA. Evidently there were a few elements of the table containing the quotient digit 2 that Intel thought would never be accessed, and they optimized the PLA design using this assumption. The resulting PLA returned 0 rather than 2 in these situations. However, those entries were really accessed, and this caused the division bug. Even though the effect of the faulty PLA was to cause 5 out of 2048 table entries to be wrong, the Pentium only computes an incorrect quotient 1 out of 9 billion times on random inputs. This is explored in Exercise J.34.

> Pentium 使用 SRT 除法的简单版本，如 [第 J.9 节](#speeding-up-integer-multiplication-and-division) 中所述。当他们将商查找表转换为 PLA 时引入了该错误。显然，表格中有一些元素包含英特尔认为永远不会被访问的商数字 2，他们使用这个假设优化了 PLA 设计。在这些情况下，生成的 PLA 返回 0 而不是 2。然而，这些条目确实被访问了，这导致了除法错误。即使错误的 PLA 导致 2048 个表条目中有 5 个是错误的，Pentium 仅在 90 亿次随机输入中计算出不正确的商 1 次。这在练习 J.34 中进行了探讨。
