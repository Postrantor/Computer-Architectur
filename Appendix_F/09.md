## Internetworking

> ## Internetworking

Undoubtedly one of the most important innovations in the communications com- munity has been internetworking. It allows computers on independent and incom- patible networks to communicate reliably and efficiently. [Figure F.34](#_bookmark630) illustrates the need to traverse between networks. It shows the networks and machines involved in transferring a file from Stanford University to the University of Cal- ifornia at Berkeley, a distance of about 75 km.

> 毫无疑问，通信社区中最重要的创新之一就是互联网。它允许在独立和无理网络上的计算机可靠，有效地通信。[图 F.34]（#_ bookmark630）说明了在网络之间穿越的必要性。它显示了参与将文件从斯坦福大学转移到伯克利大学的 Cal-Ifornia 大学的网络和机器，距离约 75 公里。

The low cost of internetworking is remarkable. For example, it is vastly less expensive to send electronic mail than to make a coast-to-coast telephone call and leave a message on an answering machine. This dramatic cost improvement is achieved using the same long-haul communication lines as the telephone call, which makes the improvement even more impressive.

> 互联网工程的低成本非常出色。例如，发送电子邮件的发送要比打一个海岸到海岸的电话要便宜得多，并在接听机上留言。这种巨大的成本提高是使用与电话相同的长途通信线实现的，这使得改进更加令人印象深刻。

The enabling technologies for internetworking are software standards that allow reliable communication without demanding reliable networks. The underly- ing principle of these successful standards is that they were composed as a hierar- chy of layers, each layer taking responsibility for a portion of the overall communication task. Each computer, network, and switch implements its layer of the standards, relying on the other components to faithfully fulfill their respon- sibilities. These layered software standards are called protocol families or protocol suites. They enable applications to work with any interconnection without extra work by the application programmer. [Figure F.35](#_bookmark631) suggests the hierarchical model of communication.

> 互联网加工的启示技术是软件标准，可以允许可靠的通信而无需可靠的网络。这些成功标准的基本原则是它们是作为层级的层组成的，每个层都负责一部分整体通信任务。每个计算机，网络和交换机都会实现其标准层，并依靠其他组件来忠实地实现其响应性。这些分层软件标准称为协议家庭或协议套件。它们使应用程序能够与任何互连一起工作，而无需申请程序员的额外工作。[图 F.35]（#_ bookmark631）提出了通信的层次结构模型。

The most popular internetworking standard is TCP/IP (Transmission Control Protocol/Internet Protocol). This protocol family is the basis of the humbly named Internet, which connects hundreds of millions of computers around the world. This popularity means TCP/IP is used even when communicating locally across compatible networks; for example, the network file system (NFS) uses IP even though it is very likely to be communicating across a homogenous LAN such as Ethernet. We use TCP/IP as our protocol family example; other protocol families follow similar lines. [Section F.13](#historical-perspective-and-references-6) gives the history of TCP/IP.

> 最受欢迎的互联网加工标准是 TCP/IP（传输控制协议/Internet 协议）。该协议家族是谦卑命名的 Internet 的基础，该基础连接了世界各地的数亿台计算机。这种受欢迎程度意味着即使在跨兼容网络进行本地通信时，也会使用 TCP/IP。例如，即使网络文件系统（NFS）使用 IP，即使它很可能在诸如以太网之类的同质 LAN 上进行通信。我们使用 TCP/IP 作为协议家庭示例；其他协议系列遵循类似的行。[F.13 节]（＃历史 - 光谱和参考文献-6）给出了 TCP/IP 的历史。

The goal of a family of protocols is to simplify the standard by dividing respon- sibilities hierarchically among layers, with each layer offering services needed by the layer above. The application program is at the top, and at the bottom is the phys- ical communication medium, which sends the bits. Just as abstract data types sim- plify the programmer’s task by shielding the programmer from details of the implementation of the data type, this layered strategy makes the standard easier to understand.

> 协议家庭的目的是通过将响应性层次分配在层之间来简化标准，每层提供上述图层所需的服务。申请程序位于顶部，底部是发送位置的物理通信媒介。就像抽象数据类型通过将程序员免受数据类型的实现的详细信息来模拟程序员的任务一样，这种分层策略使标准更易于理解。

There were many efforts at network protocols, which led to confusion in terms. Hence, Open Systems Interconnect (OSI) developed a model that popularized describing networks as a series of layers. Figure F.36 shows the model. Although all protocols do not exactly follow this layering, the nomenclature for the different layers is widely used. Thus, you can hear discussions about a simple layer 3 switch versus a layer 7 smart switch.

> 网络协议有许多努力，这导致了混乱。因此，开放系统互连（OSI）开发了一个模型，该模型普及了将网络描述为一系列层。图 F.36 显示了模型。尽管所有协议均未完全遵循此分层，但广泛使用了不同层的命名法。因此，您可以听到有关简单第 3 层开关与第 7 层智能开关的讨论。

The key to protocol families is that communication occurs logically at the same level of the protocol in both sender and receiver, but services of the lower level implement it. This style of communication is called _peer-to-peer_. As an analogy, imagine that General A needs to send a message to General B on the battlefield. General A writes the message, puts it in an envelope addressed to General B, and gives it to a colonel with orders to deliver it. This colonel puts it in an envelope, and writes the name of the corresponding colonel who reports to General B, and gives it to a major with instructions for delivery. The major does the same thing and gives it to a captain, who gives it to a lieutenant, who gives it to a sergeant. The sergeant takes the envelope from the lieutenant, puts it into an envelope with the name of a sergeant who is in General B’s division, and finds a private with orders to take the large envelope. The private borrows a motorcycle and delivers the envelope to the other sergeant. Once it arrives, it is passed up the chain of command, with each person removing an outer envelope with his name on it and passing on the inner envelope to his superior. As far as General B can tell, the note is from another gen- eral. Neither general knows who was involved in transmitting the envelope, nor how it was transported from one division to the other.

> 协议系列的关键是，通信在发件人和接收方的协议层面上逻辑上发生，但是较低级别的服务实现了它。这种交流方式称为_peer-to-per_。比喻，想象一般 A 需要在战场上向 B 将军发送信息。一般 A 写了这一消息，将其放在通用 B 的信封中，并将其交给上校，并带有命令来交付它。该上校将其置于一个信封中，并写下了将上校报告给 B 将军的名字，并将其交给了大专业，并提供了交货指示。少校做同样的事情，并将其交给船长，后者将其交给了中尉，后者将其送给了军士。中士从中尉那里夺走了信封，将其置于 B 派中士的名字的信封中，并找到了 B 师的名字，并找到了一个带有大型信封的私人命令。私人借摩托车并将信封交给另一只中士。一旦到达，它就会沿着指挥链传递，每个人都用他的名字删除了一个外部信封，并将内在的信封传递到上级。就一般 B 所说的而言，该注释来自另一个一般。一般都不知道谁参与传输信封，也不知道它是如何从一个部门运送到另一个部门的。

Protocol families follow this analogy more closely than you might think, as [Figure F.37](#_bookmark633) shows. The original message includes a header and possibly a trailer sent by the lower-level protocol. The next-lower protocol in turn adds its own header to the message, possibly breaking it up into smaller messages if it is too large for this layer. Reusing our analogy, a long message from the general is divided and placed in several envelopes if it could not fit in one. This division of the message and appending of headers and trailers continues until the message

> 如[图 F.37]（#_ bookmark633）所示，协议系列比您想象的要遵循这个类比。原始消息包括标题和低级协议发送的预告片。下一个降低的协议又将其自己的标题添加到消息中，如果该层太大，则可能将其分解为较小的消息。重复我们的类比，如果不适合一个信封，将一般的信息分开并放在几个信封中。该消息的这种划分和标题和拖车的附加量一直持续到消息

![](./media/image706.png)
![](./media/image709.png)
![](./media/image712.png)

Figure F.37 A generic protocol stack with two layers. Note that communication is peer-to-peer, with headers and trailers for the peer added at each sending layer and removed by each receiving layer. Each layer offers services to the one above to shield it from unnecessary details.

> 图 F.37 具有两层的通用协议堆栈。请注意，通信是对等点，在每个发送层上添加的对等的标题和拖车，并由每个接收层删除。每层为上述一个提供服务，以使其免受不必要的细节的影响。

descends to the physical transmission medium. The message is then sent to the des- tination. Each level of the protocol family on the receiving end will check the mes- sage at its level and peel off its headers and trailers, passing it on to the next higher level and putting the pieces back together. This nesting of protocol layers for a spe- cific message is called a _protocol stack_, reflecting the last in, first out nature of the addition and removal of headers and trailers.

> 下降到物理传输介质。然后将消息发送到删除。接收端的协议家族的每个级别都会在其水平上检查 Mes-sage，并剥离其标题和拖车，将其传递到下一个更高级别，并将零件放回原处。针对特定消息的协议层的嵌套称为_protocol stack_，反映了最后一个，首先出现的添加和删除标题和拖车的性质。

As in our analogy, the danger in this layered approach is the considerable latency added to message delivery. Clearly, one way to reduce latency is to reduce the number of layers, but keep in mind that protocol families define a standard but do not force how to implement the standard. Just as there are many ways to imple- ment an instruction set architecture, there are many ways to implement a protocol family.

> 就像我们的类比一样，这种分层方法的危险是消息传递的相当延迟。显然，减少延迟的一种方法是减少层的数量，但请记住，协议系列定义了标准，但不要强迫如何实施标准。正如有很多方法可以实施指令集体系结构一样，有很多方法可以实施协议系列。

Our protocol stack example is TCP/IP. Let’s assume that the bottom protocol layer is Ethernet. The next level up is the Internet Protocol or IP layer; the official term for an IP packet is a datagram. The IP layer routes the datagram to the des- tination machine, which may involve many intermediate machines or switches. IP makes a best effort to deliver the packets but does not guarantee delivery, content, or order of datagrams. The TCP layer above IP makes the guarantee of reliable, in- order delivery and prevents corruption of datagrams.

> 我们的协议堆栈示例是 TCP/IP。假设底部协议层是以太网。下一个级别是 Internet 协议或 IP 层；IP 数据包的官方术语是数据报。IP 层将数据报路线路由到定位机，这可能涉及许多中间机或开关。IP 尽力交付数据包，但不能保证数据报的交付，内容或顺序。IP 上方的 TCP 层可保证可靠的，订单交付并防止数据报的损坏。

Following the example in [Figure F.37](#_bookmark633), assume an application program wants to send a message to a machine via an Ethernet. It starts with TCP. The largest number of bytes that can be sent at once is 64 KB. Since the data may be much larger than 64 KB, TCP must divide them into smaller segments and reassemble them in proper order upon arrival. TCP adds a 20-byte header ([Figure F.38](#_bookmark634)) to every data- gram and passes them down to IP. The IP layer above the physical layer adds a 20-byte header, also shown in [Figure F.38](#_bookmark634). The data sent down from the IP level to the Ethernet are sent in packets with the format shown in [Figure F.30](#_bookmark627). Note that the TCP packet appears inside the data portion of the IP datagram, just as [Figure F.37](#_bookmark633) suggests.

> 在[图 F.37]（#_ Bookmark633）中的示例之后，假设应用程序希望通过以太网将消息发送给计算机。它从 TCP 开始。可以立即发送的最多字节数为 64 kb。由于数据可能大于 64 kb，因此 TCP 必须将它们分为较小的细分市场，并在到达时以适当的顺序重新组装它们。TCP 添加了一个 20 字节的标题（[图 F.38]（#_ bookmark634））到每个数据革兰器中，并将其传递给 IP。物理层上方的 IP 层添加了一个 20 字节的标头，也显示了[图 F.38]（#_ bookmark634）。从 IP 级别发送到以太网的数据以数据包发送，其格式[图 F.30]（#_ bookmark627）中显示。请注意，TCP 数据包出现在 IP 数据报的数据部分内，就像[图 F.37]（#_ bookmark633）所建议的那样。

Figure F.38 The headers for IP and TCP. This drawing is 32 bits wide. The standard headers for both are 20 bytes, but both allow the headers to optionally lengthen for rarely transmitted information. Both headers have a length of header field (L) to accommodate the optional fields, as well as source and destination fields. The length field of the whole datagram is in a separate length field in IP, while TCP combines the length of the datagram with the sequence number of the datagram by giving the sequence number in bytes. TCP uses the checksum field to be sure that the datagram is not corrupted, and the sequence number field to be sure the datagrams are assembled into the proper order when they arrive. IP provides checksum error detection only for the header, since TCP has protected the rest of the packet. One optimization is that TCP can send a sequence of datagrams before waiting for permission to send more. The number of datagrams that can be sent without waiting for approval is called the _window_, and the window field tells how many bytes may be sent beyond the byte being acknowledged by this datagram. TCP will adjust the size of the window depending on the success of the IP layer in sending datagrams; the more reliable and faster it is, the larger TCP makes the window. Since the window slides forward as the data arrive and are acknowledged, this technique is called a _sliding window protocol._ The piggyback acknowledgment field of TCP is another optimization. Since some applications send data back and forth over the same connection, it seems wasteful to send a datagram containing only an acknowledgment. This piggyback field allows a datagram carrying data to also carry the acknowl- edgment for a previous transmission, “piggybacking” on top of a data transmission. The urgent pointer field of TCP gives the address within the datagram of an important byte, such as a break character. This pointer allows the appli- cation software to skip over data so that the user doesn’t have to wait for all prior data to be processed before seeing a character that tells the software to stop. The identifier field and fragment field of IP allow intermediary machines to break the original datagram into many smaller datagrams. A unique identifier is associated with the original datagram and placed in every fragment, with the fragment field saying which piece is which. The time-to-live field allows a datagram to be killed off after going through a maximum number of intermediate switches no matter where it is in the network. Knowing the maximum number of hops that it will take for a datagram to arrive—if it ever arrives—simplifies the protocol software. The protocol field identifies which possible upper layer protocol sent the IP datagram; in our case, it is TCP. The V (for version) and type fields allow different versions of the IP protocol software for the network. Explicit version numbering is included so that software can be upgraded gracefully machine by machine, without shutting down the entire network. Nowadays, version six of the Internet protocol (IPv6) was widely used.

> 图 F.38 IP 和 TCP 的标题。这张图是 32 位宽。两者的标准标题为 20 个字节，但两者都可以选择延长标题以获取很少传输的信息。两个标头都有一个长度的标头字段（L），以适应可选字段以及源和目的地字段。整个数据报的长度字段位于 IP 中的单独长度字段中，而 TCP 通过在字节中给出序列号，将数据报的长度与数据报的序列编号结合在一起。TCP 使用校验和字段来确保数据报未损坏，并且序列号字段确保数据报到到达时将其组装成正确的顺序。IP 仅为标题提供校验和错误检测，因为 TCP 保护了数据包的其余部分。一种优化是，在等待许可发送更多信息之前，TCP 可以发送一系列数据报。无需等待批准即可发送的数据报数量称为_Window__，窗口字段告诉本数据报所确认的字节以外的字节可以发送多少个字节。TCP 将根据发送数据报时 IP 层的成功调整窗口的大小；它越可靠，越快，TCP 就会使窗口更大。由于随着数据到达并得到确认，窗口向前滑动，因此该技术称为_ sliding 窗口协议。由于某些应用程序通过相同的连接来回发送数据，因此仅发送包含确认的数据报似乎很浪费。这个背包字段允许携带数据的数据报，还可以携带以前的传输，即在数据传输之上的“背带”的确认。TCP 的紧急指针字段给出了重要字节的数据报中的地址，例如断路字符。该指针允许应用程序软件跳过数据，以便用户不必等待所有先前数据的处理，然后才能看到告诉软件停止的字符。IP 的标识符字段和片段字段允许中介机器将原始数据报分解为许多较小的数据报。唯一的标识符与原始数据报关联并放置在每个片段中，片段字段说哪个是哪个。到期的时间字段允许在网络中遍历最大数量的中间交换机后杀死数据报。知道数据报到达（如果到达的话）将需要的最大啤酒花数量可以简化协议软件。协议字段标识了哪些可能的上层协议发送了 IP 数据报；在我们的情况下，是 TCP。V（用于版本）和类型字段允许网络的 IP 协议软件的不同版本。包括显式版本编号，以便可以通过机器优雅地升级软件，而无需关闭整个网络。如今，广泛使用了 Internet 协议（IPv6）的第六版。
