## The VAX Architecture

_VAX: the most successful minicomputer design in industry history . . . the VAX was probably the hacker’s favorite machine . . . . Especially noted for its large, assembler-programmer-friendly instruction set—an asset that became a liability after the RISC revolution._

> \_VAX：行业历史上最成功的微型计算机设计。。。VAX 可能是黑客最喜欢的机器。。。。特别是因为它的大型汇编程序制品器友好的指令套装而闻名，这是 Risc Revolution 之后的责任。

_The New Hacker’s Dictionary_ (1991)

### Introduction

To enhance your understanding of instruction set architectures, we chose the VAX as the representative _Complex Instruction Set Computer_ (CISC) because it is so differ- ent from MIPS and yet still easy to understand. By seeing two such divergent styles, we are confident that you will be able to learn other instruction sets on your own. At the time the VAX was designed, the prevailing philosophy was to create instruction sets that were close to programming languages in order to simplify compilers. For example, because programming languages had loops, instruction sets should have loop instructions. As VAX architect William Strecker said ( "VAX-11/780—A Virtual Address Extension to the PDP-11 Family," _AFIPS_

> 为了增强您对教学设置体系结构的理解，我们选择了 VAX 作为代表性 *complex 指令集 Computer*(CISC)，因为它与 MIPS 有很大不同，但仍然易于理解。通过看到两种这种不同的样式，我们有信心您可以自己学习其他说明集。在设计 VAX 时，现行的理念是创建与编程语言接近的指令集，以简化编译器。例如，由于编程语言具有循环，因此指令集应具有循环说明。正如 Vax 工程师 William Strecker 所说( " VAX-11/780 - PDP-11 家族的虚拟地址扩展" ，" _AFIPS_

_Proc.,_ National Computer Conference, 1978):

A major goal of the VAX-11 instruction set was to provide for effective compiler generated code. Four decisions helped to realize this goal: 1) A very regular and consistent treatment of operators 2) An avoidance of instructions unlikely to be generated by a compiler 3) Inclusions of several forms of common operators 4) Replacement of common instruction sequences with single instructions Examples include procedure calling, multiway branching, loop control, and array subscript calculation.

> VAX-11 指令集的主要目标是提供有效的编译器生成的代码。四个决定有助于实现这一目标：1)对操作员的非常规定且一致的处理 2)编译器不太可能产生指令 3)几种形式的常见操作员的夹杂物 4)用单个说明替换通用指令序列示例包括程序调用，多路分支，循环控制和数组下标计算。

Recall that DRAMs of the mid-1970s contained less than 1/1000th the capacity of today’s DRAMs, so code space was also critical. Hence, another prevailing phi- losophy was to minimize code size, which is de-emphasized in fixed-length instruction sets like MIPS. For example, MIPS address fields always use 16 bits, even when the address is very small. In contrast, the VAX allows instructions to be a variable number of bytes, so there is little wasted space in address fields.

> 回想一下，1970 年代中期的 DRAM 含量不到当今 DRAM 的容量不到 1/1000，因此代码空间也至关重要。因此，另一个流行的液化是将代码尺寸最小化，这在 MIPS 等固定长度指令集中被取消强调。例如，即使地址很小，MIPS 地址字段也始终使用 16 位。相比之下，VAX 允许指令是可变数量的字节，因此地址字段中几乎没有浪费的空间。

Whole books have been written just about the VAX, so this VAX extension cannot be exhaustive. Hence, the following sections describe only a few of its addressing modes and instructions. To show the VAX instructions in action, later sections show VAX assembly code for two C procedures. The general style will be to contrast these instructions with the MIPS code that you are already familiar with. The differing goals for VAX and MIPS have led to very different architectures.

> 整本书都是关于 VAX 的文章，因此这种 VAX 扩展不可能详尽。因此，以下各节仅描述了其几个寻址模式和说明。为了显示行动中的 VAX 指令，后来的部分显示了两个 C 程序的 VAX 汇编代码。一般样式将是将这些说明与您已经熟悉的 MIPS 代码进行对比。VAX 和 MIP 的不同目标导致了截然不同的架构。

The VAX goals, simple compilers and code density, led to the powerful addressing modes, powerful instructions, and efficient instruction encoding. The MIPS goals were high performance via pipelining, ease of hardware implementation, and com- patibility with highly optimizing compilers. The MIPS goals led to simple instruc- tions, simple addressing modes, fixed-length instruction formats, and a large number of registers.

> VAX 目标，简单的编译器和代码密度，导致了强大的寻址模式，强大的说明和有效的指令编码。MIPS 的目标是通过管道，易于实施的易于实施，并与高度优化的编译器合并。MIPS 目标导致了简单的指导，简单的解决模式，固定长度指令格式和大量寄存器。

### VAX Operands and Addressing Modes

The VAX is a 32-bit architecture, with 32-bit-wide addresses and 32-bit-wide reg- isters. Yet, the VAX supports many other data sizes and types, as [Figure K.49](#_bookmark889) shows. Unfortunately, VAX uses the name "word" to refer to 16-bit quantities; in this text, a word means 32 bits. [Figure K.49](#_bookmark889) shows the conversion between the MIPS data type names and the VAX names. Be careful when reading about VAX instructions, as they refer to the names of the VAX data types.

> VAX 是一个 32 位架构，具有 32 位宽的地址和 32 位宽的寄存器。然而，VAX 支持许多其他数据大小和类型，如 [图 K.49](#_bookmark889) 所示。不幸的是，VAX 使用名称 "字" 来指代 16 位数量；在本文中，一个字表示 32 位。[图 K.49](#_bookmark889) 显示了 MIPS 数据类型名称和 VAX 名称之间的转换。阅读 VAX 指令时要小心，因为它们引用了 VAX 数据类型的名称。

Figure K.49 VAX data types, their lengths, and names. The first letter of the VAX type (b, w, l, f, q, d, g, c) is often used to complete an instruction name. Examples of move instructions include movb, movw, movl, movf, movq, movd, movg, and movc3. Each move instruction transfers an operand of the data type indicated by the letter following mov.

> 图 K.49 VAX 数据类型，其长度和名称。VAX 类型的第一个字母(B，W，L，F，Q，D，G，C)通常用于完成指令名称。移动说明的示例包括 MOVB，MOVW，MOVL，MOVF，MOVQ，MOVD，MOVG 和 MOVC3。每次移动指令都会传输由字母以下 MOV 指示的数据类型的操作数。

The VAX provides sixteen 32-bit registers. The VAX assembler uses the notation r0, r1, ..., r15 to refer to these registers, and we will stick to that notation. Alas, 4 of these 16 registers are effectively claimed by the instruction set architecture. For example, r14 is the stack pointer (sp) and r15 is the program counter (pc). Hence, r15 cannot be used as a general-purpose register, and using r14 is very difficult because it interferes with instructions that manipulate the stack. The other dedicated registers are r12, used as the argument pointer (ap), and r13, used as the frame pointer (fp); their purpose will become clear later. (Like MIPS, the VAX assembler accepts either the register number or the register name.)

> VAX 提供了 16 位 32 位登记册。VAX 汇编器使用符号 R0，R1，...，R15 来引用这些寄存器，我们将坚持使用该符号。las，这 16 个寄存器中有 4 个由指令集体系结构有效地要求。例如，R14 是堆栈指针(SP)，R15 是程序计数器(PC)。因此，R15 不能用作通用寄存器，并且使用 R14 非常困难，因为它会干扰操纵堆栈的说明。其他专用寄存器是 R12，用作参数指针(AP)和 R13，用作帧指针(FP)；他们的目的将在以后变得明确。(就像 MIPS 一样，VAX 汇编器接受寄存器号或寄存器名称。)

VAX addressing modes include those discussed in Appendix A, which has all the MIPS addressing modes: _register, displacement, immediate_, and _PC-relative_. Moreover, all these modes can be used for jump addresses or for data addresses. But that’s not all the addressing modes. To reduce code size, the VAX has three lengths of addresses for displacement addressing: 8-bit, 16-bit, and 32-bit addresses called, respectively, _byte displacement, word displacement_, and _long displacement_ addressing. Thus, an address can be not only as small as possible but also as large as necessary; large addresses need not be split, so there is no equivalent to the MIPS lui instruction (see Figure A.24 on page A-37).

> VAX 地址模式包括附录 A 中讨论的那些，该模式具有所有 MIPS 地址模式的 MIPS：*REGISTER，EXPACENTENT，AIMSICEMENT，AIMSTICE* 和 *PC-RELATION*。此外，所有这些模式都可以用于跳跃地址或数据地址。但这并不是所有的寻址模式。为了减少代码大小，VAX 具有三个用于位移地址的地址：8 位，16 位和 32 位地址，分别称为 *byte Expracement，Word Expracement* 和 *long Expinacement* 地址。因此，地址不仅可以尽可能小，而且可以在必要时尽可能大。大型地址不必分开，因此与 MIPS LUI 指令无关(请参阅第 A-37 页的图 A.24)。

Those are still not all the VAX addressing modes. Several have a _deferred_ option, meaning that the object addressed is only the _address_ of the real object, requiring another memory access to get the operand. This addressing mode is called _indirect addressing_ in other machines. Thus, _register deferred, autoincre- ment deferred_, and _byte/word/long displacement deferred_ are other addressing modes to choose from. For example, using the notation of the VAX assembler, r1 means the operand is register 1 and (r1) means the operand is the location in memory pointed to by r1.

> 这些仍然不是所有 VAX 地址模式。有几个具有 *deferred* 选项，这意味着地址的对象仅是真实对象的 *address*，需要其他内存访问才能获取操作数。此地址模式在其他机器中称为* indirect aderteming*。因此，*register 延期，自动递延*和\_byte/word/long 置换术是其他可供选择的地址模式。例如，使用 VAX 汇编器的符号，R1 表示操作数为寄存器 1，(R1)表示操作数是记忆中指向 R1 的位置。

There is yet another addressing mode. _Indexed addressing_ automatically con- verts the value in an index operand to the proper byte address to add to the rest of the address. For a 32-bit word, we needed to multiply the index of a 4-byte quantity by 4 before adding it to a base address. Indexed addressing, called _scaled addres- sing_ on some computers, automatically multiplies the index of a 4-byte quantity by 4 as part of the address calculation.

> 还有另一个寻址模式。* indexed propstracting *自动将索引操作数中的值与正确的字节地址相关，以添加到其余地址。对于一个 32 位单词，我们需要将 4 字节数量的索引乘以 4，然后再将其添加到基础地址。在某些计算机上称为* Scaled addres-sing*的索引地址将 4 字节数量的索引自动乘以 4 个字节的索引，作为地址计算的一部分。

To cope with such a plethora of addressing options, the VAX architecture separates the specification of the addressing mode from the specification of the operation. Hence, the opcode supplies the operation and the number of oper- ands, and each operand has its own addressing mode specifier. [Figure K.50](#_bookmark890) shows the name, assembler notation, example, meaning, and length of the address specifier.

> 为了应对如此多的解决选项，VAX 体系结构将寻址模式的规范与操作规范分开。因此，OpCode 提供操作和操作数量，每个操作数都有其自己的寻址模式指示符。[图 K.50](#_bookmark890) 显示了地址指定符的名称，汇编符号，示例，含义和长度。

The VAX style of addressing means that an operation doesn’t know where its operands come from; a VAX add instruction can have three operands in registers, three operands in memory, or any combination of registers and memory operands.

> 解决方案的 VAX 风格意味着操作不知道其操作数来自何处；VAX 添加指令可以在寄存器中包含三个操作数，三个操作数或记忆和内存操作数的任何组合。

Figure K.50 Definition and length of the VAX operand specifiers. The length of each addressing mode is 1 byte plus the length of any displacement or immediate field needed by the mode. Literal mode uses a special 2-bit tag and the remaining 6 bits encode the constant value. If the constant is too big, it must use the immediate addressing mode. Note that the length of an immediate operand is dictated by the length of the data type indicated in the opcode, not the value of the immediate. The symbol _d_ in the last four modes represents the length of the data in bytes; _d_ is 4 for 32-bit add.

> 图 K.50 VAX 操作数指定符的定义和长度。每个寻址模式的长度为 1 个字节加上模式所需的任何位移或直接字段的长度。文字模式使用特殊的 2 位标签，其余 6 位编码常数。如果常数太大，则必须使用即时的寻址模式。请注意，直接操作数的长度由 OPODE 中指示的数据类型的长度决定，而不是即时的值。最后四个模式中的符号 *d* 表示字节中数据的长度；*d* 为 32 位添加 4。

Example How long is the following instruction?

> 示例以下指令多长时间？

The name addl3 means a 32-bit add instruction with three operands. Assume the length of the VAX opcode is 1 byte.

> 名称 addl3 表示带有三个操作数的 32 位添加指令。假设 VAX OpCode 的长度为 1 个字节。

_Answer_ The first operand specifier—r1—indicates register addressing and is 1 byte long. The second operand specifier—737(r2)—indicates displacement addressing and has two parts: The first part is a byte that specifies the word displacement addressing mode and base register (r2); the second part is the 2-byte-long dis- placement (737). The third operand specifier—(r3)\[r4]—also has two parts: The first byte specifies register deferred addressing mode ((r3)), and the second byte specifies the Index register and the use of indexed addressing (\[r4]). Thus, the

> *answer *第一个操作数指示符-R1 指示寄存器地址，为 1 个字节长。第二个操作数指数(737(R2))指示位移地址，并有两个部分：第一部分是一个字节，指定单词位移地址模式和基本寄存器(R2)；第二部分是 2 字节长的分位(737)。第三个操作数指数 - (r3)\ [r4 ] - 也有两个部分：第一个字节指定寄存器递延地址模式(((r3))，第二个字节指定索引寄存器和使用索引的地址(\ [\ [\ [\ [R4 ])。就这样

In this example instruction, we show the VAX destination operand on the left and the source operands on the right, just as we show MIPS code. The VAX assembler actually expects operands in the opposite order, but we felt it would be less con- fusing to keep the destination on the left for both machines. Obviously, left or right orientation is arbitrary; the only requirement is consistency.

> 在此示例指令中，我们在显示 MIPS 代码时显示了左侧的 VAX 目标操作数，右侧的源操作数在右侧。VAX 汇编器实际上期望操作数以相反的顺序，但是我们认为将两台机器的左侧目的地保持在目的地的范围较小。显然，左或右向是任意的。唯一的要求是一致性。

Elaboration Because the PC is 1 of the 16 registers that can be selected in a VAX addressing mode, 4 of the 22 VAX addressing modes are synthesized from other addressing modes. Using the PC as the chosen register in each case, immediate addressing is really autoincrement, PC-relative is displacement, absolute is autoincrement deferred, and relative deferred is displacement deferred.

> 详细说明，因为 PC 是可以在 VAX 地址模式下选择的 16 个寄存器中的 1 个，因此从其他地址模式中合成了 22 个 VAX 地址模式中的 4 个。在每种情况下，使用 PC 作为所选寄存器，即时地址确实是自动插入的，PC 相关的位移，绝对是自动递延的，并且相对递延的位移延迟。

### Encoding VAX Instructions

Given the independence of the operations and addressing modes, the encoding of instructions is quite different from MIPS.

> 鉴于操作和寻址模式的独立性，指令的编码与 MIPS 完全不同。

VAX instructions begin with a single byte opcode containing the operation and the number of operands. The operands follow the opcode. Each operand begins with a single byte, called the _address specifier_, that describes the addressing mode for that operand. For a simple addressing mode, such as register addressing, this byte specifies the register number as well as the mode (see the rightmost column in [Figure K.50](#_bookmark890)). In other cases, this initial byte can be followed by many more bytes to specify the rest of the address information.

> VAX 指令以一个包含操作和操作数的单个字节 OPCODE 开始。操作数遵循操作码。每个操作数以一个名为 *address specifier* 的单个字节开始，该字节描述了该操作数的地址模式。对于简单的寻址模式，例如寄存器地址，该字节指定寄存器号和模式(请参阅[图 K.50](#_bookmark890) 中的最右列)。在其他情况下，可以遵循更多字节，以指定其余的地址信息。

As a specific example, let’s show the encoding of the add instruction from the example on page K-24:

> 作为一个具体示例，让我们从第 K-24 页的示例中展示添加指令的编码：

[Figure K.51](#_bookmark891) shows the encoding. Note that the operands are stored in memory in opposite order to the assembly code above. The execution of VAX instructions begins with fetching the source operands, so it makes sense for them to come first. Order is not important in fixed-length instructions like MIPS, since the source and destination operands are easily found within a 32-bit word.

> [图 K.51](#_bookmark891) 显示编码。请注意，操作数以与上述汇编代码相反的顺序存储在内存中。VAX 指令的执行从获取源操作数开始，因此将它们放在第一位是有意义的。在像 MIPS 这样的固定长度指令中，顺序并不重要，因为源操作数和目标操作数很容易在 32 位字中找到。

Figure K.51 The encoding of the VAX instruction addl3 r1,737(r2),(r3)\[r4], assuming it starts at address 201. To satisfy your curiosity, the right column shows the actual VAX encoding in hexadecimal notation. Note that the 16-bit constant 737<sub>ten</sub> takes 2 bytes.

> 图 K.51 VAX 指令的编码 addl3 r1,737(r2)，(r3)\ [r4 ]，假设它从地址开始 201。为了满足您的好奇心，右列显示了实际的 VAX 编码中的实际 VAX，则在 Hexadecimal note 中进行了编码。。请注意，16 位常数 737 <sub>十</sub>采用 2 个字节。

The first byte, at location 201, is the opcode. The next byte, at location 202, is a specifier for the index mode using register r4. Like many of the other specifiers, the left 4 bits of the specifier give the mode and the right 4 bits give the register used in that mode. Since addl3 is a 4-byte operation, r4 will be multiplied by 4 and added to whatever address is specified next. In this case it is register deferred addressing using register r3. Thus, bytes 202 and 203 combined define the third operand in the assembly code.

> 位置 201 处的第一个字节是 OpCode。下一个字节，位置 202，是使用寄存器 R4 的索引模式的指定符。像许多其他指示符一样，指定符的左 4 位给出了模式，右 4 位给出了该模式下使用的寄存器。由于 ADDL3 是一个 4 字节操作，因此 R4 将乘以 4，并添加到接下来指定的任何地址中。在这种情况下，它是使用寄存器 R3 的登记递延地址。因此，Bytes 202 和 203 合并了组装代码中的第三个操作数。

The following byte, at address 204, is a specifier for word displacement addres- sing using register r2 as the base register. This specifier tells the VAX that the fol- lowing two bytes, locations 205 and 206, contain a 16-bit address to be added to r2.

> 以下字节(在地址 204)是使用寄存器 R2 作为基本寄存器的单词位移 addressing 的指定符。该说明符告诉 VAX，两个字节的位置 205 和 206，包含一个 16 位地址，要添加到 R2 中。

The final byte of the instruction gives the destination operand, and this specifier selects register addressing using register r1.

> 指令的最终字节给出了目标操作数，该规范符选择使用寄存器 R1 的寄存器地址。

Such variability in addressing means that a single VAX operation can have many different lengths; for example, an integer add varies from 3 bytes to 19 bytes. VAX implementations must decode the first operand before they can find the sec- ond, and so implementors are strongly tempted to take 1 clock cycle to decode each operand; thus, this sophisticated instruction set architecture can result in higher clock cycles per instruction, even when using simple addresses.

> 解决方案的这种差异意味着单个 VAX 操作可以具有许多不同的长度。例如，整数添加从 3 个字节到 19 个字节不等。VAX 实现必须在找到 sec-ond 之前解码第一操作数，因此实现者强烈试图使用 1 个时钟周期来解码每个操作数。因此，即使使用简单的地址，这种复杂的指令集体系结构也可能导致每个指令的时钟周期更高。

### VAX Operations

In keeping with its philosophy, the VAX has a large number of operations as well as a large number of addressing modes. We review a few here to give the flavor of the machine.

> 为了保持其理念，VAX 具有大量的操作以及大量的寻址模式。我们在这里回顾一些以赋予机器的风味。

Given the power of the addressing modes, the VAX _move_ instruction performs several operations found in other machines. It transfers data between any two addressable locations and subsumes load, store, register-register moves, and memory-memory moves as special cases. The first letter of the VAX data type (b, w, l, f, q, d, g, c in [Figure K.49](#_bookmark889)) is appended to the acronym mov to determine the size of the data. One special move, called _move address_, moves the 32-bit _address_ of the operand rather than the data. It uses the acronym mova.

> 给定寻址模式的功能，VAX *MOVE* 指令执行其他机器中发现的几个操作。它在任意两个可寻址的位置和元素加载，存储，注册注册移动和内存记忆移动之间传输数据。VAX 数据类型的第一个字母(b，w，l，f，q，d，g，c，c in [图 k.49](#_bookmark889))附加到首字母缩略词 mov 以确定数据的大小。一个称为* move 地址的特殊举动移动操作数的 32 位\_address*而不是数据。它使用首字母缩写 Mova。

The arithmetic operations of MIPS are also found in the VAX, with two major differences. First, the type of the data is attached to the name. Thus, addb, addw, and addl operate on 8-bit, 16-bit, and 32-bit data in memory or registers, respec- tively; MIPS has a single add instruction that operates only on the full 32-bit reg- ister. The second difference is that to reduce code size the add instruction specifies the number of unique operands; MIPS always specifies three even if one operand is redundant. For example, the MIPS instruction add $1, $1, $2 takes 32 bits like all MIPS instructions, but the VAX instruction uses r1 for both the destination and a source, taking just 24 bits: 8 bits for the opcode and 8 bits each for the two register specifiers.

> MIP 的算术操作在 VAX 中也发现了两个主要差异。首先，将数据的类型附加到名称上。因此，ADDB，ADDW 和 ADDL 在记忆或寄存器中的 8 位，16 位和 32 位数据上运行；MIPS 具有一个单一的添加指令，仅在完整的 32 位 reg-Ister 上运行。第二个区别是要减少代码大小，添加指令指定了唯一操作数的数量；MIP 始终指定三个操作数，即使一个操作数是多余的。例如，MIPS 指令加上$ 1，$ 1，$ 2 像所有 MIPS 指令一样服用 32 位，但是 VAX 指令使用 R1 用于目的地和源，仅需 24 位：opcode 的 8 位和 8 位用于两个寄存器指定符。

##### _Number of Operations_

Now we can show how VAX instruction names are formed:

> 现在，我们可以展示如何形成 VAX 指令名称：

The operation add works with data types byte, word, long, float, and double and comes in versions for either 2 or 3 unique operands, so the following instructions are all found in the VAX:

> 操作添加与数据类型，单词，长，浮动和双重配合使用，并配备 2 或 3 个唯一操作数的版本，因此在 VAX 中找到了以下说明：

Accounting for all addressing modes (but ignoring register numbers and immediate values) and limiting to just byte, word, and long, there are more than 30,000 ver- sions of integer add in the VAX; MIPS has just 4!

> 考虑所有寻址模式(但忽略寄存器号和即时值)，并限制仅限字节，单词和长时间，在 VAX 中有 30,000 多个整数添加；MIPS 只有 4 个！

Another reason for the large number of VAX instructions is the instructions that either replace sequences of instructions or take fewer bytes to represent a sin- gle instruction. Here are four such examples (\* means the data type):

> 大量 VAX 指令的另一个原因是指令要么替换指令序列或更少的字节来代表 single 指令。这是四个这样的示例(\*表示数据类型)：

The _push_ instruction in the last row is exactly the same as using the move instruc- tion with autodecrement addressing on the stack pointer:

> 最后一行中的 *push* 指令与使用堆栈指针上的自动编码寻址的移动指令完全相同：

Brevity is the advantage of pushl: It is 1 byte shorter since sp is implied.

> 简洁是 PUSHL 的优点：由于隐含 SP，它是 1 字节短的。

##### _Branches, Jumps, and Procedure Calls_

The VAX branch instructions are related to the arithmetic instructions because the branch instructions rely on _condition codes_. Condition codes are set as a side effect of an operation, and they indicate whether the result is positive, negative, or zero or if an overflow occurred. Most instructions set the VAX condition codes according to their result; instructions without results, such as branches, do not. The VAX con- dition codes are N (Negative), Z (Zero), V (oVerflow), and C (Carry). There is also a _compare_ instruction cmp\* just to set the condition codes for a subsequent branch. The VAX branch instructions include all conditions. Popular branch instruc- tions include beql(=), bneq( ), blss(<), bleq( ), bgtr(>), and bgeq( ), which do just what you would expect. There are also unconditional branches whose name is determined by the size of the PC-relative offset. Thus, brb (_branch byte_) has an 8-bit displacement, and brw (_branch word_) has a 16-bit displacement.

> VAX 分支指令与算术指令有关，因为分支指令依赖于*条件代码*。条件代码设置为操作的副作用，它们指示结果是正，负还是零或是否发生溢出。大多数指令根据其结果设置 VAX 条件代码；没有结果(例如分支机构)的说明没有。vax 构造代码为 n(负)，z(零)，v(溢出)和 c(携带)。还有一个 *compare* 指令 cmp \*只是为了设置后续分支的条件代码。VAX 分支说明包括所有条件。流行的分支指导包括 Beql(=)，Bneq()，blss(<)，bleq()，bgtr(>)和 bgeq()，它们正是您所期望的。也有无条件的分支，其名称由 PC 搭乘偏移量的大小决定。因此，brb(_branch byte_)具有 8 位位移，而 BRW(_Branch Word_)具有 16 位的位移。

The final major category we cover here is the procedure _call and return_ instruc- tions. Unlike the MIPS architecture, these elaborate instructions can take dozens of clock cycles to execute. The next two sections show how they work, but we need to explain the purpose of the pointers associated with the stack manipulated by calls and ret. The _stack pointer_, sp, is just like the stack pointer in MIPS; it points to the top of the stack. The _argument pointer_, ap, points to the base of the list of arguments or parameters in memory that are passed to the procedure. The _frame pointer_, fp, points to the base of the local variables of the procedure that are kept in memory (the _stack frame_). The VAX call and return instructions manipulate these pointers to maintain the stack in proper condition across procedure calls and to provide conve- nient base registers to use when accessing memory operands. As we shall see, call and return also save and restore the general-purpose registers as well as the program counter. [Figure K.52](#_bookmark892) gives a further sampling of the VAX instruction set.

> 我们在这里涵盖的最终主要类别是过程 *call 和 return* Instructions。与 MIPS 体系结构不同，这些精致的说明可能需要数十个时钟周期来执行。接下来的两个部分显示了它们的工作原理，但是我们需要解释与通话和 RET 操纵的堆栈相关的指针的目的。_ stack Pointer_，Sp，就像 MIPS 中的堆栈指针一样；它指向堆栈的顶部。_argument Pointer_，AP 指向传递给过程中的参数或参数列表的基础。_frame Pointer_，fp 指向保存在内存中的过程的本地变量的底座(_STACK 帧_)。VAX 呼叫和返回指令操纵这些指针，以在过程调用中保持适当条件的堆栈，并在访问内存操作数时提供供应的基本寄存器。正如我们将看到的，请致电和返回还保存和恢复通用寄存器以及程序计数器。[图 K.52](#_bookmark892) 进一步对 VAX 指令集进行了抽样。

### An Example to Put It All Together: swap

To see programming in VAX assembly language, we translate two C procedures, swap and sort. The C code for swap is reproduced in [Figure K.53](#_bookmark893). The next section covers sort.

> 要在 VAX 汇编语言中查看编程，我们翻译了两个 C 程序，即交换和排序。[图 K.53](#_bookmark893) 中复制了交换的 C 代码。下一部分涵盖排序。

We describe the swap procedure in three general steps of assembly language programming:

> 我们在汇编语言编程的三个一般步骤中描述了交换过程：

1. Allocate registers to program variables.
2. Produce code for the body of the procedure.
3. Preserve registers across the procedure invocation.

Figure K.52 Classes of VAX instructions with examples. The asterisk stands for multiple data types: b, w, l, d, f, g, h, and q. The underline, as in addd\_, means there are 2-operand (addd2) and 3-operand (addd3) forms of this instruction.

> 图 k.52 vax 指令类带有示例。星号代表多种数据类型：B，W，L，D，F，G，H 和 Q。按照 ADDD \ \_中的下划线表示此说明的 2- operand(addd2)和 3- operand(addd3)表格。

Figure K.53 A C procedure that swaps two locations in memory. This procedure will be used in the sorting example in the next section.

> 图 K.53 C 程序在内存中交换两个位置。该过程将在下一节的分类示例中使用。

The VAX code for these procedures is based on code produced by the VMS C compiler using optimization.

> 这些过程的 VAX 代码基于使用优化的 VMS C 编译器生成的代码。

##### _Register Allocation for swap_

In contrast to MIPS, VAX parameters are normally allocated to memory, so this step of assembly language programming is more properly called "variable alloca- tion." The standard VAX convention on parameter passing is to use the stack. The two parameters, v\[] and k, can be accessed using register ap, the argument pointer: The address 4(ap) corresponds to v\[] and 8(ap) corresponds to k. Remember that with byte addressing the address of sequential 4-byte words differs by 4. The only other variable is temp, which we associate with register r3.

> 与 MIPS 相反，VAX 参数通常分配给内存，因此汇编语言编程的此步骤更恰当地称为 "可变分配" 。参数传递的标准 VAX 约定是使用堆栈。可以使用寄存器 AP，参数指针：地址 4(ap)对应于 v \ []和 8(ap)对应于 k。请记住，通过 BYTE 解决顺序 4 字节单词的地址的情况下，唯一的另一个变量是临时，我们将其与寄存器 R3 关联。

##### _Code for the Body of the Procedure swap_

Unlike the MIPS code, which is basically two loads and two stores, the key VAX code is one memory-to-register move, one memory-to-memory move, and one register-to-memory move. Note that the addl3 instruction shows the flexibility of the VAX addressing modes: It adds the constant 1 to a memory operand and places the result in a register.

> 与 MIPS 代码(基本上是两个负载和两个商店)不同，关键 VAX 代码是一个内存到注册的移动，一个内存到记忆的移动以及一个寄存器到记忆的移动。请注意，ADDL3 指令显示了 VAX 地址模式的灵活性：它将常数 1 添加到内存操作数，并将结果放入寄存器中。

Now we have allocated storage and written the code to perform the operations of the procedure. The only missing item is the code that preserves registers across the routine that calls swap.

> 现在，我们已经分配了存储并编写了代码以执行过程的操作。唯一缺少的项目是保留在调用交换的例程中保存寄存器的代码。

##### _Preserving Registers across Procedure Invocation of swap_

The VAX has a pair of instructions that preserve registers, calls and ret. This example shows how they work.

> VAX 有一对保留寄存器，呼叫和 ret 的说明。此示例显示了它们的工作方式。

The VAX C compiler uses a form of callee convention. Examining the code above, we see that the values in registers r0, r1, r2, and r3 must be saved so that they can later be restored. The calls instruction expects a 16-bit mask at the beginning of the procedure to determine which registers are saved: if bit _i_ is set in the mask, then register _i_ is saved on the stack by the calls instruction. In addition, calls saves this mask on the stack to allow the return instruction (ret) to restore the proper registers. Thus, the calls executed by the caller does the saving, but the callee sets the call mask to indicate what should be saved.

> VAX C 编译器使用 Callee 约定的形式。在检查上面的代码时，我们看到寄存器 R0，R1，R2 和 R3 中的值必须保存，以便以后可以恢复它们。通话指令期望在过程的开头进行 16 位掩码，以确定保存哪些寄存器：如果将 bit *i* 设置在掩码中，则通过呼叫指令将寄存器 *i* 保存在堆栈中。此外，呼叫还将此掩码保存在堆栈中，以允许返回指令(RET)还原适当的寄存器。因此，呼叫者执行的呼叫进行保存，但是 Callee 设置了调用掩码以指示应保存的内容。

One of the operands for calls gives the number of parameters being passed, so that calls can adjust the pointers associated with the stack: the argument pointer (ap), frame pointer (fp), and stack pointer (sp). Of course, calls also saves the program counter so that the procedure can return!

> 呼叫的操作数之一给出了传递参数的数量，因此呼叫可以调整与堆栈关联的指针：参数指针(AP)，帧指针(FP)和堆栈指针(SP)。当然，呼叫还可以节省程序计数器，以便该过程可以返回！

Thus, to preserve these four registers for swap, we just add the mask at the beginning of the procedure, letting the calls instruction in the caller do all the work:

> 因此，为了保留这四个寄存器进行交换，我们只需在程序开始时添加掩码，让呼叫者中的呼叫指令完成所有工作：

This directive tells the assembler to place a 16-bit constant with the proper bits set to save registers r0 through r3.

> 该指令告诉汇编程序，放置一个 16 位常数，并设置了适当的位，以节省寄存器 R0 至 R3。

The return instruction undoes the work of calls. When finished, ret sets the stack pointer from the current frame pointer to pop everything calls placed on the stack. Along the way, it restores the register values saved by calls, including those marked by the mask and old values of the fp, ap, and pc.

> 返回指令撤消了通话的工作。完成后，RET 将堆栈指针从当前的帧指针设置为弹出所有调用堆栈上的所有呼叫。一路上，它还原由呼叫保存的寄存器值，包括由 FP，AP 和 PC 的蒙版和旧值标记的寄存器值。

To complete the procedure swap, we just add one instruction:

> 要完成过程交换，我们只添加一个指令：

##### _The Full Procedure swap_

We are now ready for the whole routine. [Figure K.54](#_bookmark894) identifies each block of code with its purpose in the procedure, with the MIPS code on the left and the VAX code on the right. This example shows the advantage of the scaled indexed addressing and the sophisticated call and return instructions of the VAX in reducing the num- ber of lines of code. The 17 lines of MIPS assembly code became 8 lines of VAX assembly code. It also shows that passing parameters in memory results in extra memory accesses.

> 我们现在已经准备好整个例程了。[图 K.54](#_bookmark894) 在过程中以其目的标识每个代码的块，左侧的 MIPS 代码和右侧的 VAX 代码。此示例显示了缩放的索引寻址的优势以及 vax 的复杂呼叫和返回指令，以减少代码线的数量。MIPS 组装代码的 17 行变为 VAX 组装代码的 8 行。它还表明，内存中的传递参数会导致额外的内存访问。

Keep in mind that the number of instructions executed is not the same as per- formance; the fallacy on page K-38 makes this point.

> 请记住，执行的指令数与能力不同。第 K-38 页上的谬误使这一点。

Note that VAX software follows a convention of treating registers r0 and r1 as temporaries that are not saved across a procedure call, so the VMS C compiler does include registers r0 and r1 in the register saving mask. Also, the C compiler should have used r1 instead of 8(ap) in the addl3 instruction; such examples inspire computer architects to try to write compilers!

> 请注意，VAX 软件遵循将寄存器 R0 和 R1 视为未在过程调用中保存的临时性的约定，因此 VMS C 编译器确实在寄存器保存掩码中包含寄存器 R0 和 R1。另外，C 编译器应在 ADDL3 指令中使用 R1 而不是 8(AP)；这样的例子激发了计算机架构师尝试编写编译器！

Figure K.54 MIPS versus VAX assembly code of the procedure swap in [Figure K.53](#_bookmark893) on page K-30.

> 图 K.54 在[图 K.53](#_bookmark893) 中的步骤交换的 VAX 组装代码在第 K-30 页。

### A Longer Example: sort

We show the longer example of the sort procedure. [Figure K.55](#_bookmark895) shows the C ver- sion of the program. Once again we present this procedure in several steps, con- cluding with a side-by-side comparison to MIPS code.

> 我们显示了排序过程的较长示例。[图 K.55](#_bookmark895) 显示了程序的 c version。我们再次以几个步骤介绍此过程，并与 MIPS 代码并排比较。

##### _Register Allocation for sort_

The two parameters of the procedure sort, v and n, are found in the stack in loca- tions 4(ap) and 8(ap), respectively. The two local variables are assigned to regis- ters: i to r6 and j to r4. Because the two parameters are referenced frequently in the code, the VMS C compiler copies the _address_ of these parameters into registers upon entering the procedure:

> 该过程排序 V 和 N 的两个参数分别在位置 4(AP)和 8(AP)的堆栈中找到。将两个局部变量分配给了重新配置：i 至 r6 和 j 至 r4。由于代码中经常引用两个参数，因此 VMS C 编译器在输入该过程时将这些参数的*ADDRESS *将这些参数的\_address 复制到寄存器中：

It would seem that moving the _value_ of the operand to a register would be more useful than its address, but once again we bow to the decision of the VMS C com- piler. Apparently the compiler cannot be sure that v and n don’t overlap in memory.

> 似乎将操作数的*value *转移到寄存器上比其地址更有用，但是我们再次屈服于 VMS C compiler 的决定。显然，编译器无法确定 V 和 N 不会在内存中重叠。

##### _Code for the Body of the sort Procedure_

The procedure body consists of two nested _for_ loops and a call to swap, which includes parameters. Let’s unwrap the code from the outside to the middle.

> 该过程主体由两个嵌套 *FOR* 循环和一个求换呼叫组成，其中包括参数。让我们从外部到中间解开代码。

Recall that the C for statement has three parts: initialization, loop test, and iteration increment. It takes just one instruction to initialize i to 0, the first part of the for statement:

> 回想一下语句的 C 有三个部分：初始化，循环测试和迭代增量。只需一个指令即可初始化 i 至 0，这是供语句的第一部分：

Notice that there is no explicit comparison. The lack of comparison is a benefit of condition codes, with the conditions being set as a side effect of the prior instruc- tion. This branch skips over the second condition test.

> 请注意，没有明确的比较。缺乏比较是条件代码的好处，将条件设置为先前指导的副作用。该分支跳过第二个条件测试。

Notice that the instruction blss (at the top of the loop) is testing the condition codes based on the new value of r4 (j), set either by the subl3 before entering the loop or by the decl at the bottom of the loop.

> 请注意，指令 BLSS(在循环的顶部)正在根据 r4(j)的新值测试条件代码，该值是由 subl3 设置的，或者在输入循环之前或在循环底部的 dect 设置。

##### _Preserving Registers across Procedure Invocation of sort_

The only remaining code is the saving and restoring of registers using the callee save convention. This procedure uses registers r2 through r7, so we add a mask with those bits set:

> 剩下的唯一代码是使用 Callee 保存约定保存和还原寄存器。此过程使用 R2 至 R7 的寄存器，因此我们添加了一个设置的掩码：

Since ret will undo all the operations, we just tack it on the end of the procedure.

> 由于 RET 将撤销所有操作，因此我们只是在程序结束时进行处理。

##### _The Full Procedure sort_

Now we put all the pieces together in [Figure K.56](#_bookmark896). To make the code easier to fol- low, once again we identify each block of code with its purpose in the procedure and list the MIPS and VAX code side by side. In this example, 11 lines of the sort procedure in C become the 44 lines in the MIPS assembly language and 20 lines in VAX assembly language. The biggest VAX advantages are in register saving and restoring and indexed addressing.

> 现在，我们将所有碎片放在[图 K.56](#_bookmark896) 中。为了使代码更易于下降，我们再次在过程中识别及其目的的每个代码块，并并排列出 MIPS 和 VAX 代码。在此示例中，C 中的 11 行排序过程成为 MIPS 组装语言中的 44 行，而 VAX 汇编语言中的 20 行。最大的 VAX 优势在于登记和恢复和索引地址。

### Fallacies and Pitfalls

All architecture design involves trade-offs made in the context of a set of hardware and software technologies. Over time those technologies are likely to change, and decisions that may have been correct at one time later look like mistakes. For exam- ple, in 1975 the VAX designers overemphasized the importance of code size effi- ciency and underestimated how important ease of decoding and pipelining would be 10 years later. And, almost all architectures eventually succumb to the lack of sufficient address space. Avoiding these problems in the long run, however, would probably mean compromising the efficiency of the architecture in the short run.

> 所有架构设计都涉及在一套硬件和软件技术的背景下进行的权衡。随着时间的流逝，这些技术可能会发生变化，并且可能稍后可能是正确的决定看起来像错误。对于考试，1975 年，VAX 设计师过分强调了代码尺寸效率的重要性，并低估了十年后的解码和管道易于解码和管道的重要性。而且，几乎所有架构最终都屈服于缺乏足够的地址空间。但是，从长远来看，避免这些问题可能意味着在短期内损害体系结构的效率。

Fallacy _An architecture with flaws cannot be successful._

The IBM 360 is often criticized in the literature—the branches are not PC-relative, and the address is too small in displacement addressing. Yet, the machine has been an enormous success because it correctly handled several new problems. First, the architecture has a large amount of address space. Second, it is byte addressed and handles bytes well. Third, it is a general-purpose register machine. Finally, it is sim- ple enough to be efficiently implemented across a wide performance and cost range.

> IBM 360 在文献中经常受到批评 - 分支机构不具有 PC 相关性，并且地址在流离失所地址中太小。但是，该机器取得了巨大的成功，因为它正确处理了几个新问题。首先，该体系结构有大量的地址空间。其次，它是字节上的，并且操纵字节很好。第三，这是一台通用寄存器。最后，它足够模拟，可以在广泛的性能和成本范围内有效地实施。

The Intel 8086 provides an even more dramatic example. The 8086 architecture is the only widespread architecture in existence today that is not truly a general- purpose register machine. Furthermore, the segmented address space of the 8086 causes major problems for both programmers and compiler writers. Never- theless, the 8086 architecture—because of its selection as the microprocessor in the IBM PC—has been enormously successful.

> 英特尔 8086 提供了一个更加戏剧性的例子。8086 体系结构是当今现有的唯一广泛的体系结构，并不是真正的通用寄存器机器。此外，8086 的分段地址空间为程序员和编译器作家带来了主要问题。然而，8086 架构(因为它是 IBM PC 中的微处理器的选择)已取得了巨大成功。

Figure K.56 MIPS32 versus VAX assembly version of procedure sort in [Figure K.55](#_bookmark895) on page K-33.

> 图 K.56 MIPS32 与 VAX 汇编版本的过程形式排序[图 K.55](#_bookmark895) 在第 k-33 页上。

Figure K.57 Ratio of MIPS M2000 to VAX 8700 in instructions executed and perfor- mance in clock cycles using SPEC89 programs. On average, MIPS executes a little over twice as many instructions as the VAX, but the CPI for the VAX is almost six times the MIPS CPI, yielding almost a threefold performance advantage. (Based on data from "Per- formance from Architecture: Comparing a RISC and CISC with Similar Hardware Orga- nization," by D. Bhandarkar and D. Clark, in _Proc. Symp. Architectural Support for Programming Languages and Operating Systems IV_, 1991.)

> 图 K.57 使用 SPEC89 程序在执行时钟周期中执行的指令中，MIPS M2000 与 VAX 8700 的比率。平均而言，MIP 执行的指令是 VAX 的两倍以上，但 VAX 的 CPI 几乎是 MIPS CPI 的六倍，几乎具有三倍的性能优势。(基于 "体系结构的效果：将 RISC 和 CISC 与类似硬件 organization 进行比较" ，D。Bhandarkar 和 D. Clark 的数据)

Fallacy _The architecture that executes fewer instructions is faster._

> 谬论\_执行更少的指令的体系结构更快。

Designers of VAX machines performed a quantitative comparison of VAX and MIPS for implementations with comparable organizations, the VAX 8700 and the MIPS M2000. [Figure K.57](#_bookmark897) shows the ratio of the number of instructions exe- cuted and the ratio of performance measured in clock cycles. MIPS executes about twice as many instructions as the VAX while the MIPS M2000 has almost three times the performance of the VAX 8700.

> VAX 机器的设计师对与可比组织，VAX 8700 和 MIPS M2000 的实施实施的 VAX 和 MIP 进行了定量比较。[图 K.57](#_bookmark897) 显示了在时钟周期中测量的指令数量和绩效比率的比例。MIPS 执行的指令大约是 VAX 的两倍，而 MIPS M2000 的性能几乎是 VAX 8700 的性能的三倍。

### Concluding Remarks

_The Virtual Address eXtension of the PDP-11 architecture_ … _provides a virtual address of about 4.3 gigabytes which, even given the rapid improvement of mem- ory technology, should be adequate far into the future._

William Strecker
_ "VAX-11/780—A Virtual Address Extension to the PDP-11 Family," _
AFIPS Proc., _National Computer Conference_ (1978)

We have seen that instruction sets can vary quite dramatically, both in how they access operands and in the operations that can be performed by a single instruction. [Figure K.58](#_bookmark898) compares instruction usage for both architectures for two programs; even very different architectures behave similarly in their use of instruction classes.

> 我们已经看到，指令集在它们访问操作数的方式和可以通过单个指令执行的操作中的方式都大大变化。[图 K.58](#_bookmark898) 比较了两个程序的两个架构的指令使用情况；即使是非常不同的体系结构在使用教学课程中也表现出色。

Figure K.58 The frequency of instruction distribution for two programs on VAX and MIPS.

> 图 K.58 VAX 和 MIPS 上两个程序的指令分布频率。

A product of its time, the VAX emphasis on code density and complex oper- ations and addressing modes conflicts with the current emphasis on easy decoding, simple operations and addressing modes, and pipelined performance.

> VAX 的重点是代码密度和复杂操作以及解决模式的一种产物，与当前强调易于解码，简单操作和解决模式以及管道性能相冲突。

With more than 600,000 sold, the VAX architecture has had a very successful run. In 1991, DEC made the transition from VAX to Alpha.

> Vax Architecture 售出了超过 600,000 个，取得了非常成功的运行。1991 年，DEC 从 VAX 过渡到 Alpha。

Orthogonality is key to the VAX architecture; the opcode is independent of the addressing modes, which are independent of the data types and even the number of unique operands. Thus, a few hundred operations expand to hundreds of thousands of instructions when accounting for the data types, operand counts, and addressing modes.

> 正交性是 VAX 架构的关键。OpCode 独立于寻址模式，该模式与数据类型甚至唯一操作数的数量无关。因此，在考虑数据类型，操作数计数和寻址模式时，几百个操作扩展到数十万个说明。
