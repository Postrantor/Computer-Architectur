## Internetworking

Undoubtedly one of the most important innovations in the communications com- munity has been internetworking. It allows computers on independent and incom- patible networks to communicate reliably and efficiently. [Figure F.34](#_bookmark630) illustrates the need to traverse between networks. It shows the networks and machines involved in transferring a file from Stanford University to the University of Cal- ifornia at Berkeley, a distance of about 75 km.

> 毫无疑问，通信社区中最重要的创新之一就是互联网。它允许在独立和无理网络上的计算机可靠，有效地通信。[图 F.34](#_bookmark630) 说明了在网络之间穿越的必要性。它显示了参与将文件从斯坦福大学转移到伯克利大学的 Cal-Ifornia 大学的网络和机器，距离约 75 公里。

The low cost of internetworking is remarkable. For example, it is vastly less expensive to send electronic mail than to make a coast-to-coast telephone call and leave a message on an answering machine. This dramatic cost improvement is achieved using the same long-haul communication lines as the telephone call, which makes the improvement even more impressive.

> 互联网工程的低成本非常出色。例如，发送电子邮件的发送要比打一个海岸到海岸的电话要便宜得多，并在接听机上留言。这种巨大的成本提高是使用与电话相同的长途通信线实现的，这使得改进更加令人印象深刻。

The enabling technologies for internetworking are software standards that allow reliable communication without demanding reliable networks. The underly- ing principle of these successful standards is that they were composed as a hierar- chy of layers, each layer taking responsibility for a portion of the overall communication task. Each computer, network, and switch implements its layer of the standards, relying on the other components to faithfully fulfill their respon- sibilities. These layered software standards are called protocol families or protocol suites. They enable applications to work with any interconnection without extra work by the application programmer. [Figure F.35](#_bookmark631) suggests the hierarchical model of communication.

> 互联网加工的启示技术是软件标准，可以允许可靠的通信而无需可靠的网络。这些成功标准的基本原则是它们是作为层级的层组成的，每个层都负责一部分整体通信任务。每个计算机，网络和交换机都会实现其标准层，并依靠其他组件来忠实地实现其响应性。这些分层软件标准称为协议家庭或协议套件。它们使应用程序能够与任何互连一起工作，而无需申请程序员的额外工作。[图 F.35](#_bookmark631) 提出了通信的层次结构模型。

The most popular internetworking standard is TCP/IP (Transmission Control Protocol/Internet Protocol). This protocol family is the basis of the humbly named Internet, which connects hundreds of millions of computers around the world. This popularity means TCP/IP is used even when communicating locally across compatible networks; for example, the network file system (NFS) uses IP even though it is very likely to be communicating across a homogenous LAN such as Ethernet. We use TCP/IP as our protocol family example; other protocol families follow similar lines. [Section F.13](#historical-perspective-and-references-6) gives the history of TCP/IP.

> 最受欢迎的互联网加工标准是 TCP/IP(传输控制协议/Internet 协议)。该协议家族是谦卑命名的 Internet 的基础，该基础连接了世界各地的数亿台计算机。这种受欢迎程度意味着即使在跨兼容网络进行本地通信时，也会使用 TCP/IP。例如，即使网络文件系统(NFS)使用 IP，即使它很可能在诸如以太网之类的同质 LAN 上进行通信。我们使用 TCP/IP 作为协议家庭示例；其他协议系列遵循类似的行。[F.13 节](＃历史 - 光谱和参考文献-6)给出了 TCP/IP 的历史。

The goal of a family of protocols is to simplify the standard by dividing respon- sibilities hierarchically among layers, with each layer offering services needed by the layer above. The application program is at the top, and at the bottom is the phys- ical communication medium, which sends the bits. Just as abstract data types sim- plify the programmer’s task by shielding the programmer from details of the implementation of the data type, this layered strategy makes the standard easier to understand.

> 协议家庭的目的是通过将响应性层次分配在层之间来简化标准，每层提供上述图层所需的服务。申请程序位于顶部，底部是发送位置的物理通信媒介。就像抽象数据类型通过将程序员免受数据类型的实现的详细信息来模拟程序员的任务一样，这种分层策略使标准更易于理解。

There were many efforts at network protocols, which led to confusion in terms. Hence, Open Systems Interconnect (OSI) developed a model that popularized describing networks as a series of layers. Figure F.36 shows the model. Although all protocols do not exactly follow this layering, the nomenclature for the different layers is widely used. Thus, you can hear discussions about a simple layer 3 switch versus a layer 7 smart switch.

> 网络协议有许多努力，这导致了混乱。因此，开放系统互连(OSI)开发了一个模型，该模型普及了将网络描述为一系列层。图 F.36 显示了模型。尽管所有协议均未完全遵循此分层，但广泛使用了不同层的命名法。因此，您可以听到有关简单第 3 层开关与第 7 层智能开关的讨论。

The key to protocol families is that communication occurs logically at the same level of the protocol in both sender and receiver, but services of the lower level implement it. This style of communication is called `peer-to-peer`. As an analogy, imagine that General A needs to send a message to General B on the battlefield. General A writes the message, puts it in an envelope addressed to General B, and gives it to a colonel with orders to deliver it. This colonel puts it in an envelope, and writes the name of the corresponding colonel who reports to General B, and gives it to a major with instructions for delivery. The major does the same thing and gives it to a captain, who gives it to a lieutenant, who gives it to a sergeant. The sergeant takes the envelope from the lieutenant, puts it into an envelope with the name of a sergeant who is in General B’s division, and finds a private with orders to take the large envelope. The private borrows a motorcycle and delivers the envelope to the other sergeant. Once it arrives, it is passed up the chain of command, with each person removing an outer envelope with his name on it and passing on the inner envelope to his superior. As far as General B can tell, the note is from another gen- eral. Neither general knows who was involved in transmitting the envelope, nor how it was transported from one division to the other.

> 协议族的关键是通信在逻辑上发生在发送方和接收方协议的同一级别，但较低级别的服务实现它。这种通信方式称为 "点对点" 。打个比方，假设将军 A 需要在战场上向将军 B 发送消息。将军 A 写下消息，将其放入写给将军 B 的信封中，然后将其交给一位上校，并下令将其送达。这位上校把它装在一个信封里，写上相应的向 B 将军报告的上校的名字，然后交给一个少校，并附上投递说明。少校做同样的事情，把它交给上尉，上尉把它交给中尉，再把它交给中士。中士从中尉手中接过信封，将信封放入写有 B 将军所在师部一名中士姓名的信封中，然后找一个奉命接过大信封的二等兵。士兵借了一辆摩托车，把信封交给了另一个中士。一旦到达，它就会向上传递到指挥系统中，每个人都会取出一个写有他名字的外层信封，然后将内层信封交给他的上级。据 B 将军所知，这张字条是另一位将军写的。两位将军都不知道谁参与了信封的传递，也不知道信封是如何从一个师运送到另一个师的。

Protocol families follow this analogy more closely than you might think, as [Figure F.37](#_bookmark633) shows. The original message includes a header and possibly a trailer sent by the lower-level protocol. The next-lower protocol in turn adds its own header to the message, possibly breaking it up into smaller messages if it is too large for this layer. Reusing our analogy, a long message from the general is divided and placed in several envelopes if it could not fit in one. This division of the message and appending of headers and trailers continues until the message descends to the physical transmission medium. The message is then sent to the des- tination. Each level of the protocol family on the receiving end will check the mes- sage at its level and peel off its headers and trailers, passing it on to the next higher level and putting the pieces back together. This nesting of protocol layers for a spe- cific message is called a `protocol stack`, reflecting the last in, first out nature of the addition and removal of headers and trailers.

> 正如 [图 F.37](#_bookmark633) 所示，协议系列比您想象的更紧密地遵循这个类比。原始消息包括一个报头，可能还有一个由低层协议发送的报尾。下一个较低的协议依次将自己的标头添加到消息中，如果对于该层来说太大，则可能将其分解为更小的消息。重用我们的类比，来自将军的一条长消息被分成几个信封，如果一个信封装不下的话。消息的这种划分以及标题和尾部的附加一直持续到消息下降到物理传输介质。然后将消息发送到目的地。接收端协议族的每一层都将在其层级检查消息并剥离其报头和报尾，将其传递到下一个更高层并将这些部分重新组合在一起。这种针对特定消息的协议层嵌套称为 "协议栈" ，反映了添加和删除报头和报尾的后进先出性质。

![](../media/image706.png)

Figure F.37 A generic protocol stack with two layers. Note that communication is peer-to-peer, with headers and trailers for the peer added at each sending layer and removed by each receiving layer. Each layer offers services to the one above to shield it from unnecessary details.

As in our analogy, the danger in this layered approach is the considerable latency added to message delivery. Clearly, one way to reduce latency is to reduce the number of layers, but keep in mind that protocol families define a standard but do not force how to implement the standard. Just as there are many ways to imple- ment an instruction set architecture, there are many ways to implement a protocol family.

> 就像我们的类比一样，这种分层方法的危险是消息传递的相当延迟。显然，减少延迟的一种方法是减少层的数量，但请记住，协议系列定义了标准，但不要强迫如何实施标准。正如有很多方法可以实施指令集体系结构一样，有很多方法可以实施协议系列。

Our protocol stack example is TCP/IP. Let’s assume that the bottom protocol layer is Ethernet. The next level up is the Internet Protocol or IP layer; the official term for an IP packet is a datagram. The IP layer routes the datagram to the des- tination machine, which may involve many intermediate machines or switches. IP makes a best effort to deliver the packets but does not guarantee delivery, content, or order of datagrams. The TCP layer above IP makes the guarantee of reliable, in- order delivery and prevents corruption of datagrams.

> 我们的协议堆栈示例是 TCP/IP。假设底部协议层是以太网。下一个级别是 Internet 协议或 IP 层；IP 数据包的官方术语是数据报。IP 层将数据报路线路由到定位机，这可能涉及许多中间机或开关。IP 尽力交付数据包，但不能保证数据报的交付，内容或顺序。IP 上方的 TCP 层可保证可靠的，订单交付并防止数据报的损坏。

Following the example in [Figure F.37](#_bookmark633), assume an application program wants to send a message to a machine via an Ethernet. It starts with TCP. The largest number of bytes that can be sent at once is 64 KB. Since the data may be much larger than 64 KB, TCP must divide them into smaller segments and reassemble them in proper order upon arrival. TCP adds a 20-byte header ([Figure F.38](#_bookmark634)) to every data- gram and passes them down to IP. The IP layer above the physical layer adds a 20-byte header, also shown in [Figure F.38](#_bookmark634). The data sent down from the IP level to the Ethernet are sent in packets with the format shown in [Figure F.30](#_bookmark627). Note that the TCP packet appears inside the data portion of the IP datagram, just as [Figure F.37](#_bookmark633) suggests.

> 在[图 F.37](#_Bookmark633) 中的示例之后，假设应用程序希望通过以太网将消息发送给计算机。它从 TCP 开始。可以立即发送的最多字节数为 64 kb。由于数据可能大于 64 kb，因此 TCP 必须将它们分为较小的细分市场，并在到达时以适当的顺序重新组装它们。TCP 添加了一个 20 字节的标题([图 F.38](#_bookmark634))到每个数据革兰器中，并将其传递给 IP。物理层上方的 IP 层添加了一个 20 字节的标头，也显示了[图 F.38](#_bookmark634)。从 IP 级别发送到以太网的数据以数据包发送，其格式[图 F.30](#_bookmark627) 中显示。请注意，TCP 数据包出现在 IP 数据报的数据部分内，就像[图 F.37](#_bookmark633) 所建议的那样。

Figure F.38 The headers for IP and TCP. This drawing is 32 bits wide. The standard headers for both are 20 bytes, but both allow the headers to optionally lengthen for rarely transmitted information. Both headers have a length of header field (L) to accommodate the optional fields, as well as source and destination fields. The length field of the whole datagram is in a separate length field in IP, while TCP combines the length of the datagram with the sequence number of the datagram by giving the sequence number in bytes. TCP uses the checksum field to be sure that the datagram is not corrupted, and the sequence number field to be sure the datagrams are assembled into the proper order when they arrive. IP provides checksum error detection only for the header, since TCP has protected the rest of the packet. One optimization is that TCP can send a sequence of datagrams before waiting for permission to send more. The number of datagrams that can be sent without waiting for approval is called the `window`, and the window field tells how many bytes may be sent beyond the byte being acknowledged by this datagram. TCP will adjust the size of the window depending on the success of the IP layer in sending datagrams; the more reliable and faster it is, the larger TCP makes the window. Since the window slides forward as the data arrive and are acknowledged, this technique is called a `sliding window protocol.` The piggyback acknowledgment field of TCP is another optimization. Since some applications send data back and forth over the same connection, it seems wasteful to send a datagram containing only an acknowledgment. This piggyback field allows a datagram carrying data to also carry the acknowl- edgment for a previous transmission, "piggybacking" on top of a data transmission. The urgent pointer field of TCP gives the address within the datagram of an important byte, such as a break character. This pointer allows the appli- cation software to skip over data so that the user doesn’t have to wait for all prior data to be processed before seeing a character that tells the software to stop. The identifier field and fragment field of IP allow intermediary machines to break the original datagram into many smaller datagrams. A unique identifier is associated with the original datagram and placed in every fragment, with the fragment field saying which piece is which. The time-to-live field allows a datagram to be killed off after going through a maximum number of intermediate switches no matter where it is in the network. Knowing the maximum number of hops that it will take for a datagram to arrive—if it ever arrives—simplifies the protocol software. The protocol field identifies which possible upper layer protocol sent the IP datagram; in our case, it is TCP. The V (for version) and type fields allow different versions of the IP protocol software for the network. Explicit version numbering is included so that software can be upgraded gracefully machine by machine, without shutting down the entire network. Nowadays, version six of the Internet protocol (IPv6) was widely used.

> 图 F.38 IP 和 TCP 的标头。此图为 32 位宽。两者的标准标头都是 20 字节，但都允许标头可选地加长以用于很少传输的信息。两个标头都有一个标头字段长度 (L)，以容纳可选字段以及源字段和目标字段。整个数据报的长度字段在 IP 中是在一个单独的长度字段中，而 TCP 通过给出以字节为单位的序号，将数据报的长度和数据报的序号结合起来。TCP 使用校验和字段来确保数据报没有损坏，并使用序列号字段来确保数据报在到达时被组装成正确的顺序。IP 只为报头提供校验和错误检测，因为 TCP 保护了数据包的其余部分。一种优化是 TCP 可以在等待发送更多数据报的许可之前发送一系列数据报。无需等待批准即可发送的数据报的数量称为 "窗口" ，窗口字段表示在该数据报确认的字节之外可以发送多少字节。TCP 会根据 IP 层发送数据报的成功情况来调整窗口的大小；它越可靠、越快，TCP 的窗口就越大。由于窗口在数据到达并被确认时向前滑动，因此这种技术称为 "滑动窗口协议" 。TCP 的搭载确认字段是另一种优化。由于某些应用程序通过同一连接来回发送数据，因此发送仅包含确认的数据报似乎很浪费。这个搭载字段允许携带数据的数据报也携带对先前传输的确认，"搭载" 在数据传输之上。TCP 的紧急指针字段给出了重要字节(例如中断字符)在数据报中的地址。该指针允许应用程序软件跳过数据，这样用户就不必等待所有先前的数据都处理完就可以看到告诉软件停止的字符。IP 的标识符字段和分片字段允许中间机器将原始数据报分解成许多更小的数据报。一个唯一的标识符与原始数据报相关联并放置在每个片段中，片段字段说明哪个片段是哪个片段。生存时间字段允许数据报在经过最大数量的中间交换机后被终止，无论它在网络中的哪个位置。知道数据报到达所需的最大跳数(如果它真的到达的话)可以简化协议软件。协议字段标识哪个可能的上层协议发送了 IP 数据报；在我们的例子中，它是 TCP。V(版本)和类型字段允许网络使用不同版本的 IP 协议软件。包括明确的版本编号，以便软件可以在机器上优雅地升级，而无需关闭整个网络。如今，互联网协议第六版(IPv6)被广泛使用。
