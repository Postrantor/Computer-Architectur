## The Intel 80x86

> ##英特尔 80x86

### Introduction

> ＃＃＃ 介绍

MIPS was the vision of a single architect. The pieces of this architecture fit nicely together and the whole architecture can be described succinctly. Such is not the case of the 80x86: It is the product of several independent groups who evolved the archi- tecture over 20 years, adding new features to the original instruction set as you might add clothing to a packed bag. Here are important 80x86 milestones:

> MIPS 是单个建筑师的愿景。这种架构的碎片很好地融合在一起，可以简洁地描述整个体系结构。80x86 的情况不是这样：它是几个独立团体的产物，他们在 20 年内演变了该档案，在原始说明套装中添加了新功能，因为您可能会将衣服添加到包装的袋子中。这是重要的 80x86 里程碑：

- 1978—The Intel 8086 architecture was announced as an assembly language– compatible extension of the then-successful Intel 8080, an 8-bit microproces- sor. The 8086 is a 16-bit architecture, with all internal registers 16 bits wide. Whereas the 8080 was a straightforward accumulator machine, the 8086 extended the architecture with additional registers. Because nearly every reg- ister has a dedicated use, the 8086 falls somewhere between an accumulator machine and a general-purpose register machine, and can fairly be called an _extended accumulator_ machine.

> - 1978 年 - 英特尔 8086 体系结构被宣布为一种集会语言 - 当时成功的英特尔 8080（8 位微处理器）的兼容扩展。8086 是一个 16 位架构，所有内部寄存器 16 位宽。尽管 8080 是一台简单的蓄能器机器，但 8086 用其他寄存器扩展了体系结构。因为几乎每个登记都有专用的用途，所以 8086 属于累加器机器和通用寄存器机器之间的某个位置，并且可以公平地称为_Extended accamulator_ Machine。

- 1980—The Intel 8087 floating-point coprocessor is announced. This architec- ture extends the 8086 with about 60 floating-point instructions. Its architects rejected extended accumulators to go with a hybrid of stacks and registers, essentially an _extended stack_ architecture: A complete stack instruction set is supplemented by a limited set of register-memory instructions.

> - 1980 年 - 宣布了英特尔 8087 浮点协处理器。该架构通过约 60 个浮点说明扩展了 8086。它的架构师拒绝了扩展的蓄能器，以与堆栈和寄存器混合在一起，从本质上讲是_Extended stack_架构：完整的堆栈指令集补充了一组有限的寄存器记录器指令。

- 1982—The 80286 extended the 8086 architecture by increasing the address space to 24 bits, by creating an elaborate memory mapping and protection model, and by adding a few instructions to round out the instruction set and to manipulate the protection model. Because it was important to run 8086 pro- grams without change, the 80286 offered a _real addressing mode_ to make the machine look just like an 8086.

> - 1982 年 -  80286 通过创建精心设计的内存映射和保护模型，并添加一些说明来完善指令集并操纵保护模型，从而扩展了 8086 体系结构，将地址空间扩展到 24 位。由于不更改的 8086 程序运行非常重要，因此 80286 提供了_real 地址模式_，使机器看起来像 8086。

- 1985—The 80386 extended the 80286 architecture to 32 bits. In addition to a 32-bit architecture with 32-bit registers and a 32-bit address space, the 80386 added new addressing modes and additional operations. The added instructions make the 80386 nearly a general-purpose register machine. The 80386 also added paging support in addition to segmented addressing (see Chapter 2). Like the 80286, the 80386 has a mode to execute 8086 programs without change.

> - 1985 年 -  80386 将 80286 架构扩展到 32 位。除了具有 32 位寄存器和 32 位地址空间的 32 位体系结构外，80386 还增加了新的地址模式和其他操作。增加的说明使 80386 几乎是通用寄存器机器。80386 除了分段地址外，还增加了分页支持（请参阅第 2 章）。像 80286 一样，80386 具有执行 8086 程序而无需更改的模式。

This history illustrates the impact of the “golden handcuffs” of compatibility on the 80x86, as the existing software base at each step was too important to jeopar- dize with significant architectural changes. Fortunately, the subsequent 80486 in 1989, Pentium in 1992, and P6 in 1995 were aimed at higher performance, with only four instructions added to the user-visible instruction set: three to help with multiprocessing plus a conditional move instruction.

> 这段历史说明了兼容性“金色手铐”对 80x86 的影响，因为每个步骤的现有软件基础对涉及重大架构变化的危险非常重要。幸运的是，随后的 1989 年 80486，1992 年的奔腾和 1995 年的 P6 针对更高的性能，仅添加了四个指令，其中包括用户可见的指令集：三个可帮助多处理以及有条件移动指令。

Since 1997 Intel has added hundreds of instructions to support multimedia by operating on many narrower data types within a single clock (see Appendix A). These SIMD or vector instructions are primarily used in hand-coded libraries or drivers and rarely generated by compilers. The first extension, called MMX, appeared in 1997. It consists of 57 instructions that pack and unpack multiple bytes, 16-bit words, or 32-bit double words into 64-bit registers and performs shift, logical, and integer arithmetic on the narrow data items in parallel. It supports both saturating and nonsaturating arithmetic. MMX uses the registers comprising the floating-point stack and hence there is no new state for operating systems to save. In 1999 Intel added another 70 instructions, labeled SSE, as part of Pentium III. The primary changes were to add eight separate registers, double their width to 128 bits, and add a single-precision floating-point data type. Hence, four 32-bit floating-point operations can be performed in parallel. To improve memory perfor- mance, SSE included cache prefetch instructions plus streaming store instructions that bypass the caches and write directly to memory.

> 自 1997 年以来，英特尔（Intel）添加了数百个指令来通过在单个时钟内的许多较窄数据类型上操作来支持多媒体（请参阅附录 A）。这些 SIMD 或向量说明主要用于手工编码的库或驱动程序，很少由编译器生成。第一个扩展名为 MMX，出现在 1997 年。它由 57 个说明组成，这些说明包装和打开多个字节，16 位单词或 32 位双词，分为 64 位寄存器，并执行变化，逻辑和整数算术，并在并联数据项。它支持饱和和不饱和算术。MMX 使用包含浮点堆栈的寄存器，因此没有新的状态可以保存操作系统。1999 年，英特尔添加了另外 70 个标记为 SSE 的说明，作为奔腾 III 的一部分。主要更改是添加八个单独的寄存器，将其宽度翻倍到 128 位，并添加单精度的浮点数据类型。因此，可以并行执行四个 32 位浮点操作。为了改善内存性能，SSE 包括缓存预取指令以及绕过缓存并直接写入内存的流式商店指令。

In 2001, Intel added yet another 144 instructions, this time labeled SSE2. The new data type is double-precision arithmetic, which allows pairs of 64-bit floating- point operations in parallel. Almost all of these 144 instructions are versions of existing MMX and SSE instructions that operate on 64 bits of data in parallel. Not only does this change enable multimedia operations, but it also gives the com- piler a different target for floating-point operations than the unique stack architec- ture. Compilers can choose to use the eight SSE registers as floating-point registers as found in the RISC machines. This change has boosted performance on the Pentium 4, the first microprocessor to include SSE2 instructions. At the time of announcement, a 1.5 GHz Pentium 4 was 1.24 times faster than a 1 GHz Pentium III for SPECint2000(base), but it was 1.88 times faster for SPECfp2000(base).

> 在 2001 年，英特尔添加了另外 144 个说明，这次被标记为 SSE2。新的数据类型是双精度算术，它允许并联 64 位浮点操作。几乎所有这 144 个说明都是现有的 MMX 和 SSE 指令的版本，它们在 64 位并行运行。此更改不仅可以实现多媒体操作，而且还为 Compiler 提供了与唯一的堆栈架构的不同目标。编译器可以选择使用 RISC 机器中发现的八个 SSE 寄存器作为浮点寄存器。这一变化增强了奔腾 4 的性能，奔腾 4 是第一个包括 SSE2 指令的微处理器。在宣布时，Specint2000（基础）的 1.5 GHz Pentium 4 比 1 GHz III 的 1.24 倍，但 SpecFP2000（基础）的速度快 1.88 倍。

In 2003 a company other than Intel enhanced the IA-32 architecture this time. AMD announced a set of architectural extensions to increase the address space for 32 to 64 bits. Similar to the transition from 16- to 32-bit address space in 1985 with the 80386, AMD64 widens all registers to 64 bits. It also increases the number of registers to sixteen and has 16 128-bit registers to support XMM, AMD’s answer to SSE2. Rather than expand the instruction set, the primary change is adding a new mode called _long mode_ that redefines the execution of all IA-32 instructions with 64-bit addresses. To address the larger number of registers, it adds a new prefix to instructions. AMD64 still has a 32-bit mode that is backwards compatible to the standard Intel instruction set, allowing a more graceful transition to 64-bit addres- sing than the HP/Intel Itanium. Intel later followed AMD’s lead, making almost identical changes so that most software can run on either 64-bit address version of the 80x86 without change.

> 2003 年，除英特尔以外的一家公司这次增强了 IA-32 架构。AMD 宣布了一套建筑扩展，以增加 32 至 64 位的地址空间。与 1985 年 80386 的 16-位地址空间的过渡相似，AMD64 将所有寄存器扩大到 64 位。它还将寄存器数量增加到 16 个，并有 16 位 128 位登记册支持 XMM，AMD 对 SSE2 的答案。主要更改不是扩展指令集，而是添加一种名为_long Mode_的新模式，该模式重新定义了使用 64 位地址的所有 IA-32 指令执行。为了解决较大数量的寄存器，它在说明中添加了一个新的前缀。AMD64 仍然具有 32 位模式，该模式与标准的英特尔指令集兼容，可以比 HP/Intel Itanium 更优雅地过渡到 64 位插件。英特尔后来遵循 AMD 的潜在客户，进行了几乎相同的更改，因此大多数软件都可以在 80x86 的 64 位地址版本上运行，而无需更改。

Whatever the artistic failures of the 80x86, keep in mind that there are more instances of this architectural family than of any other server or desktop processor in the world. Nevertheless, its checkered ancestry has led to an architecture that is difficult to explain and impossible to love.

> 无论 80x86 的艺术失败是什么，请记住，与世界上任何其他服务器或桌面处理器相比，该建筑家族的实例更多。尽管如此，其格子血统导致了一个难以解释且不可能爱的建筑。

We start our explanation with the registers and addressing modes, move on to the integer operations, then cover the floating-point operations, and conclude with an examination of instruction encoding.

> 我们开始使用寄存器和解决模式的解释，继续进行整数操作，然后覆盖浮点操作，然后以对教学编码的检查结束。

### 80x86 Registers and Data Addressing Modes

> ### 80x86 寄存器和数据寻址模式

The evolution of the instruction set can be seen in the registers of the 80x86 ([Figure K.30](#_bookmark869)). Original registers are shown in black type, with the extensions of the 80386 shown in a lighter shade, a coloring scheme followed in subsequent fig- ures. The 80386 basically extended all 16-bit registers (except the segment regis- ters) to 32 bits, prefixing an “E” to their name to indicate the 32-bit version. The arithmetic, logical, and data transfer instructions are two-operand instructions that allow the combinations shown in [Figure K.31](#_bookmark870).

> 指令集的演变可以在 80x86 的寄存器中看到（[图 K.30]（#_ bookmark869））。原始寄存器以黑色类型显示，其中 80386 的延伸为较浅的阴影，随后的无图像中的着色方案。80386 基本上将所有 16 位寄存器（除段重新汇总除外）扩展到 32 位，并将“ E”前缀为其名称，以表示 32 位版本。算术，逻辑和数据传输指令是两项指令，允许[图 K.31]中显示的组合（#_ bookmark870）。

To explain the addressing modes, we need to keep in mind whether we are talk- ing about the 16-bit mode used by both the 8086 and 80286 or the 32-bit mode available on the 80386 and its successors. The seven data memory addressing modes supported are

> 为了解释寻址模式，我们需要牢记是否正在谈论 8086 和 80286 使用的 16 位模式，还是在 80386 及其后继商上使用的 32 位模式。支持的七个数据存储器地址模式是

- Absolute

> - 绝对

- Register indirect

> - 注册间接

- Based

> - 基于

- Indexed

> - 索引

- Based indexed with displacement

> - 基于排量的索引

- Based with scaled indexed

> - 基于缩放索引

- Based with scaled indexed and displacement

> - 基于缩放索引和位移

Figure K.30 The 80x86 has evolved over time, and so has its register set. The original set is shown in black and the extended set in gray. The 8086 divided the first four registers in half so that they could be used either as one 16-bit register or as two 8-bit registers. Starting with the 80386, the top eight registers were extended to 32 bits and could also be used as general-purpose registers. The floating-point registers on the bottom are 80 bits wide, and although they look like regular registers they are not. They implement a stack, with the top of stack pointed to by the status register. One operand must be the top of stack, and the other can be any of the other seven registers below the top of stack.

> 图 K.30 80x86 随着时间的推移而发展，其寄存器集也随之发展。原始集合以黑色显示，并以灰色为单位。8086 将前四个寄存器划分为一半，以便可以用作一个 16 位登记册或两个 8 位登记册。从 80386 开始，前八个登记册被扩展到 32 位，也可以用作通用登记册。底部的浮点寄存器的宽度为 80 位，尽管它们看起来像常规寄存器，但它们不是。他们实现了一个堆栈，堆栈的顶部指向状态寄存器。一个操作数必须是堆栈的顶部，另一个可以是堆栈顶部以下的其他七个寄存器中的任何一个。

Figure K.31 Instruction types for the arithmetic, logical, and data transfer instruc- tions. The 80x86 allows the combinations shown. The only restriction is the absence of a memory-memory mode. Immediates may be 8, 16, or 32 bits in length; a register is any one of the 14 major registers in [Figure K.30](#_bookmark869) (not IP or FLAGS).

> 图 K.31 算法，逻辑和数据传输指令类型。80x86 允许显示的组合。唯一的限制是没有内存内存模式。直接的长度可能为 8、16 或 32 位；寄存器是[图 K.30]（#_ bookmark869）（不是 IP 或标志）的 14 个主要寄存器中的任何一个。

Displacements can be 8 or 32 bits in 32-bit mode, and 8 or 16 bits in 16-bit mode. If we count the size of the address as a separate addressing mode, the total is 11 addressing modes.

> 位移可以在 32 位模式下为 8 或 32 位，在 16 位模式下的 8 或 16 位。如果我们将地址的大小视为单独的地址模式，则总计为 11 个地址模式。

Although a memory operand can use any addressing mode, there are restric- tions on what registers can be used in a mode. The section “80x86 Instruction Encoding” on page K-11 gives the full set of restrictions on registers, but the fol- lowing description of addressing modes gives the basic register options:

> 尽管内存操作数可以使用任何地址模式，但在模式下可以使用哪些寄存器进行了详尽的修改。第 K-11 页上的“ 80x86 指令编码”部分给出了对寄存器的完整限制，但是寻址模式的后面描述给出了基本寄存器选项：

- _Absolute_—With 16-bit or 32-bit displacement, depending on the mode.

> - _absolute _-根据模式，有 16 位或 32 位位移。

- _Register indirect_—BX, SI, DI in 16-bit mode and EAX, ECX, EDX, EBX, ESI, and EDI in 32-bit mode.

> - _ register indirect_— bx，si，di 以 16 位模式和 EAX，ECX，EDX，EBX，ESI 和 EDI 32 位模式。

- _Based mode with 8-bit or 16-bit/32-bit displacement_—BP, BX, SI, and DI in 16-bit mode and EAX, ECX, EDX, EBX, ESI, and EDI in 32-bit mode. The displacement is either 8 bits or the size of the address mode: 16 or 32 bits. (Intel gives two different names to this single addressing mode, _based_ and _indexed_, but they are essentially identical and we combine them. This book uses indexed addressing to mean something different, explained next.)

> - _基于 8 位或 16 位/32 位位移的模式为 16 位模式下的 BP，BX，SI 和 DI，EAX，ECX，EDX，EBX，ESI，ESI 和 EDI 在 32 位模式下进行。位移是 8 位或地址模式的大小：16 或 32 位。（英特尔为此单一的地址模式提供了两个不同的名称，即_based_和_indexed_，但它们基本相同，我们将它们结合在一起。本书使用索引地址来表示不同的内容，接下来解释了。）

- _Indexed_—The address is the sum of two registers. The allowable combinations are BX+SI, BX+DI, BP+SI, and BP+DI. This mode is called _based indexed_ on the 8086. (The 32-bit mode uses a different addressing mode to get the same effect.)

> - _indexed _-地址是两个寄存器的总和。允许组合是 BX+SI，BX+DI，BP+SI 和 BP+DI。此模式在 8086 上称为_基于_的索引_（32 位模式使用不同的地址模式来获得相同的效果。）

- _Based indexed with 8- or 16-bit displacement_—The address is the sum of dis- placement and contents of two registers. The same restrictions on registers apply as in indexed mode.

> - _基于 8-或 16 位排量的索引 - 地址是两个寄存器的分位和内容的总和。对寄存器的相同限制适用于索引模式。

- _Base plus scaled indexed_—This addressing mode and the next were added in the 80386 and are only available in 32-bit mode. The address calculation is

> - _base Plus 缩放索引_-在 80386 中添加了此地址模式，仅在 32 位模式下可用。地址计算是

where _Scale_ has the value 0, 1, 2, or 3; _Index register_ can be any of the eight 32-bit general registers except ESP; and _Base register_ can be any of the eight 32-bit general registers.

> 其中_scale_具有 0、1、2 或 3 的值；_index 寄存器_可以是除 ESP 以外的八个 32 位常规寄存器中的任何一个；_base 寄存器_可以是八个 32 位通用寄存器中的任何一个。

- _Base plus scaled index with 8- or 32-bit displacement_—The address is the sum of the displacement and the address calculated by the scaled mode immediately above. The same restrictions on registers apply.

> - _base Plus 带有 8-或 32 位位移的缩放索引_-地址是位移的总和和由上面的缩放模式计算得出的地址。对寄存器的相同限制适用。

The 80x86 uses Little Endian addressing.

> 80x86 使用的是很少的 Endian 地址。

Ideally, we would refer discussion of 80x86 logical and physical addresses to Chapter 2, but the segmented address space prevents us from hiding that infor- mation. [Figure K.32](#_bookmark871) shows the memory mapping options on the generations of 80x86 machines; Chapter 2 describes the segmented protection scheme in greater detail.

> 理想情况下，我们将对 80x86 的逻辑和物理地址的讨论推荐给第 2 章，但是分段的地址空间阻止了我们隐藏该信息。[图 K.32]（#_ bookmark871）在 80x86 机器的一代上显示了内存映射选项；第 2 章更详细地描述了分段的保护方案。

The assembly language programmer clearly must specify which segment reg- ister should be used with an address, no matter which address mode is used. To save space in the instructions, segment registers are selected automatically depend- ing on which address register is used. The rules are simple: References to instruc- tions (IP) use the code segment register (CS), references to the stack (BP or SP) use the stack segment register (SS), and the default segment register for the other registers is the data segment register (DS). The next section explains how they can be overridden.

> 汇编语言程序员显然必须指定应与地址一起使用哪个段 reg-iSter，无论使用哪种地址模式。为了在说明中保存空间，选择了段寄存器自动取决于使用哪个地址寄存器。规则很简单：引用指令（IP）使用代码段寄存器（CS），对堆栈（BP 或 SP）的引用使用堆栈段寄存器（SS），而其他寄存器的默认段为数据段寄存器（DS）。下一节解释了如何被覆盖。

### 80x86 Integer Operations

> ### 80x86 整数操作

The 8086 provides support for both 8-bit (_byte_) and 16-bit (called _word_) data types. The data type distinctions apply to register operations as well as memory accesses. The 80386 adds 32-bit addresses and data, called _double words._ Almost every operation works on both 8-bit data and one longer data size. That size is determined by the mode and is either 16 or 32 bits.

> 8086 提供了对 8 位（_byte_）和 16 位（称为_word_）数据类型的支持。数据类型区分适用于寄存器操作以及内存访问。80386 添加了 32 位地址和数据，称为_双词。_几乎每个操作都适用于 8 位数据和一个更长的数据大小。该大小由模式确定，为 16 或 32 位。

Clearly some programs want to operate on data of all three sizes, so the 80x86 architects provide a convenient way to specify each version without expanding code size significantly. They decided that most programs would be dominated by either 16- or 32-bit data, and so it made sense to be able to set a default large size. This default size is set by a bit in the code segment register. To override the default size, an 8-bit _prefix_ is attached to the instruction to tell the machine to use the other large size for this instruction.

> 显然，有些程序希望在所有三种尺寸的数据上运行，因此 80x86 架构师提供了一种方便的方式来指定每个版本，而无需大量扩展代码大小。他们认为大多数程序将由 16 位或 32 位数据主导，因此能够设置默认的大尺寸是很有意义的。此默认大小在代码段寄存器中有点设置。为了覆盖默认的大小，将 8 位_prefix_附加到指令上，以告诉机器将其他大尺寸用于此说明。

The prefix solution was borrowed from the 8086, which allows multiple prefixes to modify instruction behavior. The three original prefixes override the default seg- ment register, lock the bus so as to perform a semaphore (see Chapter 5), or repeat the following instruction until CX counts down to zero. This last prefix was intended to be paired with a byte move instruction to move a variable number of bytes. The 80386 also added a prefix to override the default address size.

> 从 8086 借用前缀解决方案，该解决方案允许多个前缀修改指令行为。三个原始前缀覆盖了默认示例寄存器，锁定总线以执行信号量（请参阅第 5 章），或重复以下说明，直到 CX 计数为零为零。最后一个前缀旨在与字节移动指令配对，以移动可变数量的字节。80386 还添加了一个前缀来覆盖默认地址大小。

Figure K.32 The original segmented scheme of the 8086 is shown on the left. All 80x86 processors support this style of addressing, called _real mode_. It simply takes the contents of a segment register, shifts it left 4 bits, and adds it to the 16-bit offset, forming a 20-bit physical address. The 80286 (center) used the contents of the segment register to select a segment descriptor, which includes a 24-bit base address among other items. It is added to the 16-bit offset to form the 24-bit physical address. The 80386 and successors (right) expand this base address in the segment descriptor to 32 bits and also add an optional paging layer below segmentation. A 32-bit linear address is first formed from the segment and offset, and then this address is divided into two 10-bit fields and a 12-bit page offset. The first 10-bit field selects the entry in the first-level page table, and then this entry is used in combination with the second 10-bit field to access the second-level page table to select the upper 20 bits of the physical address. Prepending this 20-bit address to the final 12-bit field gives the 32-bit physical address. Paging can be turned off, redefining the 32-bit linear address as the physical address. Note that a “flat” 80x86 address space comes simply by loading the same value in all the segment registers; that is, it doesn’t matter which segment register is selected.

> 图 K.32 8086 的原始分段方案显示在左侧。所有 80x86 处理器都支持这种称为_REAL MODE_的寻址样式。它只需将段寄存器的内容移动，将其左右移动 4 位，然后将其添加到 16 位偏移量中，形成 20 位物理地址。80286（中心）使用片段寄存器的内容选择一个段描述符，其中包括 24 位基础地址。它被添加到 16 位偏移量中以形成 24 位物理地址。80386 和后继（右）将此基础地址扩展到 32 位，并在分段下方添加一个可选的分页层。首先是从段和偏移中形成 32 位线性地址，然后将该地址分为两个 10 位字段和一个 12 位页面偏移。第一个 10 位字段选择第一级页面表中的条目，然后将此条目与第二个 10 位字段结合使用，以访问第二级页面表以选择物理地址的上限 20 位。将这个 20 位地址预先到最后的 12 位字段提供了 32 位物理地址。可以关闭分页，将 32 位线性地址重新定义为物理地址。请注意，“平坦” 80x86 地址空间仅通过在所有细分寄存器中加载相同的值来得出。也就是说，选择哪个片段寄存器都没关系。

The 80x86 integer operations can be divided into four major classes:

> 80x86 整数操作可以分为四个主要类：

1. Data movement instructions, including move, push, and pop

> 1.数据移动说明，包括移动，推和弹出

2. Arithmetic and logic instructions, including logical operations, test, shifts, and integer and decimal arithmetic operations

> 2.算术和逻辑指令，包括逻辑操作，测试，班次以及整数和十进制算术操作

3. Control flow, including conditional branches and unconditional jumps, calls, and returns

> 3.控制流，包括条件分支和无条件跳跃，呼叫和返回

4. String instructions, including string move and string compare

> 4.字符串说明，包括字符串移动和字符串比较

Figure K.33 Some typical 80x86 instructions and their functions. A list of frequent operations appears in [Figure K.34](#_bookmark873). We use the abbreviation SR:X to indicate the forma- tion of an address with segment register SR and offset X. This effective address corre- sponding to SR:X is (SR<<4)+X. The CALLF saves the IP of the next instruction and the current CS on the stack.

> 图 K.33 一些典型的 80x86 指令及其功能。[图 K.34]（#_ bookmark873）中出现了频繁操作的列表。我们使用缩写 SR：X 指示使用段寄存器 SR 和 Offset X 的地址的形式。此有效地址归为 SR：X IS：X IS（SR << 4）+X。CALLF 保存下一个指令的 IP，并将当前 CS 保存在堆栈上。

[Figure K.33](#_bookmark872) shows some typical 80x86 instructions and their functions.

> [图 K.33]（#_ bookmark872）显示了一些典型的 80x86 说明及其功能。

The data transfer, arithmetic, and logic instructions are unremarkable, except that the arithmetic and logic instruction operations allow the destination to be either a register or a memory location.

> 数据传输，算术和逻辑指令不明显，除了算术和逻辑指令操作允许目的地是寄存器或内存位置。

Control flow instructions must be able to address destinations in another seg- ment. This is handled by having two types of control flow instructions: “near” for intrasegment (within a segment) and “far” for intersegment (between segments) transfers. In far jumps, which must be unconditional, two 16-bit quantities follow the opcode in 16-bit mode. One of these is used as the instruction pointer, while the other is loaded into CS and becomes the new code segment. In 32- bit mode the first field is expanded to 32 bits to match the 32-bit program counter (EIP).

> 控制流说明必须能够解决另一个问题中的目的地。通过具有两种类型的控制流指令来解决这：内液（段内）的“接近”和“段”（段之间）转移的“远处”。在必须无条件的远距离跳跃中，两个 16 位数量以 16 位模式遵循 OPODE。其中一个用作指令指针，而另一个则将其加载到 CS 中，并成为新的代码段。在 32 位模式下，第一个字段将扩展到 32 位，以匹配 32 位程序计数器（EIP）。

Calls and returns work similarly—a far call pushes the return instruction pointer and return segment on the stack and loads both the instruction pointer and the code segment. A far return pops both the instruction pointer and the code segment from the stack. Programmers or compiler writers must be sure to always use the same type of call _and_ return for a procedure—a near return does not work with a far call, and _vice versa_.

> 呼叫和返回的工作类似 - 远处的呼叫推动了返回指令指针和返回段，并加载了指令指针和代码段。遥远的返回可以从堆栈中弹出指令指针和代码段。程序员或编译器作家必须确保始终使用相同类型的呼叫_和_返回以进行一个过程 - 靠近返回不适合远程通话，_vice versa_。

String instructions are part of the 8080 ancestry of the 80x86 and are not commonly executed in most programs.

> 字符串说明是 80x86 的 8080 血统的一部分，并且在大多数程序中不常见。

[Figure K.34](#_bookmark873) lists some of the integer 80x86 instructions. Many of the instructions are available in both byte and word formats.

> [图 K.34]（#_ bookmark873）列出了一些整数 80x86 说明。许多说明都有字节和单词格式。

JNZ, JZ Jump if condition to IP + 8-bit offset; JNE (for JNZ) and JE (for JZ) are alternative names JMP, JMPF Unconditional jump—8- or 16-bit offset intrasegment (near) and intersegment (far) versions CALL, CALLF Subroutine call—16-bit offset; return address pushed; near and far versions

> JNZ，JZ 跳转如果条件到 IP + 8 位偏移；jne（用于 JNZ）和 JE（用于 JZ）是 JMP 的替代名称，JMPF 无条件跳跃 -  8 或 16 位偏移式内 insement（近）和分段（FAR）版本，呼叫呼叫，Callf SubRoutine 呼叫-16 位偏移;推动返回地址；近乎遥远的版本

RET, RETF Pops return address from stack and jumps to it; near and far versions LOOP Loop branch—decrement CX; jump to IP + 8-bit displacement if CX ¦ 0 **Data transfer Move data between registers or between register and memory**

> RET，RETF 从 Stack 弹出返回地址并跳到它；近距离循环循环分支-Decrement CX；跳到 IP + 8 位位移，如果 CX�0 **数据传输在寄存器之间或在寄存器和内存之间移动数据**

Figure K.34 Some typical operations on the 80x86. Many operations use register-memory format, where either the source or the destination may be memory and the other may be a register or immediate operand.

> 图 K.34 在 80x86 上进行了一些典型操作。许多操作都使用寄存器内存格式，其中源或目的地可能是内存，而另一个可以是寄存器或立即操作数。

### 80x86 Floating-Point Operations

> ### 80x86 浮点操作

Intel provided a stack architecture with its floating-point instructions: loads push numbers onto the stack, operations find operands in the top two elements of the stacks, and stores can pop elements off the stack, just as the stack example in Figure A.31 on page A-4 suggests.

> 英特尔提供了一个堆栈体系结构，上面有其浮点指令：将推送数字加载到堆栈上，操作在堆栈的前两个元素中查找操作数，并且商店可以将堆栈弹出，就像图 A.31 中的堆栈示例一样在 A-4 页上建议。

Intel supplemented this stack architecture with instructions and addressing modes that allow the architecture to have some of the benefits of a register-memory model. In addition to finding operands in the top two elements of the stack, one operand can be in memory or in one of the seven registers below the top of the stack. This hybrid is still a restricted register-memory model, however, in that loads always move data to the top of the stack while incrementing the top of stack pointer and stores can only move the top of stack to memory. Intel uses the notation ST to indicate the top of stack, and ST(i) to represent the *i*th register below the top of stack. One novel feature of this architecture is that the operands are wider in the reg- ister stack than they are stored in memory, and all operations are performed at this wide internal precision. Numbers are automatically converted to the internal 80-bit format on a load and converted back to the appropriate size on a store. Memory data can be 32-bit (single-precision) or 64-bit (double-precision) floating-point numbers, called _real_ by Intel. The register-memory version of these instructions will then convert the memory operand to this Intel 80-bit format before performing the operation. The data transfer instructions also will automatically convert 16- and 32-bit integers to reals, and _vice versa_, for integer loads and stores.

> 英特尔通过说明和寻址模式补充了这一堆栈体系结构，使体系结构具有寄存器记忆模型的某些好处。除了在堆栈的前两个元素中找到操作数外，一个操作数还可以在存储器中，也可以在堆栈顶部以下的七个寄存器之一中之一。该混合动力车仍然是一个受限制的寄存器内存模型，但是，该负载始终将数据移至堆栈顶部，同时增加堆栈指针的顶部，而商店只能将堆栈顶部移至内存。英特尔使用符号 st 表示堆栈的顶部，然后 st（i）表示堆栈顶部下方的 *i *th 寄存器。该体系结构的一个新颖功能是，在列堆堆栈中，操作数比存储在内存中的堆栈更宽，并且所有操作均以这种宽阔的内部精度执行。数字会自动转换为负载上的内部 80 位格式，并将其转换回商店上的适当尺寸。内存数据可以是 32 位（单精度）或 64 位（双重精确）浮点数，由英特尔称为_real_。然后，这些说明的寄存器记忆版本将在执行操作之前将内存操作数转换为此 Intel 80 位格式。数据传输指令还将自动将 16 和 32 位整数转换为 REALS，以及_Vice versa_，以进行整数负载和存储。

The 80x86 floating-point operations can be divided into four major classes:

> 80x86 浮点操作可以分为四个主要类：

1. Data movement instructions, including load, load constant, and store

> 1.数据移动说明，包括负载，加载常数和存储

2. Arithmetic instructions, including add, subtract, multiply, divide, square root, and absolute value

> 2.算术指令，包括添加，减法，乘，分隔，平方根和绝对值

3. Comparison, including instructions to send the result to the integer CPU so that it can branch

> 3.比较，包括将结果发送到整数 CPU 的说明，以便它可以分支

4. Transcendental instructions, including sine, cosine, log, and exponentiation

> 4.先验说明，包括正弦，余弦，日志和凸

[Figure K.35](#_bookmark874) shows some of the 60 floating-point operations. We use the curly brackets {} to show optional variations of the basic operations: {I} means there is an integer version of the instruction, {P} means this variation will pop one operand off the stack after the operation, and {R} means reverse the sense of the operands in this operation.

> [图 K.35]（#_ bookmark874）显示了 60 个浮点操作中的一些。我们使用卷曲括号{}显示基本操作的可选变化：{i}意味着指令的整数版本，{p}意味着此变体将在操作后弹出一个操作数，并且{r}意味着在此操作中扭转操作数的意义。

Figure K.35 The floating-point instructions of the 80x86. The first column shows the data transfer instructions, which move data to memory or to one of the registers below the top of the stack. The last three operations push constants on the stack: pi, 1.0, and 0.0. The second column contains the arithmetic operations described above. Note that the last three operate only on the top of stack. The third column is the compare instructions. Since there are no special floating-point branch instructions, the result of the compare must be transferred to the integer CPU via the FSTSW instruction, either into the AX register or into memory, followed by an SAHF instruction to set the condition codes. The floating-point comparison can then be tested using integer branch instructions. The final column gives the higher-level floating-point operations.

> 图 K.35 80x86 的浮点指令。第一列显示了数据传输指令，该说明将数据移至内存或堆栈顶部以下的寄存器之一。最后三个操作将堆栈上的常数推向：PI，1.0 和 0.0。第二列包含上述算术操作。请注意，最后三个仅在堆栈顶部工作。第三列是比较说明。由于没有特殊的浮点分支指令，因此必须通过 FSTSW 指令将比较的结果传输到整数 CPU 中，无论是将其转移到 AX 寄存器或内存中，然后进行 SAHF 指令以设置条件代码。然后可以使用整数分支指令对浮点比较进行测试。最后一列给出了更高级别的浮点操作。

There are no pop or reverse pop versions of the integer subtract instructions.

> 整数减去指令没有 POP 或反向 POP 版本。

Note that we get even more combinations when including the operand modes for these operations. The floating-point add has these options, ignoring the integer and pop versions of the instruction:

> 请注意，在包括这些操作的操作数模式时，我们将获得更多组合。浮点添加具有以下选项，忽略了该说明的整数和 POP 版本：

As mentioned earlier SSE2 presents a model of IEEE floating-point registers.

> 如前所述，SSE2 提出了 IEEE 浮点寄存器的模型。

### 80x86 Instruction Encoding

> ### 80x86 指令编码

Saving the worst for last, the encoding of instructions in the 8086 is complex, with many different instruction formats. Instructions may vary from 1 byte, when there are no operands, to up to 6 bytes, when the instruction contains a 16-bit immediate and uses 16-bit displacement addressing. Prefix instructions increase 8086 instruc- tion length beyond the obvious sizes.

> 保存最糟糕的最后，8086 中指令的编码很复杂，具有许多不同的说明格式。指令可能从 1 个字节（没有操作数时）变化，最多可达 6 个字节，当该说明包含 16 位即时并使用 16 位排量地址时。前缀指令将 8086 的指令长度增加到明显的尺寸。

The 80386 additions expand the instruction size even further, as [Figure K.36](#_bookmark875) shows. Both the displacement and immediate fields can be 32 bits long, two more prefixes are possible, the opcode can be 16 bits long, and the scaled index mode spec- ifier adds another 8 bits. The maximum possible 80386 instruction is 17 bytes long. [Figure K.37](#_bookmark876) shows the instruction format for several of the example instruc- tions in [Figure K.33](#_bookmark872). The opcode byte usually contains a bit saying whether the operand is a byte wide or the larger size, 16 bits or 32 bits depending on the mode. For some instructions, the opcode may include the addressing mode and the reg- ister; this is true in many instructions that have the form register register op immediate. Other instructions use a “postbyte” or extra opcode byte, labeled “mod, reg, r/m” in [Figure K.36](#_bookmark875), which contains the addres- sing mode information. This postbyte is used for many of the instructions that address memory. The based with scaled index uses a second postbyte, labeled “sc, index, base” in [Figure K.36](#_bookmark875).

> 如[图 K.36]（#_ bookmark875）所示，80386 的添加进一步扩展了指令大小。位移和直接字段都可以长 32 位，可能还有两个前缀，OpCode 可以长 16 位，并且缩放索引模式表格 -  ifier 添加了另外 8 位。最大可能的 80386 指令为 17 个字节。[图 K.37]（#_ bookmark876）在[图 K.33]（#_ bookmark872）中显示了几种示例指令的指令格式。OpCode 字节通常包含一些说明操作数是字节宽还是更大的尺寸，16 位还是 32 位，具体取决于模式。对于某些说明，OpCode 可以包括寻址模式和 reg-Ister；在许多指示中，具有即时寄存器 OP 的许多说明是正确的。其他说明使用[图 k.36]（#_ bookmark875）中的“ potbyte”或额外的操作码，标记为“ mod，reg，r/m”，其中包含 addressing 模式信息。该邮政 BYTE 用于许多解决内存的指令。带有缩放索引的基础使用第二个延迟，在[图 K.36]（#_ bookmark875）中标记为“ SC，索引，基础”。

The floating-point instructions are encoded in the escape opcode of the 8086 and the postbyte address specifier. The memory operations reserve 2 bits to decide

> 浮点指令编码在 8086 的逃生 OPODE 和 postbyte 地址规范中。内存操作保留 2 位

Figure K.36 The instruction format of the 8086 (black type) and the extensions for the 80386 (shaded type). Every field is optional except the opcode.

> 图 K.36 8086（黑色类型）的指令格式和 80386（阴影类型）的扩展名。每个字段都是可选的，除了 opcode。

![](./media/image1281.png)
![](./media/image1284.png)
![](./media/image1287.png)
![](./media/image1291.png)
![](./media/image1293.png)
![](./media/image1297.png)
![](./media/image1300.png)

Figure K.37 Typical 8086 instruction formats. The encoding of the postbyte is shown in [Figure K.38](#_bookmark877). Many instructions contain the 1-bit field w, which says whether the oper- ation is a byte or a word. Fields of the form v/w or d/w are a d-field or v-field followed by the w-field. The d-field in MOV is used in instructions that may move to or from memory and shows the direction of the move. The field v in the SHL instruction indicates a variable-length shift; variable-length shifts use a register to hold the shift count. The ADD instruction shows a typical optimized short encoding usable only when the first operand is AX. Overall instructions may vary from 1 to 6 bytes in length.

> 图 K.37 典型的 8086 指令格式。[图 K.38]（#_ bookmark877）中显示了延迟的编码。许多说明包含 1 位字段 W，该字段表示操作是字节还是单词。V/W 或 D/W 形式的字段是 D 场或 V 场，其次是 W 场。MOV 中的 D-Field 用于可能移动或从内存移动并显示移动方向的指令。SHL 指令中的字段 V 表示可变长度的变化；可变长度偏移使用寄存器来保存偏移计数。添加指令显示仅当第一个操作数为 AX 时，仅在第一个操作数时才能使用典型的优化简短编码。总体说明的长度可能从 1 到 6 个字节不等。

whether the operand is a 32- or 64-bit real or a 16- or 32-bit integer. Those same 2 bits are used in versions that do not access memory to decide whether the stack should be popped after the operation and whether the top of stack or a lower reg- ister should get the result.

> 无论操作数是 32 位还是 64 位真实还是 16 位或 32 位整数。那些相同的 2 位在无法访问内存的版本中使用，以决定是否应在操作后弹出堆栈，以及堆栈的顶部还是下部的 reg-ister 应该得到结果。

Alas, you cannot separate the restrictions on registers from the encoding of the addressing modes in the 80x86. Hence, [Figures K.38](#_bookmark877) and [K.39](#_bookmark878) show the encoding of the two postbyte address specifiers for both 16- and 32-bit mode.

> las，您无法将寄存器的限制与 80x86 中的地址模式的编码分开。因此，[Figures K.38]（#_ bookmark877）和[K.39]（#_ bookmark878）显示了 16-和 32 位模式的两个 pottbyte 地址指定的编码。

Figure K.38 The encoding of the first address specifier of the 80x86, _mod, reg, r/m._ The first four columns show the encoding of the 3-bit reg field, which depends on the w bit from the opcode and whether the machine is in 16- or 32- bit mode. The remaining columns explain the mod and r/m fields. The meaning of the 3-bit r/m field depends on the value in the 2-bit mod field and the address size. Basically, the registers used in the address calculation are listed in the sixth and seventh columns, under mod ¼ 0, with mod ¼ 1 adding an 8-bit displacement and mod ¼ 2 adding a 16- or 32-bit displacement, depending on the address mode. The exceptions are r/m ¼ 6 when mod ¼ 1 or mod ¼ 2 in 16-bit mode selects BP plus the displacement; r/m ¼ 5 when mod ¼ 1 or mod ¼ 2 in 32-bit mode selects EBP plus displace- ment; and r/m ¼ 4 in 32-bit mode when mod ¦3 (sib) means use the scaled index mode shown in [Figure K.39](#_bookmark878). When mod ¼ 3, the r/m field indicates a register, using the same encoding as the reg field combined with the w bit.

> 图 k.38 80x86，_mod，reg，r/m._的第一个地址指定符的编码前四列显示了 3 位 reg 字段的编码，该编码取决于 opcode 的 W 位和是否是否该机器处于 16 或 32 位模式。其余列解释了 mod 和 r/m 字段。3 位 R/M 字段的含义取决于 2 位 MOD 字段和地址大小中的值。基本上，地址计算中使用的寄存器在第六列和第七列中列出了 mod¼0，mod¼1 添加了 8 位位移和 mod¼2 添加 16 或 32 位位移，取决于地址模式。当 Mod¼1 或 Mod¼2 在 16 位模式下选择 BP 加位移时，例外是 R/M¼6。r/m¼5 当 mod¼1 或 32 位模式中的 mod¼2 选择 EBP 加上位移；当 mod�3（sib）表示使用[图 K.39]（#_ bookmark878）中显示的缩放索引模式时，在 32 位模式下以 32 位模式为单位（＃bookmark878）时。当 mod¼3 时，r/m 字段表示寄存器，使用与 reg 字段相同的编码与 W 位相同的编码。

Figure K.39 Based plus scaled index mode address specifier found in the 80386. This mode is indicated by the (sib) notation in [Figure K.38](#_bookmark877). Note that this mode expands the list of registers to be used in other modes: Register indirect using ESP comes from Scale ¼ 0, Index ¼ 4, and Base ¼ 4, and base displacement with EBP comes from Scale ¼ 0, Index ¼ 5, and mod ¼ 0. The two-bit scale field is used in this formula of the effective address: Base register + 2<sup>Scale</sup> × Index register.

> 图 K.39 基于 80386 中找到的基于缩放索引模式的地址指定符。此模式由[图 K.38]中的（SIB）符号表示（#_ bookmark877）。请注意，此模式扩展了要在其他模式中使用的寄存器列表：使用 ESP 的寄存器来自 Scale¼0，index¼4 和 base¼4，并且带有 EBP 的基本位移来自秤 ¼0，索引 ¼5，5 和 mod¼0。在有效地址的此公式中使用了两位比例字段：基本寄存器 + 2 <sup> scale </sup>× 索引寄存器。

### Putting It All Together: Measurements of Instruction Set Usage

> ###将所有内容放在一起：指令的测量设置使用情况

In this section, we present detailed measurements for the 80x86 and then compare the measurements to MIPS for the same programs. To facilitate comparisons among dynamic instruction set measurements, we use a subset of the SPEC92 pro- grams. The 80x86 results were taken in 1994 using the Sun Solaris FORTRAN and C compilers V2.0 and executed in 32-bit mode. These compilers were comparable in quality to the compilers used for MIPS.

> 在本节中，我们介绍了 80x86 的详细测量结果，然后将测量值与同一程序的 MIPS 进行比较。为了促进在动态说明集测量中的比较，我们使用 SPEC92 程序的子集。80x86 的结果是在 1994 年使用 Sun Solaris Fortran 和 C Compilers v2.0 取得的，并以 32 位模式执行。这些编译器的质量与用于 MIPS 的编译器相当。

Remember that these measurements depend on the benchmarks chosen and the compiler technology used. Although we feel that the measurements in this section are reasonably indicative of the usage of these architectures, other programs may behave differently from any of the benchmarks here, and different compilers may yield different results. In doing a real instruction set study, the architect would want to have a much larger set of benchmarks, spanning as wide an application range as possible, and consider the operating system and its usage of the instruction set. Single-user benchmarks like those measured here do not necessarily behave in the same fashion as the operating system.

> 请记住，这些测量取决于所选的基准和所使用的编译器技术。尽管我们认为本节中的测量值合理地表明了这些体系结构的使用，但其他程序的行为可能与这里的任何基准不同，并且不同的编译器可能会产生不同的结果。在进行真实的指导集研究时，建筑师希望拥有更大的基准测试，尽可能宽，并考虑操作系统及其对指令集的使用。像这里测量的单用户基准相似的单用户基准不一定与操作系统相同。

We start with an evaluation of the features of the 80x86 in isolation, and later compare instruction counts with those of DLX.

> 我们从隔离 80x86 的特征进行评估，然后将指令计数与 DLX 的指令进行比较。

##### _Measurements of 80x86 Operand Addressing_

> ##### _ 80x86 操作数的测量_

We start with addressing modes. [Figure K.40](#_bookmark879) shows the distribution of the operand types in the 80x86. These measurements cover the “second” operand of the oper- ation; for example, counts as a single memory operand. If the types of the first operand were counted, the percentage of register usage would increase by about a factor of 1.5.

> 我们从解决模式开始。[图 K.40]（#_ bookmark879）显示了 80x86 中操作数类型的分布。这些测量涵盖了操作的“第二”操作数；例如，将其视为单个内存操作数。如果计算了第一操作数的类型，则注册使用率的百分比将增加约 1.5 倍。

The 80x86 memory operands are divided into their respective addressing modes in [Figure K.41](#_bookmark880). Probably the biggest surprise is the popularity of the

> 80x86 内存操作数分为[图 K.41]（#_ bookmark880）中的各自的寻址模式。可能最大的惊喜是

Figure K.40 Operand type distribution for the average of five SPECint92 programs (compress, eqntott, espresso, gcc, li) and the average of five SPECfp92 programs (doduc, ear, hydro2d, mdljdp2, su2cor).

> 图 K.40 的平均五个 Specint92 程序（压缩，Eqntott，Espresso，GCC，LI）的操作数类型分布和五个 SPECFP92 程序的平均值（DODUC，EAR，HYDRO2D，MDLJDP2，SU2COR）。

Figure K.41 Operand addressing mode distribution by program. This chart does not include addressing modes used by branches or control instructions.

> 图 K.41 操作数通过程序解决模式分布。该图表不包括分支机构或控制说明使用的方式。

addressing modes added by the 80386, the last four rows of the figure. They account for about half of all the memory accesses. Another surprise is the popu- larity of direct addressing. On most other machines, the equivalent of the direct addressing mode is rare. Perhaps the segmented address space of the 80x86 makes direct addressing more useful, since the address is relative to a base address from the segment register.

> 地址为 80386 添加的模式，这是图的最后四行。他们占所有内存访问的一半。另一个惊喜是直接解决的人口。在大多数其他机器上，直接寻址模式的同等用途很少。也许 80x86 的分段地址空间使直接地址更有用，因为该地址相对于段寄存器的基础地址。

These addressing modes largely determine the size of the Intel instructions. [Figure K.42](#_bookmark881) shows the distribution of instruction sizes. The average number of bytes per instruction for integer programs is 2.8, with a standard deviation of 1.5, and 4.1 with a standard deviation of 1.9 for floating-point programs. The dif- ference in length arises partly from the differences in the addressing modes: Integer programs rely more on the shorter register indirect and 8-bit displacement addres- sing modes, while floating-point programs more frequently use the 80386 addres- sing modes with the longer 32-bit displacements.

> 这些解决模式在很大程度上决定了英特尔指令的大小。[图 K.42]（#_ bookmark881）显示了指令大小的分布。整数程序的平均每个说明的字节数为 2.8，标准偏差为 1.5，浮点程序的标准偏差为 1.9。长度的差异部分源于地址模式的差异：整数程序更多地依赖于较短的寄存器间接和 8 位排量插件模式，而浮点程序则更频繁地使用 80386 addres-sing modes and aidd addressing 模式。更长的 32 位位移。

Given that the floating-point instructions have aspects of both stacks and reg- isters, how are they used? [Figure K.43](#_bookmark882) shows that, at least for the compilers used in this measurement, the stack model of execution is rarely followed. (See Section L.3 for a historical explanation of this observation.)

> 鉴于浮点指令都具有堆栈和注册的各个方面，它们如何使用？[图 K.43]（#_ bookmark882）表明，至少对于此测量中使用的编译器，很少遵循执行的堆栈模型。（有关此观察的历史解释，请参见 L.3 节。）

Finally, [Figures K.44](#_bookmark883) and [K.45](#_bookmark884) show the instruction mixes for 10 SPEC92 programs.

> 最后，[图 K.44]（#_ bookmark883）和[k.45]（#_ bookmark884）显示了 10 个 Spec92 程序的指令混音。

##### _Comparative Operation Measurements_

> ##### _比较操作测量_

[Figures K.46](#_bookmark885) and [K.47](#_bookmark886) show the number of instructions executed for each of the 10 programs on the 80x86 and the ratio of instruction execution compared with that

> [图 K.46]（#_ bookmark885）和[k.47]（#_ bookmark886）显示了 80x86 上 10 个程序中执行的每个指令数量以及与此相比的指令之比

Figure K.43 The percentage of instructions for the floating-point operations (add, sub, mul, div) that use each of the three options for specifying a floating-point operand on the 80x86. The three options are (1) the strict stack model of implicit operands on the stack, (2) register version naming an explicit operand that is not one of the top two elements of the stack, and (3) memory operand.

> 图 K.43 使用三个选项中的每一个指定 80x86 上的浮点操作数。这三个选项是（1）堆栈上隐式操作数的严格堆栈模型，（2）登记版本，命名了一个明确的操作数，该操作数不是堆栈的前两个元素之一，以及（3）内存操作数。

for DLX: Numbers less than 1.0 mean that the 80x86 executes fewer instructions than DLX. The instruction count is surprisingly close to DLX for many integer programs, as you would expect a load-store instruction set architecture like DLX to execute more instructions than a register-memory architecture like the 80x86. The floating-point programs always have higher counts for the 80x86,

> 对于 DLX：小于 1.0 的数字意味着 80x86 执行的指令少于 DLX。对于许多整数程序，指令计数非常接近 DLX，因为您期望像 DLX 这样的负载商店指令集体系结构比 80x86（例如 80x86）执行更多的说明。浮点程序总是在 80x86 中具有较高的计数，

Figure K.44 80x86 instruction mix for five SPECfp92 programs.

> 图 K.44 80x86 五个 SPECFP92 程序的指令组合。

presumably due to the lack of floating-point registers and the use of a stack architecture.

> 大概是由于缺乏浮点寄存器和使用堆栈架构。

Another question is the total amount of data traffic for the 80x86 versus DLX, since the 80x86 can specify memory operands as part of operations while DLX can only access via loads and stores. Figures K.46 and K.47 also show the data reads, data writes, and data read-modify-writes for these 10 programs. The total

> 另一个问题是 80x86 与 DLX 的数据流量总量，因为 80x86 可以指定内存操作数作为操作的一部分，而 DLX 只能通过负载和商店访问。图 K.46 和 K.47 还显示了这 10 个程序的数据读取，数据写入和数据读取模式写入。总数

Figure K.45 80x86 instruction mix for five SPECint92 programs.

> 图 K.45 80x86 五个 Specint92 程序的指令组合。

accesses ratio to DLX of each memory access type is shown in the bottom rows, with the read-modify-write counting as one read and one write. The 80x86 performs about two to four times as many data accesses as DLX for floating-point programs, and 1.25 times as many for integer programs. Finally, [Figure K.48](#_bookmark887) shows the percentage of instructions in each category for 80x86 and DLX.

> 访问比率与每种内存访问类型的 DLX 显示在底部行中，其中读取模拟 - 写入为一个读取和一篇写入。80x86 的数据访问的数据访问大约是浮点程序的 DLX 的两倍，而整数程序的数据访问量是浮点程序的 1.25 倍。最后，[图 K.48]（#_ bookmark887）显示了 80x86 和 DLX 的每个类别中指令的百分比。

Figure K.47 Instructions executed and data accesses for five SPECfp92 programs on 80x86 and ratio to DLX.

> 图 K.47 指令执行和数据访问 80x86 的五个 SPECFP92 程序以及与 DLX 的比率。

### Concluding Remarks

> ###结论

##### _Beauty is in the eye of the beholder._

> ＃＃＃＃＃ _美在旁观者的眼中。_

As we have seen, “orthogonal” is not a term found in the Intel architectural dictio- nary. To fully understand which registers and which addressing modes are avail- able, you need to see the encoding of all addressing modes and sometimes the encoding of the instructions.

> 正如我们已经看到的那样，“正交”不是在英特尔建筑统计中找到的术语。为了充分了解哪些寄存器以及哪些地址模式可用，您需要查看所有寻址模式的编码，有时是指令的编码。

Figure K.48 Percentage of instructions executed by category for 80x86 and DLX for the averages of five SPECint92 and SPECfp92 programs of [Figures K.46](#_bookmark885) and [K.47](#_bookmark886).

> 图 K.48 由 80x86 的类别执行的指令百分比和[FIGURE K.46]的五个 SpecInt92 和 SpecFP92 程序的 DLX（#_ bookmark885）和[k.47]（#_ bookmark886）。

Some argue that the inelegance of the 80x86 instruction set is unavoidable, the price that must be paid for rampant success by any architecture. We reject that notion. Obviously, no successful architecture can jettison features that were added in previous implementations, and over time some features may be seen as unde- sirable. The awkwardness of the 80x86 began at its core with the 8086 instruction set and was exacerbated by the architecturally inconsistent expansions of the 8087, 80286, and 80386.

> 有人认为，不可避免的是 80x86 指令集的不可避免，这是任何架构都必须为猖 ramp 的成功而支付的价格。我们拒绝那个观念。显然，没有成功的架构可以抛弃以前实施中添加的功能，并且随着时间的推移，某些功能可能被认为是不可思议的。80x86 的尴尬始于 8086 的指令，并因 8087、80286 和 80386 的建筑不一致的扩展而加剧。

A counterexample is the IBM 360/370 architecture, which is much older than the 80x86. It dominates the mainframe market just as the 80x86 dominates the PC market. Due undoubtedly to a better base and more compatible enhancements, this instruction set makes much more sense than the 80x86 more than 30 years after its first implementation.

> 反例是 IBM 360/370 体系结构，比 80x86 年龄大得多。就像 80x86 统治 PC 市场一样，它主导了大型机市场。毫无疑问，由于其首次实施后 30 年以上的 80x86，这一说明集毫无疑问，该指令集比 80x86 更有意义。

For better or worse, Intel had a 16-bit microprocessor years before its compet- itors’ more elegant architectures, and this head start led to the selection of the 8086 as the CPU for the IBM PC. What it lacks in style is made up in quantity, making the 80x86 beautiful from the right perspective.

> 无论好坏，英特尔在竞争竞争之前就拥有了 16 位微处理器的数年，而这一主启动导致将 8086 作为 IBM PC 的 CPU 选择。它缺乏风格的数量组成，从正确的角度使 80x86 美丽。

The saving grace of the 80x86 is that its architectural components are not too difficult to implement, as Intel has demonstrated by rapidly improving perfor- mance of integer programs since 1978. High floating-point performance is a larger challenge in this architecture.

> 80x86 的节省优势在于，它的建筑组件并不难实施，因为英特尔自 1978 年以来通过快速改善整数程序的速度来证明。高浮点的性能是这种体系结构的更大挑战。
