## Introduction

> ＃＃ 介绍

This appendix covers 10 instruction set architectures, some of which remain a vital part of the IT industry and some of which have retired to greener pastures. We keep them all in part to show the changes in fashion of instruction set architecture over time.

> 该附录涵盖了 10 个指令集架构，其中一些仍然是 IT 行业的重要组成部分，其中一些已退休为绿色的牧场。我们将它们全部保留，以展示随着时间的推移的教学方式架构的变化。

We start with eight RISC architectures, using RISC V as our basis for compar- ison. There are billions of dollars of computers shipped each year for ARM (includ- ing Thumb-2), MIPS (including microMIPS), Power, and SPARC. ARM dominates in both the PMD (including both smart phones and tablets) and the embedded markets.

> 我们从八个 RISC 架构开始，使用 RISC V 作为我们的比较基础。每年有数十亿美元的计算机运送了 ARM（包括 Thumb-2），MIPS（包括 Micromips），Power 和 Sparc。ARM 在 PMD（包括智能手机和平板电脑）和嵌入式市场中都占主导地位。

The 80x86 remains the highest dollar-volume ISA, dominating the desktop and the much of the server market. The 80x86 did not get traction in either the embed- ded or PMD markets, and has started to lose ground in the server market. It has been extended more than any other ISA in this book, and there are no plans to stop it soon. Now that it has made the transition to 64-bit addressing, we expect this architecture to be around, although it may play a smaller role in the future then it did in the past 30 years.

> 80x86 仍然是最高的美元体积 ISA，主导台式机和服务器市场的大部分。80x86 在嵌入式或 PMD 市场中都没有引起关注，并且已经开始在服务器市场失去基础。它的扩展比本书中的任何其他 ISA 都要多，并且没有计划尽快停止它。既然它已经过渡到 64 位讲话了，我们希望这种体系结构在附近，尽管它在将来可能比过去 30 年中扮演的角色较小。

The VAX typifies an ISA where the emphasis was on code size and offering a higher level machine language in the hopes of being a better match to programming languages. The architects clearly expected it to be implemented with large amounts of microcode, which made single chip and pipelined implementations more chal- lenging. Its successor was the Alpha, a RISC architecture similar to MIPS and RISC V, but which had a short life.

> VAX 代表 ISA，重点是代码尺寸并提供更高级别的机器语言，以期与编程语言更好地匹配。建筑师显然期望它可以用大量的微码实施，从而使单个芯片和管道实现更加挑剔。它的继任者是 Alpha，这是一种类似于 MIPS 和 RISC V 的 RISC 建筑，但寿命很短。

The vulnerable IBM 360/370 remains a classic that set the standard for many instruction sets to follow. Among the decisions the architects made in the early 1960s were:

> 脆弱的 IBM 360/370 仍然是经典，它为许多指令集设定了标准。建筑师在 1960 年代初做出的决定中是：

- 8-bit byte

> - 8 位字节

- Byte addressing

> - 字节寻址

- 32-bit words

> -32 位单词

- 32-bit single precision floating-point format + 64-bit double precision floating- point format

> - 32 位单精度浮点格式 + 64 位双精度浮动点格式

- 32-bit general-purpose registers, separate 64-bit floating-point registers

> - 32 位通用登记册，单独的 64 位浮点登记册

- Binary compatibility across a family of computers with different cost- performance

> - 具有不同成本性能的计算机家族的二进制兼容性

- Separation of architecture from implementation

> - 将体系结构与实施分开

As mentioned in Chapter 2, the IBM 370 was extended to be virtualizable, so it had the lowest overhead for a virtual machine of any ISA. The IBM 360/370 remains the foundation of the IBM mainframe business in a version that has extended to 64 bits.

> 如第 2 章所述，IBM 370 被扩展为虚拟化，因此对于任何 ISA 的虚拟机来说，它的开销最低。IBM 360/370 仍然是 IBM 大型机业务的基础，该版本已扩展到 64 位。

A Survey of RISC Architectures for Desktop, Server, and Embedded Computers

> 台式机，服务器和嵌入式计算机的 RISC 体系结构的调查

### Introduction

> ＃＃＃ 介绍

We cover two groups of Reduced Instruction Set Computer (RISC) architectures in this section. The first group is the desktop, server RISCs, and PMD processors:

> 我们涵盖了本节中两组减少的指令集（RISC）体系结构。第一组是桌面，服务器 RISC 和 PMD 处理器：

- Advanced RISC Machines ARMv8, AArch64, the 64-bit ISA,

> - 高级 RISC 机器 ARMV8，AARCH64，64 位 ISA，

- MIPS64, version 6, the most recent the 64-bit ISA,

> -MIPS64，第 6 版，最新的 64 位 ISA，

- Power version 3.0, which merges the earlier IBM Power architecture and the PowerPC architecture.

> - Power 版本 3.0，合并了较早的 IBM Power 架构和 PowerPC 体系结构。

- RISC-V, specifically RV64G, the 64-bit extension of RISC-V.

> -RISC-V，特别是 RV64G，RISC-V 的 64 位扩展。

- SPARCv9, the 64-bit ISA.

> -SPARCV9，64 位 ISA。

As [Figure K.1](#_bookmark842) shows these architectures are remarkably similar.

> 如[图 K.1]（#_ bookmark842）显示这些架构非常相似。

There are two other important historical RISC processors that are almost iden- tical to those in the list above: the DEC Alpha processor, which was made by Dig- ital Equipment Corporation from 1992 to 2004 and is almost identical to MIPS64. Hewlett-Packard’s PA-RISC was produced by HP from about 1986 to 2005, when it was replaced by Itanium. PA-RISC is most closely related to the Power ISA, which emerged from the IBM Power design, itself a descendant of IBM 801.

> 还有另外两个重要的历史 RISC 处理器与上面列表中的列表：DEC Alpha 处理器，这是由 Dig-Ital Equipment Corporation 从 1992 年到 2004 年制造的，几乎与 MIPS64 相同。惠普（Hewlett-Packard）的 PA-RISC 是由 HP 从 1986 年到 2005 年由 Itanium 取代的 HP 生产的。PA-RISC 与 Power ISA 最密切相关，ISA 来自 IBM Power Design，本身就是 IBM 801 的后代。

The second group is the embedded RISCs designed for lower-end applications:

> 第二组是专为低端应用程序设计的嵌入式 RISC：

- Advanced RISC Machines, Thumb-2: an 32-bit instruction set with 16-bit and 32-bit instructions. The architecture includes features from both ARMv7 and ARMv8.

> - 高级 RISC 机器，Thumb-2：32 位指令，带有 16 位和 32 位指令。该架构包括来自 ARMV7 和 ARMV8 的功能。

- microMIPS64: a version of the MIPS64 instruction set with 16-it instructions, and

> -MICROMIPS64：MIPS64 指令的版本，带有 16-IT 指令，以及

- RISC-V Compressed extension (RV64GC), a set of 16-bit instructions added to RV64G

> -RISC-V 压缩扩展（RV64GC），一组 16 位指令添加到 RV64G

Both RV64GC and microMIPS64 have corresponding 32-bit versions: RV32GC and microMIPS32.

> RV64GC 和 Micromips64 均具有相应的 32 位版本：RV32GC 和 Micromips32。

Since the comparison of the base 32-bit or 64-bit desktop and server architec- ture will examine the differences among those ISAs, our discussion of the embed- ded architectures focuses on the 16-bit instructions. [Figure K.2](#_bookmark843) shows that these embedded architectures are also similar. In all three, the 16-bit instructions are ver- sions of 32-bit instructions, typically with a restricted set of registers.The idea is to reduce the code size by replacing common 32-bit instructions with 16-bit versions. For RV32GC or Thumb-2, including the 16-bit instructions yields a reduction in code size to about 0.73 of the code size using only the 32-bit ISA (either RV32G or ARMv7).

> 由于基本 32 位或 64 位桌面和服务器架构的比较将检查这些 ISA 之间的差异，因此我们对嵌入架构的讨论着重于 16 位指令。[图 K.2]（#_ bookmark843）表明这些嵌入式体系结构也相似。在这三个中，16 位指令是 32 位指令的范围，通常具有限制性寄存器。该想法是通过用 16 位版本替换常见的 32 位指令来减少代码大小。对于 RV32GC 或 THUBS-2，包括 16 位指令仅使用 32 位 ISA（RV32G 或 ARMV7）将代码大小的代码大小减少到代码大小的 0.73。

<img src="./media/image834.png" style="width:0.23183in" />
<img src="./media/image835.png" style="width:0.23106in" />
<img src="./media/image836.png" style="width:0.23145in" />
<img src="./media/image837.png" style="width:0.24381in" />
<img src="./media/image838.png" style="width:0.23107in" />
![](./media/image839.png)
<img src="./media/image840.png" style="width:0.24459in" />
<img src="./media/image841.png" style="width:0.2385in" />
<img src="./media/image842.png" style="width:0.24411in" />
<img src="./media/image843.png" style="width:0.24247in" />
<img src="./media/image844.png" style="width:0.11587in" />
<img src="./media/image845.png" style="width:0.11587in" />
<img src="./media/image846.png" style="width:0.11587in" />
<img src="./media/image847.png" style="width:0.1151in" />
<img src="./media/image848.png" style="width:0.11587in" />
<img src="./media/image849.png" style="width:1.29356in;height:0.255in" />
<img src="./media/image850.png" style="width:0.68832in" />

![](./media/image851.png)
![](./media/image853.png)
<img src="./media/image854.png" style="width:0.48383in" />
![](./media/image855.png)
![](./media/image857.png)
![](./media/image858.png)
![](./media/image873.png)
<img src="./media/image878.png" style="width:1.13837in;height:0.2501in" />
<img src="./media/image879.png" style="width:0.7849in;height:0.22396in" />
![](./media/image880.png)
![](./media/image883.png)
![](./media/image886.png)
![](./media/image889.png)
<img src="./media/image892.png" style="width:1.08511in;height:0.11458in" />
<img src="./media/image893.png" style="width:0.69363in;height:0.25in" />
<img src="./media/image894.png" style="width:0.8327in;height:0.22458in" />
<img src="./media/image895.png" style="width:0.6941in;height:0.25in" />
<img src="./media/image896.png" style="width:0.69021in;height:0.25in" />
<img src="./media/image897.png" style="width:0.68536in;height:0.25in" />

Figure K.1 Summary of the most recent version of five architectures for desktop, server, and PMD use (all had earlier versions). Except for the number of data address modes and some instruction set details, the integer instruc- tion sets of these architectures are very similar. Contrast this with [Figure K.29](#_bookmark867). In ARMv8, register 31 is a 0 (like register 0 in the other architectures), but when it is used in a load or store, it is the current stack pointer, a special purpose register. We can either think of SP-based addressing as a different mode (which is how the assembly mnemonics operate) or as simply a register + offset addressing mode (which is how the instruction is encoded).

> 图 K.1 桌面，服务器和 PMD 使用的五个架构的最新版本的摘要（所有版本都具有较早的版本）。除了数据地址模式的数量和一些指令集的详细信息外，这些体系结构的整数仪器集非常相似。将此与[图 K.29]（#_ bookmark867）对比。在 ARMV8 中，寄存器 31 为 0（例如其他架构中的寄存器 0），但是当它在负载或存储中使用时，它是当前的堆栈指针，特殊目的寄存器。我们可以将基于 SP 的地址视为不同的模式（这就是汇编 mnemonics 操作的方式），或者仅仅是寄存器 + 偏移地址模式（这是对指令的编码方式）。

<img src="./media/image898.png" style="width:0.43733in" />
<img src="./media/image899.png" style="width:0.49888in" />
<img src="./media/image900.png" style="width:0.80725in" />
<img src="./media/image901.png" style="width:0.24271in" />
<img src="./media/image902.png" style="width:0.24394in" />
<img src="./media/image903.png" style="width:0.23915in" />
![](./media/image904.png)
![](./media/image908.png)
![](./media/image911.png)
![](./media/image916.png)
<img src="./media/image927.png" style="width:2.1201in;height:0.255in" />
<img src="./media/image928.png" style="width:0.88711in;height:0.52083in" />
<img src="./media/image929.png" style="width:0.64244in;height:0.22396in" />
![](./media/image930.png)

Figure K.2 Summary of three recent architectures for embedded applications. All three use 16-bit extensions of a base instruction set. Except for number of data address modes and a number of instruction set details, the integer instruction sets of these architectures are similar. Contrast this with [Figure K.29](#_bookmark867). An earlier 16-bit version of the MIPS instruction set, called MIPS16, was created in 1995 and was replaced by microMIPS32 and microMIPS64. The first Thumb architecture had only 16-bit instructions and was created in 1996. Thumb-2 is built primarily on ARMv7, the 32-bit ARM instruction set; it offers 16 registers. RISC-V also defines RV32E, which has only 16 registers, includes the 16-bit instructions, and cannot have floating point. It appears that most implementations for embedded appli- cations opt for RV32C or RV64GC.

> 图 K.2 嵌入式应用程序的三个最新体系结构的摘要。这三个都使用基本指令集的 16 位扩展。除了数据地址模式数量和许多指令集详细信息外，这些体系结构的整数指令集相似。将此与[图 K.29]（#_ bookmark867）对比。1995 年创建了早期的 16 位版本的 MIPS 指令集，称为 MIPS16，并被 Micromips32 和 Micromips64 取代。第一个拇指架构只有 16 位指令，并于 1996 年创建。Thumb-2 主要建立在 ARMV7（32 位 ARM 指示套件）上；它提供 16 个寄存器。RISC-V 还定义了 RV32E（只有 16 个寄存器）包括 16 位说明，并且不能具有浮点。看来，嵌入式应用的大多数实现都选择 RV32C 或 RV64GC。

A key difference among these three architectures is the structure of the base 32-bit ISA. In the case of RV64GC, the 32-bit instructions are exactly those of RV64G. This is possible because RISC V planned for the 16-it option from the beginning, and branch addresses and jump addresses are specified to 16-it boundaries. In the case of microMIPS64, the base ISA is MIPS64, with one change: branch and jump offsets are interpreted as 16-bit rather than 32-bit aligned. (microMIPS also uses the encoding space that was reserved in MIPS64 for user-defined instruction set extensions; such extensions are not part of the base ISA.)

> 这三个架构之间的一个关键区别是基本 32 位 ISA 的结构。在 RV64GC 的情况下，32 位指令正是 RV64G 的说明。这是可能的，因为 RISC V 从一开始就计划了 16 个 IT 选项，并且将分支地址和跳跃地址指定为 16 个边界。对于 Micromips64，基本 ISA 为 MIPS64，具有一个更改：分支和跳跃偏移被解释为 16 位而不是 32 位对齐。（Micromips 还使用在 MIPS64 中保留的编码空间用于用户定义的指令集扩展；此类扩展不是基本 ISA 的一部分。）

Thumb-2 uses a slightly different approach. The 32-bit instructions in Thumb- 2 are mostly a subset of those in ARMv7; certain features that were dropped in ARMv8 are not included (e.g., conditional execution of most instructions and the ability to write the PC as a GPR). Thumb-2 also includes a few dozen instruc- tions introduced in ARMv8, specifically bit field manipulation, additional system instructions, and synchronization support. Thus, the 32-bit instructions in Thumb- 2 constitute a unique ISA.

> Thumb-2 使用略有不同的方法。拇指 2 中的 32 位说明主要是 ARMV7 中的一个子集；不包括在 ARMV8 中删除的某些功能（例如，大多数指令的有条件执行以及将 PC 写入 GPR 的能力）。Thumb-2 还包括 ARMV8 中引入的几十个指令，特别是位现场操作，其他系统指令和同步支持。因此，拇指 2 中的 32 位说明构成了独特的 ISA。

Earlier versions of the 16-bit instruction sets for MIPS (MIPS16) and ARM (Thumb), took the approach of creating a separate mode, invoked by a procedure call, to transfer control to a code segment that employed only 16-bit instructions. The 16-bit instruction set was not complete and was only intended for user programs that were code-size critical.

> MIPS（MIPS16）和 ARM（Thumb）的 16 位指令集的早期版本采用了创建单独模式的方法，该模式通过程序调用调用，以将控制转移到仅采用 16 位指令的代码段。16 位指令集尚未完成，仅适用于代码尺寸关键的用户程序。

One complication of this description is that some of the older RISCs have been extended over the years. We decided to describe the most recent versions of the architectures: ARMv8 (the 64-bit architecture AArch64), MIPS64 R6, Power v3.0, RV64G, and SPARC v9 for the desktop/server/PMD, and the 16-bit subset of the ISAs for microMIPS64, RV64GC, and Thumb-2.

> 这种描述的一个复杂性是，多年来，一些较旧的 RISC 已延长。我们决定描述架构的最新版本：ARMV8（64 位体系结构 AARCH64），MIPS64 R6，POWER V3.0，RV64G 和 SPARC V9 用于台式/服务器/PMD，以及 16 位子集的 16 位子集 Micromips64，RV64GC 和 Thumb-2 的 ISA。

The remaining sections proceed as follows. After discussing the addressing modes and instruction formats of our RISC architectures, we present the survey of the instructions in five steps:

> 其余部分进行如下。在讨论了 RISC 架构的寻址模式和指令格式之后，我们以五个步骤介绍了指令的调查：

- Instructions found in the RV64G core, described in Appendix A.

> - 在附录 A 中描述的 RV64G 核心中找到的说明。

- Instructions not found in the RV64G or RV64GC but found in two or more of the other architectures. We describe and organize these by functionality, e.g. instructions that support extended integer arithmetic.

> - 在 RV64G 或 RV64GC 中找不到的说明，但在其他两个或多个架构中找到。我们通过功能来描述和组织它们，例如支持扩展整数算术的说明。

- Instruction groups unique to ARM, MIPS, Power, or SPARC, organized by function.

> - 通过功能组织的手臂，MIP，功率或 SPARC 独有的指导组。

- Multimedia extensions of the desktop/server/PMD RISCs

> - 桌面/服务器/PMD RISC 的多媒体扩展

- Digital signal-processing extensions of the embedded RISCs

> - 嵌入式 RISC 的数字信号处理扩展

Although the majority of the instructions in these architectures are included, we have not included every single instruction; this is especially true for the Power and ARM ISAs, which have _many_ instructions.

> 尽管包括这些体系结构中的大多数说明，但我们并未包含每个指令。对于具有_many_指令的力量和手臂 ISA 尤其如此。

![](./media/image933.png)
![](./media/image937.png)
![](./media/image941.png)
![](./media/image945.png)
![](./media/image949.png)
<img src="./media/image953.png" style="width:0.22275in;height:0.10417in" />
![](./media/image954.png)
![](./media/image958.png)
![](./media/image962.png)
![](./media/image964.png)

### Addressing Modes and Instruction Formats

> ###地址模式和指令格式

[Figure K.3](#_bookmark844) shows the data addressing modes supported by the desktop/server/ PMD architectures. Since all, but ARM, have one register that always has the value 0 when used in address modes, the absolute address mode with limited range can be synthesized using register 0 as the base in displacement addressing. (This register can be changed by arithmetic-logical unit (ALU) operations in PowerPC, but is always zero when it is used in an address calculation.) Similarly, register indirect addressing is synthesized by using displacement addressing with an offset of 0. Simplified addressing modes is one distinguishing feature of RISC architectures. As [Figure K.4](#_bookmark845) shows, the embedded architectures restrict the registers that can be accessed with the 16-bit instructions, typically to only 8 registers, for most instructions, and a few special instructions that refer to other registers. [Figure K.5](#_bookmark846) shows the data addressing modes supported by the embedded architectures in their 16-bit instruction mode. These versions of load/store instructions restrict the reg- isters that can be used in address calculations, as well as significantly shorten the immediate fields, used for displacements.

> [图 K.3]（#_ bookmark844）显示了桌面/服务器/ PMD 架构支持的数据地址模式。自从 ARM（ARM）中，有一个寄存器在地址模式中使用时总是具有值 0 的一个寄存器，因此可以使用寄存器 0 作为位移地址中的基础合成具有有限范围的绝对地址模式。（该寄存器可以通过 PowerPC 中的算术逻辑单元（ALU）操作更改，但在地址计算中使用时始终为零。地址模式是 RISC 架构的一个区别特征。如[图 K.4]（#_ bookmark845）所示，嵌入式体系结构限制了可以使用 16 位指令访问的寄存器，通常仅为 8 个寄存器，对于大多数说明，以及一些参考其他寄存器的特殊说明。[图 K.5]（#_ bookmark846）显示了嵌入式体系结构在其 16 位指令模式下支持的数据地址模式。这些版本的负载/存储指令限制了可以在地址计算中使用的 iSTERS，并大大缩短了用于位移的直接字段。

![](./media/image966.png)
![](./media/image970.png)
![](./media/image974.png)
![](./media/image978.png)
![](./media/image981.png)
![](./media/image985.png)
![](./media/image933.png)
![](./media/image990.png)

References to code are normally PC-relative, although jump register indirect is supported for returning from procedures, for case statements, and for pointer func- tion calls. One variation is that PC-relative branch addresses are often shifted left 2 bits before being added to the PC for the desktop RISCs, thereby increasing the branch distance. This works because the length of all instructions for the desktop

> 对代码的引用通常为 PC 层次，尽管支持跳转寄存器间接用于从过程中返回，案例语句以及指针函数调用。一种变体是，PC 相关的分支地址通常在添加到 PC 上以供桌面 RISCS 移动 2 位，从而增加了分支距离。这是因为桌面的所有说明的长度

![](./media/image994.png)
![](./media/image995.png)
<img src="./media/image997.png" style="width:0.36279in" />
<img src="./media/image998.png" style="width:0.48409in" />
![](./media/image999.png)
![](./media/image1000.png)
![](./media/image1001.png)
![](./media/image1002.png)
![](./media/image1003.png)

Figure K.3 Summary of data addressing modes supported by the desktop architectures, where B, H, W, D indi- cate what datatypes can use the addressing mode. Note that ARM includes two different types of address modes with updates, one of which is included in Power.

> 图 K.3 桌面体系结构支持的数据地址模式的摘要，其中 B，H，W，D 指示数据类型可以使用地址模式。请注意，ARM 包含两种不同类型的地址模式，并具有更新，其中一种包含在电源中。

<img src="./media/image1007.png" style="width:0.15753in" />
![](./media/image1008.png)
<img src="./media/image1009.png" style="width:0.10545in" />
<img src="./media/image1010.png" style="width:0.23112in" />
<img src="./media/image1011.png" style="width:0.11774in" />
<img src="./media/image1012.png" style="width:0.11624in" />
<img src="./media/image1013.png" style="width:0.10666in" />
<img src="./media/image1014.png" style="width:2.06103in;height:0.11458in" />
<img src="./media/image1015.png" style="width:0.80428in" />
<img src="./media/image1016.png" style="width:0.95985in;height:0.1174in" /> 
<img src="./media/image1017.png" style="width:0.43911in" /> 
<img src="./media/image1018.png" style="width:0.49832in" />

![](./media/image1019.png)
![](./media/image1024.png)
<img src="./media/image1025.png" style="width:1.08174in;height:0.11375in" />
<img src="./media/image1026.png" style="width:1.10802in;height:0.255in" />
<img src="./media/image1027.png" style="width:0.94334in;height:0.22844in" />
<img src="./media/image1028.png" style="width:0.94332in;height:0.22844in" />

Figure K.4 Register encodings for the 16-bit subsets of microMIPS64, RV64GC, and Thumb-2, including the core general purpose registers, and special-purpose registers accessible by some instructions.

> 图 K.4 Micromips64，Rv64GC 和 Thumb-2 的 16 位子集的寄存器编码，包括核心通用寄存器以及某些说明可访问的特殊用途寄存器。

<img src="./media/image1029.png" style="width:0.96524in;height:0.11458in" />
<img src="./media/image1030.png" style="width:0.4396in" />
<img src="./media/image1031.png" style="width:0.49825in" />

![](./media/image1032.png)
![](./media/image1035.png)

Figure K.5 Summary of data addressing modes supported by the embedded architectures. microMIPS64, RV64c, and Thumb-2 show only the modes supported in 16-bit instruction formats. The stack pointer in RV64GC and micro- MIPS64 is a designed GPR; it is another version of r31 is Thumb-2. In microMIPS64, the global pointer is register 30 and is used by the linkage convention to point to the global variable data pool. Notice that typically only 8 registers are accessible as base registers (and as we will see as ALU sources and destinations).

> 图 K.5 嵌入式体系结构支持的数据解决模式的摘要。Micromips64，Rv64c 和 Thubs-2 仅显示 16 位指令格式支持的模式。RV64GC 和 Micro-MIPS64 中的堆栈指针是设计的 GPR；这是 R31 的另一个版本是 Thubs-2。在 Micromips64 中，全局指针是登记寄存器 30，并由链接约定使用以指向全局变量数据库。请注意，通常只有 8 个寄存器可以作为基本寄存器（以及我们将作为 Alu 来源和目的地）访问。

RISCs is 32 bits and instructions must be aligned on 32-bit words in memory. Embedded architectures and RISC V (when extended) have 16-bit-long instruc- tions and usually shift the PC-relative address by 1 for similar reasons.

> RISC 是 32 位，必须在记忆中的 32 位单词上对齐。嵌入式体系结构和 RISC V（延长时）具有 16 位的指标，并且由于类似的原因，通常将 PC 相关地址转换为 1。

[Figure K.6](#_bookmark847) shows the most important instruction formats of the desktop/server/ PMD RISC instructions. Each instruction set architecture uses four primary instruction formats, which typically include 90–98% of the instructions. The register-register format is used for register-register ALU instructions, while the ALU immediate format is used for ALU instructions with an immediate operand and also for loads and stores. The branch format is used for conditional branches, and the jump/call format for unconditional branches (jumps) and procedures calls. There are a number of less frequently used instruction formats that [Figure K.6](#_bookmark847) leaves out. [Figure K.7](#_bookmark848) summarizes these for the desktop/server/PMD architectures. Unlike, their 32-bit base architectures, the 16-bit extensions (microMIPS64, RV64GC, and Thumb-2) are focused on minimizing code. As a result, there are a larger number of instruction formats, even though there are far fewer instructions.

> [图 K.6]（#_ bookmark847）显示了桌面/服务器/ PMD RISC 指令的最重要的指令格式。每个指令集体系结构都使用四种主要指令格式，通常包括 90-98％的说明。寄存器注册格式用于注册注册 ALU 指令，而 ALU 即时格式用于带有直接操作数的 ALU 指令以及负载和商店。分支格式用于条件分支，而无条件分支（跳跃）和过程调用的跳跃/呼叫格式使用。[图 K.6]（#_ bookmark847）忽略了许多较少使用的指令格式。[图 K.7]（#_ bookmark848）总结了桌面/服务器/PMD 架构的这些。与他们的 32 位基础体系结构不同，16 位扩展（Micromips64，Rv64GC 和 Thumb-2）集中在最小化代码上。结果，即使指令少得多，也有更多的指令格式。

Figure K.6 Instruction formats for desktop/server RISC architectures. These four formats are found in all five archi- tectures. (The superscript notation in this figure means the width of a field in bits.) Although the register fields are located in similar pieces of the instruction, be aware that the destination and two source fields are sometimes scram- bled. Op the main opcode, Opx an opcode extension, Rd the destination register, Rs1 source register 1, Rs2 source register 2, and Const a constant (used as an immediate, address, mask, or sift amount). Although the labels on the instruction formats tell where various instructions are encoded, there are variations. For example, loads and stores, both use the ALU immediate form in MIPS. In RISC-V, loads use the ALU immediate format, while stores use the branch format.

> 图 K.6 桌面/服务器 RISC 架构的指令格式。这四种格式均在所有五个档案中找到。（该图中的上标表示法表示位于位的字段的宽度。）尽管寄存器字段位于类似的指令中，但请注意，目的地和两个源字段有时会被划定。OP 主码，OPX A OPCODE 扩展名，RD 目标寄存器，RS1 源寄存器 1，RS2 源寄存器 2 和 const and Constant（用作即时，地址，掩码或筛选金额）。尽管指令格式上的标签告诉了各种指令的编码位置，但仍有变化。例如，负载和商店都使用 MIPS 中的 Alu 即时形式。在 RISC-V 中，负载使用 ALU 即时格式，而商店则使用分支格式。

![](./media/image1040.png)
![](./media/image1043.png)
![](./media/image1044.png)
<img src="./media/image1046.png" style="width:0.91526in;height:0.11458in" />
![](./media/image1047.png)
<img src="./media/image1048.png" style="width:0.60285in;height:0.38021in" />
<img src="./media/image1049.png" style="width:1.34676in" />
![](./media/image1050.png)
![](./media/image1051.png)
![](./media/image1054.png)
<img src="./media/image1055.png" style="width:0.88488in;height:0.39062in" />
![](./media/image1056.png)
![](./media/image1057.png)
![](./media/image1058.png)
<img src="./media/image1061.png" style="width:3.83138in" />
![](./media/image1062.png)
![](./media/image1065.png)

Figure K.7 Other instruction formats beyond the four major formats of the previous figure. In some cases, there are formats very similar to one of the four core formats, but where a register field is used for other purposes. The Power architecture also includes a number of formats for vector operations.

> 图 K.7 其他指令格式以外的上图的四种主要格式。在某些情况下，有与四种核心格式之一非常相似的格式，但是将寄存器字段用于其他目的。功率架构还包括许多用于向量操作的格式。

microMIPs64 and RV64GC have eight and seven major formats, respectively, and Thumb-2 has 15. As [Figure K.8](#_bookmark849) shows, these involve varying number of register operands (0 to 3), different immediate sizes, and even different size register spec- ifiers, with a small number of registers accessible my most instructions, and fewer instructions able to access all 32 registers.

> Micromips64 和 Rv64GC 分别具有八种和七个主要格式，并且 Thumb-2 具有 15。如[图 K.8]（#_ bookmark849）显示，这些涉及不同数量的寄存器操作数（0 到 3），并且不同的直接尺寸，不同的直接尺寸，即使是不同的尺寸寄存器规格 - 少数寄存器可访问我的最多说明，并且能够访问所有 32 个寄存器的说明更少。

### Instructions

> ＃＃＃ 指示

The similarities of each architecture allow simultaneous descriptions, starting with the operations equivalent to the RISC-V 64-bit ISA.

> 每个体系结构的相似性允许同时描述，从相当于 RISC-V 64 位 ISA 的操作开始。

Figure K.8 Instruction formats for the 16-bit instructions of microMIPS64, RV64GC, and Thumb-2. For instructions with a destination and two sources, but only two register fields, the instruction uses one of the registers as both source and destination. Note that the extended opcode field (or function field) and immediate field sometimes over- lap or are identical. For RV64GC and microMIPS64, all the formats are shown; for Thumb-2, the Miscellaneous format includes 22 instructions with 12 slightly different formats; we use the extended opcode field, but a few of these instructions have immediate or register fields.

> 图 K.8 Micromips64，Rv64GC 和 Thumb-2 的 16 位指令的指令格式。对于带有目标和两个来源的说明，但只有两个寄存器字段，该指令将其中一个寄存器作为源和目的地。请注意，扩展的 OpCode 字段（或函数字段）和直接场有时过度或相同。对于 RV64GC 和 Micromips64，显示了所有格式。对于 Thubs-2，其他格式包含 22 个指令，其格式为 12 个略有不同的格式；我们使用扩展的 OpCode 字段，但是其中一些说明具有即时或登记字段。

##### _RV64G Core Instructions_

> ##### _rv64g 核心指令_

Almost every instruction found in the RV64G is found in the other architectures, as [Figures K.9 through K.19](#_bookmark850) show. (For reference, definitions of the RISC-V instruc- tions are found in Section A.9.) Instructions are listed under four categories: data transfer ([Figure K.9](#_bookmark850)); arithmetic, logical ([Figure K.10](#_bookmark851)); control ([Figure K.11](#_bookmark852) and [Figure K.12](#_bookmark853)); and floating point ([Figure K.13](#_bookmark854)).

> RV64G 中几乎所有的指示都在其他体系结构中找到，如[Figures K.9 至 K.19]（#_ bookmark850）节目。（作为参考，在 A.9 节中找到了 RISC-V 指定的定义。）指令在四个类别下列出：数据传输（[图 K.9]（#_ bookmark850））;算术，逻辑（[图 K.10]（#_ bookmark851））;控制（[图 K.11]（#_ bookmark852）和[图 K.12]（#_ bookmark853））;和浮点（[图 K.13]（#_ bookmark854））。

If a RV64G core instruction requires a short sequence of instructions in other architectures, these instructions are separated by semicolons in [Figure K.9 through](#_bookmark850) [Figure K.13](#_bookmark850). (To avoid confusion, the destination register will always be the left- most operand in this appendix, independent of the notation normally used with each architecture.).

> 如果 RV64G 核心指令需要在其他体系结构中进行简短的指令，则这些指令在[图 K.9 至]至]（#_ bookmark850）中的半 olon 分隔（图 K.13]（#_ bookmark850）。（为避免混淆，目标寄存器将始终是本附录中的最左侧操作数，而与通常在每个体系结构中使用的符号无关）。

##### _Compare and Conditional Branch_

> ##### _compare 和条件分支_

Every architecture must have a scheme for compare and conditional branch, but despite all the similarities, each of these architectures has found a different way to perform the operation! [Figure K.11](#_bookmark852) summarizes the control instructions, while [Figure K.12](#_bookmark853) shows details of how conditional branches are handled. SPARC uses the traditional four condition code bits stored in the program status word: _negative, zero, carry_, and _overflow_. They can be set on any arithmetic or logical instruction; unlike earlier architectures, this setting is optional on each instruction. An explicit option leads to fewer problems in pipelined implementation. Although condition codes can be set as a side effect of an operation, explicit compares are synthesized with a subtract using r0 as the destination. SPARC conditional branches test con- dition codes to determine all possible unsigned and signed relations. Floating point uses separate condition codes to encode the EEE 754 conditions, requiring a floating-point compare instruction. Version 9 expanded SPARC branches in four ways: a separate set of condition codes for 64-bit operations; a branch that tests the contents of a register and branches if the value is =, not=, <, <=, >=, or <= 0; three more sets of floating-point condition codes; and branch instructions that encode static branch prediction.

> 每个体系结构都必须具有一个比较和有条件分支的方案，但是尽管有所有相似之处，但这些架构中的每一个都找到了执行操作的不同方法！[图 K.11]（#_ bookmark852）总结了控制说明，而[图 K.12]（#_ bookmark853）显示了如何处理条件分支的详细信息。SPARC 使用在程序状态词中存储的传统四个条件代码位：_ nemengative，零，携带_和_OVERFLOW_。可以将它们设置在任何算术或逻辑指令上；与早期的体系结构不同，此设置是每个说明的可选设置。明确的选项会导致管道实施中的问题更少。尽管可以将条件代码设置为操作的副作用，但使用 R0 作为目的地将显式比较与减法合成。SPARC 条件分支测试协议代码确定所有可能的未签名和签名关系。浮点使用单独的条件代码来编码 EEE 754 条件，需要进行浮点比较指令。版本 9 通过四种方式扩展了 SPARC 分支：一组单独的条件代码，用于 64 位操作；如果值为=，非=，<，<=，> =或 <= 0，则测试寄存器内容和分支的分支。另外三套浮点条件代码；和编码静态分支预测的分支指令。

Power also uses four condition codes: _less than, greater than, equal_, and _sum- mary overflow_, but it has eight copies of them. This redundancy allows the Power instructions to use different condition codes without conflict, essentially giving Power eight extra 4-bit registers. Any of these eight condition codes can be the target of a compare instruction, and any can be the source of a conditional branch. The integer instructions have an option bit that behaves as if the integer is followed by a compare to zero that sets the first condition “register.” Power also lets the second “register” be optionally set by floating-point instructions. PowerPC provides logical operations among these eight 4-bit condition code registers (CRAND, CROR, CRXOR, CRNAND, CRNOR, CREQV), allowing more complex conditions to be tested by a single branch. Finally, Power includes a set of branch count registers, that are automatically decremented when tested, and can be used in a branch con- dition. There are also special instructions for moving from/to the condition register.

> Power 还使用四个条件代码：_没有，大于，等于_和_sum-Mary Overflow_，但它具有八个副本。这种冗余允许电源说明使用不同的条件代码而不会发生冲突，从本质上讲是额外的 4 位寄存器。这八个条件代码中的任何一个都可以是比较指令的目标，任何条件代码都可以是条件分支的来源。整数指令的选项位表现得好像整数之后是一个与零相比，该选项与设置第一个条件“寄存器”的零相比。电源还可以通过浮点指令选择将第二个“寄存器”选为。PowerPC 在这八个 4 位条件代码寄存器（Crand，cror，crxor，crnand，crnor，crnor，creqv）中提供了逻辑操作，从而可以通过单个分支测试更复杂的条件。最后，功率包括一组分支计数寄存器，测试时会自动减少，并且可以在分支结构中使用。还有从/从/条件寄存器移至条件寄存器的特殊说明。

![](./media/image1066.png)
![](./media/image1069.png)
<img src="./media/image1071.png" style="width:0.54191in" />
![](./media/image1072.png)
<img src="./media/image1078.png" style="width:0.54326in" />
<img src="./media/image1079.png" style="width:0.91426in" />
![](./media/image1080.png)
![](./media/image1081.png)

<img src="./media/image1086.png" style="width:1.13772in;height:0.24479in" />
<img src="./media/image1087.png" style="width:0.1329in" />
<img src="./media/image1088.png" style="width:0.13365in" />
![](./media/image1089.png)
<img src="./media/image1091.png" style="width:0.13367in" />
![](./media/image1092.png)
<img src="./media/image1094.png" style="width:0.3929in" />
<img src="./media/image1095.png" style="width:0.40995in" />
<img src="./media/image1096.png" style="width:0.33795in" />
<img src="./media/image1097.png" style="width:0.36242in" />
<img src="./media/image1098.png" style="width:0.35428in" />

![](./media/image1099.png)
![](./media/image1107.png)
![](./media/image1110.png)
![](./media/image1112.png)
![](./media/image1114.png)
<img src="./media/image1119.png" style="width:0.70767in" />
![](./media/image1120.png)
![](./media/image1125.png)
![](./media/image1144.png)

Figure K.9 Desktop RISC data transfer instructions equivalent to RV64G core. A sequence of instructions to syn- thesize a RV64G instruction is shown separated by semicolons. The MIPS and Power instructions for atomic opera- tions load and conditionally store a pair of registers and can be used to implement the RV64G atomic operations with at most one intervening ALU instruction. The SPARC instructions: compare-and-swap, swap, LDSTUB provide atomic updates to a memory location and can be used to build the RV64G instructions. The Power3 instructions provide all the functionality, as the RV64G instructions, depending on a function field.

> 图 K.9 桌面 RISC 数据传输指令等效于 RV64G 核心。显示了一系列指令，以结合 RV64G 指令的指令，显示了半隆分离。原子操作负载的 MIPS 和功率指令并有条件地存储一对寄存器，可用于实现 RV64G 原子操作，最多只能使用一个中间的 Alu 指令。SPARC 说明：比较和划分，交换，LDSTUB 为存储位置提供原子更新，可用于构建 RV64G 指令。power3 指令根据功能字段提供所有功能，如 RV64G 指令。

<img src="./media/image1155.png" style="width:1.09567in;height:0.10833in" />
<img src="./media/image1156.png" style="width:0.87384in" />
<img src="./media/image1157.png" style="width:0.4083in" />
<img src="./media/image1158.png" style="width:1.06698in" />
<img src="./media/image1159.png" style="width:0.43364in;height:0.11375in" />
<img src="./media/image1160.png" style="width:0.3347in" />
<img src="./media/image1161.png" style="width:0.21443in" />
<img src="./media/image1162.png" style="width:0.12835in" />
<img src="./media/image1163.png" style="width:0.19524in" />
![](./media/image1164.png)
![](./media/image1166.png)
<img src="./media/image1172.png" style="width:1.27484in;height:0.36458in" />
<img src="./media/image1173.png" style="width:1.21637in;height:0.50521in" />
<img src="./media/image1174.png" style="width:0.45084in;height:0.11156in" />
<img src="./media/image1175.png" style="width:1.14686in;height:0.24437in" />
![](./media/image1176.png)
![](./media/image1178.png)
![](./media/image1180.png)
![](./media/image1182.png)
![](./media/image1184.png)
![](./media/image1186.png)
<img src="./media/image1188.png" style="width:0.4099in" />
![](./media/image1189.png)
<img src="./media/image1191.png" style="width:0.35829in" />
![](./media/image1192.png)
![](./media/image1194.png)
![](./media/image1198.png)
![](./media/image1203.png)
![](./media/image1208.png)
![](./media/image1211.png)
![](./media/image1214.png)
![](./media/image1223.png)

Figure K.10 Desktop RISC arithmetic/logical instructions equivalent to RISC-V integer ISA. MIPS also provides instructions that trap on arithmetic overflow, which are synthesized in other architectures with multiple instructions. Note that in the “Arithmetic/logical” category all machines but SPARC use separate instruction mnemonics to indicate an immediate operand; SPARC offers immediate versions of these instructions but uses a single mnemonic. (Of course, these are separate opcodes!)

> 图 K.10 桌面 RISC 算术/逻辑指令等效于 RISC-V 整数 ISA。MIPS 还提供了捕获算术溢出的说明，这些说明是在带有多个指令的其他体系结构中合成的。请注意，在“算术/逻辑”类别中，所有机器都使用 SPARC 使用单独的指令 mnemonics 表示立即操作数；SPARC 提供了这些说明的即时版本，但使用了单个助记符。（当然，这些是单独的 opcodes！）

Figure K.11 Desktop RISC control instructions equivalent to RV64G.

> 图 K.11 桌面 RISC 控制指令等效于 RV64G。

Figure K.12 Summary of five desktop RISC approaches to conditional branches. Integer compare on SPARC is synthesized with an arithmetic instruction that sets the condition codes using r0 as the destination.

> 图 K.12 五个桌面 RISC 方法的摘要。与 SPARC 上的整数比较是通过算术指令合成的，该指令使用 R0 作为目的地设置条件代码。

RISC-V and MIPS are most similar. RISC-V uses a compare and branch with a full set of arithmetic comparisons. MIPS also uses compare and branch, but the comparisons are limited to equality and tests against zero. This limited set of con- ditions simplifies the branch determination (since an ALU operation is not required to test the condition), at the cost of sometimes requiring the use of a set-on-less-than instruction (SLT, SLTI, SLTU, SLTIU), which compares two operands and then set the destination register to 1 if less and to 0 otherwise. [Figure K.12](#_bookmark853) provides

> RISC-V 和 MIP 最相似。RISC-V 使用与完整的算术比较的比较和分支。MIPS 还使用比较和分支，但是比较仅限于零的平等和测试。这套有限的组合简化了分支的确定（由于不需要 ALU 操作来测试条件），而有时需要使用无设置的指令（SLT，SLT，SLTI，SLTU，，SLTU，SLTU，SLTIU），将两个操作数进行比较，然后将目标寄存器设置为 1，否则为 0。[图 K.12]（#_ bookmark853）提供

Figure K.13 Desktop RISC floating-point instructions equivalent to RV64G ISA with an empty entry meaning that the instruction is unavailable. ARMv8 uses the same assembly mnemonic for single and double precision; the reg- ister designator indicates the precision. “\*” is used as an abbreviation for S or D. For floating point compares all con- ditions: equal, not equal, less than, and less-then or equal are provided. Moves operate in both directions from/to integer registers. Classify sets a register based on whether the floating point quantity is plus or minus infinity, denorm, +/ 0, etc.). The sign-injection instructions take two operands, but are primarily used to form floating point move, negate, and absolute value, which are separate instructions in the other ISAs.

> 图 K.13 桌面 RISC 浮点指令等效于 RV64G ISA，其输入为空条目，这意味着该说明不可用。ARMV8 使用相同的组装助记符作为单精度和双重精度；Reg-Ister 指示符指示精度。“ \*”用作 S 或 D 的缩写。对于浮点，比较所有条件：相等，不相等，小于和较少或相等。移动从/到整数寄存器的两个方向运行。分类基于浮动点数量是加上还是减无穷大，denorm， +/ 0 等。签名指令采用两个操作数，但主要用于形成浮点移动，否定和绝对值，它们是另一个 ISA 中的单独说明。

additional details on conditional branch. RISC-V floating point comparisons sets an integer register to 0 or 1, and then use conditional branches on that content.MIPS also uses separate floating-point compare, which sets a floating point register to 0 or 1, which is then tested by a floating-point conditional branch.

> 条件分支的其他详细信息。RISC-V 浮点比较将整数寄存器设置为 0 或 1，然后在该内容上使用条件分支。MIPS 还使用单独的浮点比较，该比较将浮点寄存器设置为 0 或 1 浮点条件分支。

ARM is similar to SPARC, in that it provides four traditional condition codes that are optionally set. CMP subtracts one operand from the other and the difference sets the condition codes. Compare negative (CMN) _adds_ one operand to the other, and the sum sets the condition codes. TST performs logical AND on the two oper- ands to set all condition codes but overflow, while TEQ uses exclusive OR to set the first three condition codes. Like SPARC, the conditional version of the ARM branch instruction tests condition codes to determine all possible unsigned and signed relations. ARMv8 added both bit-test instructions and also compare and branch against zero. Floating point compares on ARM, set the integer condition codes, which are used by the B.cond instruction.

> ARM 与 SPARC 相似，因为它提供了四个可选设置的传统条件代码。CMP 从另一个操作数中减去一个操作数，而差异设置了条件代码。将负（CMN）_ADDS _一个操作数与另一个操作数进行比较，然后总和设置了条件代码。TST 执行逻辑和两个操作以及设置所有条件代码，但溢出，而 TEQ 使用独家或设置前三个条件代码。像 SPARC 一样，ARM 分支指令的条件版本测试条件代码，以确定所有可能的未签名和签名关系。ARMV8 添加了两个测试指令，还将分支与零进行比较和分支。浮点在 ARM 上进行比较，设置整数条件代码，该代码由 B.COND 指令使用。

As [Figure K.13](#_bookmark854) shows the floating point support is similar on all five architectures.

> 如[图 K.13]（#_ bookmark854）显示了所有五个架构上的浮点支撑相似。

##### _RV64GC Core 16-bit Instructions_

> ##### _rv64GC 核心 16 位指令_

[Figures K.14](#_bookmark857) through [K.17](#_bookmark855) summarize the data transfer, ALU, and control instruc- tions for our three embedded processors: microMIPS64, RV64GC, and Thumb-2. Since these architectures are all based on 32-bit or 64-bit versions of the full archi- tecture, we focus our attention on the functionality implemented by the 16-bit instructions. Since floating point is optional, we do not include it. I

> [图 K.14]（#_ bookmark857）通过[k.17]（#_ bookmark855）总结了我们三个嵌入式处理器的数据传输，ALU 和控制指标：Micromips64，rv64GC 和 Thumb-2。由于这些体系结构全部基于完整档案的 32 位或 64 位版本，因此我们将注意力集中在 16 位指令实施的功能上。由于浮点是可选的，因此我们不包括它。我

Figure K.14 Embedded RISC data transfer instructions equivalent to RV64GC 16-bit ISA; a blank indicates that the instruction is not a 16-bit instruction. Rather than show the instruction name, where appropriate, we show the num- ber of registers that can the base register for the address calculation, followed by the number of registers that can be the destination for a load or the source for a store, and finally, the size of the immediate used for address calculation. For example: 8; 8; 5 for a load means that there are 8 possible base registers, 8 possible destination registers for the load, and a 5-bit offset for the address calculation. For a store, 8; 8; 5, specifies that the source of the value to store comes from one of 8 registers. Remember that Thumb-2 also has 32-bit instructions (although not the full ARMv8 set) and that RV64GC and microMIPS64 have the full set of 32-bit instructions in RV64I or MIPS64.

> 图 K.14 嵌入的 RISC 数据传输指令等效于 RV64GC 16 位 ISA；空白表示指令不是 16 位指令。我们没有在适当的情况下显示指令名称，而是显示可以进行地址计算的基本寄存器的数量，然后是寄存器的数量，这些寄存器的数量可以是负载或商店的源头的目的地，并且最后，用于地址计算的即时使用的大小。例如：8;8;5 对于负载，意味着有 8 个可能的基本寄存器，8 个可能的负载目标寄存器以及用于地址计算的 5 位偏移。对于一家商店，8；8;5，指定存储的值的来源来自 8 个寄存器之一。请记住，Thubs-2 还具有 32 位指令（尽管不是完整的 ARMV8 集），并且 RV64GC 和 Micromips64 在 RV64I 或 MIPS64 中具有完整的 32 位指令。

Figure K.15 ALU instructions provided in RV64GC and the equivalents, if any, in the 16-bit instructions of micro- MIPS64 or Thumb-2. An entry shows the number of register sources/destinations, followed by the size of the imme- diate field, if it exists for that instruction. The add to stack pointer with scaled immediate instructions are used for adjusting the stack pointer and creating a pointer to a location on the stack. In Thumb, the add has two forms one with three operands from the 8-register subset (Lo) and one with two operands but any of 16-registers.

> 图 K.15 RV64GC 中提供的 ALU 指令以及 Micro-MIPS64 或 Thumb-2 的 16 位指令中的等效物（如果有）。条目显示了寄存器来源/目的地的数量，然后显示了该指令的登记量大小，然后显示了 InmeDiate 字段的大小。使用缩放的立即说明的添加到堆栈指针用于调整堆栈指针并创建指向堆栈位置的指针。在拇指中，添加的两种表格有两个，来自 8 型注册子集（LO）的三个操作数，另一个具有两个操作数，但有 16 个登记。

Figure K.16 Summary of three embedded RISC approaches to conditional branches. A blank indicates that the instruction does not exist. Thumb-2 uses 4 condition code bits; it provides a conditional branch that tests the 4-bit condition code and has a branch offset of 8 bits.

> 图 K.16 三种嵌入的 RISC 方法的摘要。空白表示该说明不存在。Thumb-2 使用 4 个条件代码位；它提供了一个条件分支，该分支测试 4 位条件代码，并具有 8 位分支偏移。

Figure K.17 Data transfer instructions not found in RISC-V core but found in two or more of the five desktop architectures. SPARC requires memory accesses to be aligned, while the other architectures support unaligned access, albeit, often with major performance penalties. The other architectures do not require alignment, but may use slow mechanisms to handle unaligned accesses.MIPS provides a set of instructions to handle misaligned accesses: LDL and LDR (load double left and load double right instructions) work as a pair to load a misaligned word; the corresponding store instructions perform the inverse. The Prefetch instruction causes a cache prefetch, while CACHE provides limited user control over the cache state.

> 图 K.17 数据传输指令在 RISC-V Core 中找不到，而是在五个桌面体系结构中的两个或多个中找到。SPARC 需要对齐内存访问，而其他体系结构通常会受到非对齐的访问，尽管通常会受到严重的性能惩罚。其他体系结构不需要对齐，但可能会使用缓慢的机制来处理非对齐的访问。MIPS 提供了一组指令来处理未对准的访问：LDL 和 LDR（加载双重左和加载双右指令）作为一对加载未对齐的未对齐的指令单词;相应的存储指令执行逆。预取指令会导致缓存预取，而缓存则提供了对缓存状态的用户控制有限。

### Instructions: Common Extensions beyond RV64G

> ###说明：RV64G 以外的常见扩展

[Figures K.15 through K.18](#_bookmark856) list instructions not found in [Figures K.9 through K.13](#_bookmark850) in the same four categories (data transfer, ALU, and control. The only significant floating point extension is the reciprocal instruction, which both MIPS64 and Power support. Instructions are put in these lists if they appear in more than one of the standard architectures. Recall that [Figure K.3](#_bookmark844) on page 6 showed the address modes supported by the various instruction sets. All three processors pro- vide more address modes than provided by RV64G. The loads and stores using these additional address modes are not shown in [Figure K.17](#_bookmark857), but are effectively additional data transfer instructions. This means that ARM has 64 additional load and store instructions, while Power3 has 12, and MIPS64 and SPARVv9 each have 4.

> [图 K.15 至 K.18]（#_ bookmark856）列表指令在同一四个类别（数据传输，Alu 和 Control）中[图 K.9 至 K.13]（#_ bookmark850）中找不到的指令。浮点扩展名是倒数指令，MIPS64 和电源支持均应。如果它们出现在多个标准体系结构中，则将指令放在这些列表中。请记住，[图 K.3]（#_ bookmark844）在第 6 页上显示了该列表。由各种指令集支持的地址模式。所有三个处理器的地址模式比 RV64G 提供的更多地址模式。使用这些附加地址模式的负载和商店未显示[图 K.17]（#_ bookmark857），但有效地显示其他数据传输说明。这意味着 ARM 具有 64 个额外的负载和存储说明，而 Power3 具有 12 个，MIPS64 和 SPARVV9 各有 4 个。

To accelerate branches, modern processors use dynamic branch prediction (see Section 3.3). Many of these architectures in earlier versions supported delayed branches, although they have been dropped or largely eliminated in later versions

> 为了加速分支，现代处理器使用动态分支预测（请参阅第 3.3 节）。这些架构中的许多在早期版本中都支持延迟分支，尽管它们已被删除或在以后的版本中被删除

Figure K.18 Control instructions not found in RV64G core but found in two or more of the other architectures. MIPS64 Release 6 has nondelayed and normal delayed branches, while SPARC v.9 has delayed branches with can- cellation based on the static prediction.

> 图 K.18 在 RV64G 核心中找不到的控制指令，但在其他两个或多个架构中发现。MIPS64 版本 6 具有非延迟和正常的延迟分支，而 SPARC V.9 的分支延迟分支，基于静态预测。

of the architecture, typically by offering a nondelayed version, as the preferred con- ditional branch. The SPARC “annulling” branch is an optimized form of delayed branch that executes the instruction in the delay slot only if the branch is taken; otherwise, the instruction is annulled. This means the instruction at the target of the branch can safely be copied into the delay slot since it will only be executed if the branch is taken. The restrictions are that the target is not another branch and that the target is known at compile time. (SPARC also offers a nondelayed jump because an unconditional branch with the annul bit set does _not_ execute the follow- ing instruction.).

> 该体系结构，通常是通过提供非延迟版本作为首选分支。SPARC“废除”分支是一种优化的延迟分支的形式，仅在获取分支时才在延迟插槽中执行指令；否则，该说明将被废止。这意味着可以将分支目标的指令安全地复制到延迟插槽中，因为仅在获取分支的情况下才能执行。限制是目标不是另一个分支，并且目标是在编译时已知的。（SPARC 还提供了非延长的跳跃，因为带有废除位置的无条件分支确实_not_执行以下指令。）。

In contrast to the differences among the full ISAs, the 16-bit subsets of the three embedded ISAs have essentially no significant differences other than those described in the earlier figures (e.g. size of immediate fields, uses of SP or other registers, etc.).

> 与完整 ISA 之间的差异相反，除了早期图中描述的三个嵌入 ISA 的 16 位子集基本没有显着差异（例如，直接域的大小，SP 或其他寄存器的使用等）。

Now that we have covered the similarities, we will focus on the unique features of each architecture. We first cover the desktop/server RISCs, ordering them by length of description of the unique features from shortest to longest, and then the embedded RISCs.

> 现在我们已经涵盖了相似之处，我们将重点关注每个体系结构的独特功能。我们首先介绍桌面/服务器 RISC，按照最短到最长的唯一功能的描述订购它们，然后订购嵌入式 RISC。

### Instructions Unique to MIPS64 R6

> ### MIPS64 R6 的说明

MIPS has gone through six generations of instruction sets. Generations 1–4 mostly added instructions. Release 6 eliminated many older instructions but also provided support for nondelayed branches and misaligned data access. [Figure K.19](#_bookmark858) summa- rizes the unique instructions in MIPS64 R6.

> MIPS 经历了六代指令集。一代 1-4 主要添加了说明。版本 6 消除了许多较旧的说明，但也为非延迟分支机构和未对准数据访问提供了支持。[图 K.19]（#_ bookmark858）总结了 MIPS64 R6 中的唯一说明。

Figure K.19 Additional instructions provided MIPS64 R6. In addition, there are several instructions for supporting virtual machines, most are privileged.

> 图 K.19 提供了 MIPS64 R6 的其他说明。此外，还有几种支持虚拟机的说明，大多数都具有特权。

### Instructions Unique to SPARC v.9

> ### Sparc v.9 独有的说明

Several features are unique to SPARC. We review the major figures and then sum- marize those and small differences in a figure.

> SPARC 独有的几个功能。我们回顾了主要数字，然后在一个数字中汇总了这些数字和小差异。

##### _Register Windows_

> #####注册窗口

The primary unique feature of SPARC is register windows, an optimization for reducing register traffic on procedure calls. Several banks of registers are used, with a new one allocated on each procedure call. Although this could limit the depth of procedure calls, the limitation is avoided by operating the banks as a circular buffer. The knee of the cost-performance curve seems to be six to eight banks; programs with deeper call stacks, would need to save and restore the registers to memory.

> SPARC 的主要独特功能是寄存器窗口，这是用于减少过程调用中寄存器流量的优化。使用了几列寄存器，每个程序呼叫都分配了一个新的寄存器。尽管这可能会限制程序调用的深度，但通过将银行作为圆形缓冲区操作来避免限制。成本效果曲线的膝盖似乎是六到八家银行。具有更深层次的呼叫堆栈的程序，需要保存并将寄存器还原为内存。

SPARC can have between 2 and 32 windows, typically using 8 registers each for the globals, locals, incoming parameters, and outgoing parameters. (Given that each window has 16 unique registers, an implementation of SPARC can have as few as 40 physical registers and as many as 520, although most have 128 to 136, so far.) Rather than tie window changes with call and return instructions, SPARC has the separate instructions SAVE and RESTORE. SAVE is used to “save” the caller’s window by pointing to the next window of registers in addition to performing an add instruction. The trick is that the source registers are from the caller’s window of the addition operation, while the destination register is in the callee’s window. SPARC compilers typically use this instruction for changing the stack pointer to allocate local variables in a new stack frame. RESTORE is the inverse of SAVE, bringing back the caller’s window while acting as an add instruction, with the source registers from the callee’s window and the destination register in the caller’s window. This automatically deallocates the stack frame. Compilers can also make use of it for generating the callee’s final return value.

> SPARC 可以具有 2 到 32 个窗口，通常使用 8 个寄存器，每个寄存器用于全球，当地人，传入参数和传出参数。（鉴于每个窗口都有 16 个唯一的寄存器，SPARC 的实现只能有 40 个物理寄存器和多达 520，尽管到目前为止，大多数人都有 128 至 136 个。SPARC 具有单独的说明保存和还原。除执行添加指令外，保存还用于指向寄存器的下一个窗口，以“保存”呼叫者的窗口。诀窍是，源寄存器来自加法操作的呼叫者窗口，而目标寄存器在 Callee 的窗口中。SPARC 编译器通常使用此指令将堆栈指针更改为在新的堆栈框架中分配本地变量。还原是保存的倒数，在充当添加指令时，将呼叫者的窗口带回了呼叫者的窗口，来自 Callee 窗口的源寄存器和呼叫者窗口中的目标寄存器。这会自动处理堆栈框架。编译器还可以利用它来生成 Callee 的最终回报值。

The danger of register windows is that the larger number of registers could slow down the clock rate. This was not the case for early implementations. The SPARC architecture (with register windows) and the MIPS R2000 architecture (without) have been built in several technologies since 1987. For several genera- tions the SPARC clock rate has not been slower than the MIPS clock rate for imple- mentations in similar technologies, probably because cache access times dominate register access times in these implementations. With the advent of multiple issue, which requires many more register ports, as will as register renaming or reorder buffers, register windows posed a larger penalty.Register windows were a feature of the original Berkeley RISC designs, and their inclusion in SPARC was inspired by those designs. Tensilica is the only other major architecture in use today employs them, and they were not included in the RISC-V ISA.

> 寄存器窗口的危险是，较大数量的寄存器可能会减慢时钟速度。早期实施并非如此。自 1987 年以来，SPARC 体系结构（带有寄存器窗口）和 MIPS R2000 体系结构（无）已在多种技术中构建。对于几种生成，SPARC 时钟速率的速度不如 MIPS 时钟速率慢于类似技术中的 MIPS 时钟速率，可能是因为 CACHE 访问时间在这些实现中占主导地位的注册访问时间。随着多个问题的出现，需要更多的寄存器端口，就像注册重命名或重新订购缓冲区一样，登记窗口造成了更大的罚款。注册窗口是原始伯克利 RISC 设计的功能，其包含在 SPARC 中的灵感来自那些设计。Tensilica 是当今使用的唯一其他主要建筑，它们雇用了它们，并且它们不包括在 RISC-V ISA 中。

##### _Fast Traps_

> ##### _fast 陷阱_

SPARCv9 includes support to make traps fast. It expands the single level of traps to at least four levels, allowing the window overflow and underflow trap handlers to be inter- rupted. The extra levels mean the handler does not need to check for page faults or misaligned stack pointers explicitly in the code, thereby making the handler faster. Two new instructions were added to return from this multilevel handler: RETRY (which retries the interrupted instruction) and DONE (which does not). To support user-level traps, the instruction RETURN will return from the trap in nonprivileged mode.

> SPARCV9 包括支持陷阱快速的支持。它将陷阱的单个级别扩展到至少四个级别，从而使窗户溢出和底流陷阱处理程序被破坏。额外的级别意味着处理程序不需要检查页面故障或代码中明确的堆栈指针，从而使处理程序更快。添加了两个新的说明，以从此多级处理程序中返回：重试（重试的指令中断）并完成（未完成）。为了支持用户级陷阱，指令返回将以非特权模式从陷阱返回。

##### _Support for LISP and Smalltalk_

> #####支持 LISP 和 SmallTalk

The primary remaining arithmetic feature is tagged addition and subtraction. The designers of SPARC spent some time thinking about languages like LISP and Smalltalk, and this influenced some of the features of SPARC already discussed: register windows, conditional trap instructions, calls with 32-bit instruction addresses, and multi-word arithmetic (see Taylor et al. \[1986\] and Ungar et al. \[1984\]). A small amount of support is offered for tagged data types with operations for addition, subtraction, and hence comparison. The two least-significant bits indi- cate whether the operand is an integer (coded as 00), so TADDcc and TSUBcc set the overflow bit if either operand is not tagged as an integer or if the result is too large. A subsequent conditional branch or trap instruction can decide what to do. (If the operands are not integers, software recovers the operands, checks the types of the operands, and invokes the correct operation based on those types.) It turns out that the misaligned memory access trap can also be put to use for tagged data, since loading from a pointer with the wrong tag can be an invalid access. [Figure K.20](#_bookmark859) shows both types of tag support.

> 剩余的算术特征是标记的加法和减法。SPARC 的设计师花了一些时间思考 LISP 和 SmallTalk 等语言，这影响了 SPARC 已经讨论过的某些功能：注册窗口，有条件的陷阱指令，带有 32 位指令地址的呼叫和多字算术（请参阅 Taylor）等人[1986 \]和 Ungar 等人[1984 \]）。为带有加法，减法操作的标记数据类型提供了少量支持，因此提供了比较。两个最不重要的位指示操作数是否为整数（编码为 00），因此 TADDCC 和 TSUBCC 将溢出位设置为溢流位，如果任何操作数没有标记为整数或结果太大。随后的条件分支或陷阱指令可以决定该怎么做。（如果操作数不是整数，则软件会恢复操作数，检查操作数的类型并根据这些类型调用正确的操作。）事实证明，未对准的内存访问陷阱也可以用于标记数据，由于用错误的标签从指针加载可能是无效的访问。[图 K.20]（#_ bookmark859）显示了两种类型的标签支持。

Figure K.20 SPARC uses the two least-significant bits to encode different data types for the tagged arithmetic instructions. (a) Integer arithmetic, which takes a single cycle as long as the operands and the result are integers. (b) The misaligned trap can be used to catch invalid memory accesses, such as trying to use an integer as a pointer. For lan- guages with paired data like LISP, an offset of –3 can be used to access the even word of a pair (CAR) and +1 can be used for the odd word of a pair (CDR).

> 图 K.20 SPARC 使用两个最不重要的位来编码标记算术指令的不同数据类型。（a）整数算术，只要操作数和结果是整数，就需要一个单个周期。（b）未对准的陷阱可用于捕获无效的内存访问，例如试图将整数用作指针。对于具有 LISP 等配对数据的语言，可以使用–3 的偏移量来访问一对（CAR）和 +1 的偶数单词，可用于一对奇数（CDR）。

Figure K.21 Additional instructions provided in SPARCv9. Although register windows are by far the most signif- icant distinction, they do not require many instructions!

> 图 K.21 SPARCV9 中提供的其他说明。尽管注册窗口是迄今为止最重要的区别，但它们不需要很多说明！

[Figure K.21](#_bookmark860) summarizes the additional instructions mentioned above as well as several others.

> [图 K.21]（#_ bookmark860）总结了上述其他说明以及其他一些说明。

### Instructions Unique to ARM

> ###手臂独有的说明

Earlier versions of the ARM architecture (ARM v6 and v7) had a number of unusual features including conditional execution of all instructions, and making the PC a general purpose register. These features were eliminated with the arrival of ARMv8 (in both the 32-bit and 64-bit ISA). What remains, however, is much of the complexity, at least in terms of the size of the instruction set. As [Figure K.3](#_bookmark844) on page 6 shows, ARM has the most addressing modes, including all those listed in the table; remember that these addressing modes add dozens of load/store instruc- tions compared to RVG, even though they are not listed in the table that follows. As [Figure K.6](#_bookmark847) on page 8 shows, ARMv8 also has by far the largest number of different instruction formats, which reflects a variety of instructions, as well as the different addressing modes, some of which are applicable to some loads and stores but not others.

> ARM 架构的早期版本（ARM V6 和 V7）具有许多异常功能，包括所有指令的有条件执行，并使 PC 成为通用寄存器。随着 ARMV8 的到来（在 32 位和 64 位 ISA）的到来时，这些特征被消除。但是，至少就指令集的大小而言，剩下的很大程度上是复杂的。如[图 K.3]（#_ bookmark844），第 6 页显示，ARM 的地址最多，包括表中列出的所有内容；请记住，与 RVG 相比，这些寻址模式与 RVG 相比增加了数十个负载/存储的指标，即使它们没有在随后的表中列出。如[图 K.6]（#_ bookmark847），第 8 页显示，ARMV8 还具有最多的不同指令格式，它反映了各种说明，以及不同的寻址模式，其中一些适用于有些负载和存储，但没有其他。

Most ARMv8 ALU instructions allow the second operand to be shifted before the operation is completed. This extends the range of immediates, but operand shifting is not limited to immediates. The shift options are shift left logical, shift right logical, shift right arithmetic, and rotate right. In addition, as in Power3, most ALU instructions can optionally set the condition flags. [Figure K.22](#_bookmark861) includes the additional instructions, but does not enumerate all the varieties (such as optional setting of the condition flags); see the caption for more detail. While conditional execution of all instructions was eliminated, ARMv8 provides a number of condi- tional instructions beyond the conditional move and conditional set, mentioned earlier.

> 大多数 ARMV8 ALU 说明允许在操作完成之前转移第二操作数。这扩展了即时的范围，但操作数不限于直接。换档选项为左右逻辑，右移，右移，右算术和右旋转。另外，如 Power3 中，大多数 ALU 指令可以选择设置条件标志。[图 K.22]（#_ bookmark861）包括其他说明，但并未列举所有品种（例如条件标志的可选设置）；有关更多详细信息，请参见标题。尽管取消了所有指令的有条件执行，但 ARMV8 提供了前面提到的条件移动和有条件设置之外的许多条件指令。

Figure K.22 Additional instructions provided in ARMv8, the AArch64 instruction set. Unless noted the instruction is available in a word and double word format, if there is a difference. Most of the ALU instructions can optionally set the condition codes; these are not included as separate instructions here or in earlier tables.

> 图 K.22 ARMV8（AARCH64 指令集）中提供的其他说明。除非有指示，如果有差异，则该指令以单词和双词格式可用。大多数 ALU 指令都可以选择设置条件代码；这些不包括在此处或早期表中作为单独的说明包含。

### Instructions Unique to Power3

> ### Power 独特的说明 3

Power3 is the result of several generations of IBM commercial RISC machines— IBM RT/PC, IBM Power1, and IBM Power2, and the PowerPC development, undertaken primarily by IBM and Motorola. First, we describe branch registers and the support for loop branches. [Figure K.23](#_bookmark862) then lists the other instructions pro- vided only in Power3.

> Power3 是 IBM 商业 RISC 机器几代的结果-IBM RT/PC，IBM Power1 和 IBM Power2 以及主要由 IBM 和 Motorola 进行的 PowerPC 开发。首先，我们描述了分支寄存器和对循环分支的支持。[图 K.23]（#_ bookmark862）然后列出仅在 Power3 中提供的其他指令。

**class Instruction name(s) Function**

> **类指令名称函数**

Data transfer LHBRX, LWBRX, LDBRX Loads a halfword/word/double word but reverses the byte order. SHBRX, SWBRX, SDBRX Stores a halfword/word/double word but reverses the byte order LDQ, STQ Load/store quadword to a register pair.

> 数据传输 LHBRX，LWBRX，LDBRX 加载半词/单词/双词，但逆转字节顺序。SHBRX，SWBRX，SDBRX 存储一个半词/word/double Word，但将字节顺序 LDQ，STQ LOAD/Store QuadWord 逆转为寄存器对。

Figure K.23 Additional instructions provided in Power3. Rotate instructions have two forms: one that sets a con- dition register and one that does not. There are a set of string instructions that load up to 32 bytes from an arbitrary address to a set of registers. These instructions will be phased out in future implementations, and hence we just mention them here.

> 图 K.23 Power3 中提供的其他说明。旋转说明有两种形式：一种设置一个条件寄存器和一种不设置寄存器。有一组字符串指令，从任意地址到一组寄存器，最多可加载 32 个字节。这些说明将在未来的实施中逐步淘汰，因此我们在这里只是提及它们。

##### _Branch Registers: Link and Counter_

> ##### _分支寄存器：链接和反词

Rather than dedicate one of the 32 general-purpose registers to save the return address on procedure call, Power3 puts the address into a special register called the _link register._ Since many procedures will return without calling another pro- cedure, link doesn’t always have to be saved away. Making the return address a special register makes the return jump faster since the hardware need not go through the register read pipeline stage for return jumps.

> Power3 并没有专用 32 个通用寄存器之一来保存返回地址，而是将地址放入一个名为_link 寄存器的特殊寄存器中。总是必须保存。将返回地址作为特殊寄存器使返回率更快，因为硬件不需要经过寄存器读取管道阶段以进行返回跳跃。

In a similar vein, Power3 has a _count register_ to be used in for loops where the program iterates for a fixed number of times. By using a special register the branch hardware can determine quickly whether a branch based on the count register is likely to branch, since the value of the register is known early in the execution cycle. Tests of the value of the count register in a branch instruction will automat- ically decrement the count register.

> 同样，power3 具有_count 寄存器_将用于循环中的循环，该程序迭代固定数量。通过使用特殊寄存器，分支硬件可以快速确定基于计数寄存器的分支是否可能要分支，因为寄存器的值在执行周期的早期已知。分支指令中计数寄存器值的测试将自动减少计数寄存器。

Given that the count register and link register are already located with the hard- ware that controls branches, and that one of the problems in branch prediction is getting the target address early in the pipeline (see Appendix C), the Power archi- tects decided to make a second use of these registers. Either register can hold a target address of a conditional branch. Thus, PowerPC supplements its basic con- ditional branch with two instructions that get the target address from these registers (BCLR, BCCTR). [Figure K.23](#_bookmark862) shows the several dozen instructions that have been added; note that there is an extensive facility for decimal floating point, as well.

> 鉴于计数寄存器和链路寄存器已经与控制分支的硬件相处，并且分支机构预测中的一个问题之一是在管道中获得目标地址（请参阅附录 C），所以电源档案决定了第二次使用这些寄存器。任何一个寄存器都可以保留条件分支的目标地址。因此，PowerPC 用两个指令从这些寄存器（BCLR，BCCTR）中获取目标地址。[图 K.23]（#_ bookmark862）显示了已添加的几个说明；请注意，也有足够的小数浮点设施。

### Instructions: Multimedia Extensions of the Desktop/Server RISCs

> ###说明：桌面/服务器 RISC 的多媒体扩展

Support for multimedia and graphics operations developed in several phases, beginning in 1996 with Intel MMX, MIPS MDMX, and SPARC VIS. As described in Section 4.3, which we assume the reader has read, these extensions allowed a register to be treated as multiple independent small integers (8 or 16 bits long) with arithmetic and logical operations done in parallel on all the items in a register. These initial SIMD extensions, sometimes called packed SIMD, were further developed after 2000 by widening the registers, partially or totally separating them from the general purpose or floating pointer registers, and by adding support for parallel floating point operations. RISC-V has reserved an extension for such packed SIMD instructions, but the designers have opted to focus on a true vector extension for the present. The vector extension RV64V is a vector architecture, and, as Section 4.3 points out, a true vector instruction set is considerably more general, and can typically perform the operations handled by the SIMD extensions using vector operations.

> 对多媒体和图形操作的支持以多个阶段开发，始于 1996 年 Intel MMX，MIPS MDMX 和 SPARC VIS。如第 4.3 节所述（我们假设读者已经阅读的，这些扩展程序允许寄存器被视为多个独立的小整数（长 8 或 16 位），并在寄存器中的所有项目上并行进行算术和逻辑操作。这些最初的 SIMD 扩展（有时称为包装的 SIMD）在 2000 年后通过扩大寄存器，部分或完全将它们与通用或浮动指针寄存器分开，并增加对并行浮点操作的支持，从而进一步开发。RISC-V 保留了此类包装的 SIMD 说明的扩展名，但设计师选择着眼于当前的真实向量扩展名。向量扩展 RV64V 是向量体系结构，如第 4.3 节指出的那样，真实的向量指令集更加笼统，并且通常可以执行使用向量操作的 SIMD 扩展程序处理的操作。

[Figure K.24](#_bookmark863) shows the basic structure of the SIMD extensions in ARM, MIPS, Power, and SPARC. Note the difference in how the SIMD “vector registers” are structured: repurposing the floating point, extending the floating point, or adding additional registers. Other key differences include support for FP as well as integers,

> [图 K.24]（#_ bookmark863）显示了 ARM，MIPS，POWER 和 SPARC 中 SIMD 扩展的基本结构。请注意 SIMD“向量寄存器”结构化的方式的区别：重新利用浮点，扩展浮点或添加其他寄存器。其他关键差异包括对 FP 和整数的支持，

Figure K.24 Structure of the SIMD extensions intended for multimedia support. In addition to the vector facility, The last row states whether the SIMD instruction set supports immediates (e.g, add vector immediate or AND vector immediate); the entry states the size of immediates for those ISAs that support them. Note that the fact that an imme- diate is present is encoded in the opcode space, and could alternatively be added to the next table as additional instructions. Power 3 has an optional Vector-Scalar Extension. The Vector-Scalar Extension defines a set of vector registers that overlap the FP and normal vector registers, eliminating the need to move data back and forth to the vector registers. It also supports double precision floating point operations.

> 图 K.24 SIMD 扩展的结构用于多媒体支持。除了向量设施外，最后一行还指出 SIMD 指令集是否支持即时（例如，添加矢量即时或即时添加矢量）；该条目指出了那些支持它们的 ISA 的立即大小。请注意，存在不变的事实是在 OpCode 空间中编码的，并且可以作为其他指令添加到下一个表中。Power 3 具有可选的矢量量表扩展。矢量量表扩展定义了一组向量寄存器，该向量寄存器与 FP 和正常向量寄存器重叠，从而消除了将数据来回移动到向量寄存器的需求。它还支持双精度浮点操作。

support for 128-bit integers, and provisions for immediate fields as operands in inte- ger and logical operations. Standard load and store instructions are used for moving data from the SIMD registers to memory with special extensions to handle moving less than a full SIMD register. SPARC VIS, which was one of the earliest ISA exten- sions for graphics, is much more limited: only add, subtract, and multiply are included, there is no FP support, and only limited instructions for bit element oper- ations; we include it in Figure K.24 but will not be going into more detail.

> 支持 128 位整数，以及作为整数和逻辑操作中的操作数的直接领域的规定。标准负载和存储说明用于将数据从 SIMD 寄存器移至内存，并具有特殊的扩展名，以处理小于完整的 SIMD 寄存器的移动。Sparc Vis 是最早的图形 ISA 扩展之一，它更加有限：仅包括添加，减法和倍数，没有 FP 支持，并且仅对位元素操作的指令有限；我们将其包含在图 K.24 中，但不会更详细。

[Figure K.25](#_bookmark864) shows the arithmetic instructions included in these SIMD exten- sions; only those appearing in at least two extensions are included. MIPS SIMD includes many other instructions, as does the Power 3 Vector-Scalar extension, which we do not cover. One frequent feature not generally found in general- purpose microprocessors is saturating operations. Saturation means that when a calculation overflows the result is set to the largest positive number or most neg- ative number, rather than a modulo calculation as in two’s complement arithmetic. Commonly found in digital signal processors (see the next subsection), these sat- urating operations are helpful in routines for filtering. Another common extension are instructions for accumulating values within a single register; the dot product instruction an the maximum/minimum instructions are typical examples.

> [图 K.25]（#_ bookmark864）显示了这些 simd 扩展中包含的算术指令；只有在至少两个扩展中出现的人。MIPS SIMD 还包括许多其他说明，我们不涵盖的 Power 3 矢量 - 标准扩展名也是如此。一般目的的微处理器中通常未发现的一个频繁功能是饱和操作。饱和度意味着，当计算溢出时，将结果设置为最大的正数或最负数，而不是像两个补体算术中那样的模量计算。在数字信号处理器中通常发现（请参阅下一个小节），这些 sat untrating 操作有助于过滤。另一个常见的扩展名是在单个寄存器中累积值的说明；点产品指令最大/最小指令是典型的示例。

In addition to the arithmetic instructions, the most common additions are log- ical and bitwise operations and instructions for doing version of permutations and packing elements into the SIMD registers. These additions are summarized in [Figure K.26](#_bookmark865), Lastly, all three extensions support SIMD FP operations, as summa- rized in [Figure K.27](#_bookmark866).

> 除了算术指令外，最常见的添加是对数字和位操作以及用于将置换版本和包装元素进行版本的指令以及在 SIMD 寄存器中进行的。这些添加在[图 K.26]（#_ bookmark865）中总结了，最后，所有三个扩展名支持 SIMD FP 操作，如[图 K.27]（#_ bookmark866）中所述。

Figure K.25 Summary of arithmetic SIMD instructions. B stands for byte (8 bits), H for half word (16 bits), and W for word (32 bits), D for double word (64 bits), and Q for quad word (128 bits). Thus, 8B means an operation on 8 bytes in a single instruction. Note that some instructions–such as adjacent add/subtract, or multiply–produce results that are twice the width of the inputs (e.g. multiply on 16 bytes produces 8 halfword results). Dot product is a multiply and accumulate. The SPARC VIS instructions are aimed primarily at graphics and are structured accordingly.

> 图 K.25 算术 SIMD 指令的摘要。b 代表字节（8 位），h 表示半单词（16 位），w 表示单词（32 位），d 用于双词（64 位），而 q 表示四词（128 位）。因此，8B 表示单个指令中 8 个字节的操作。请注意，某些指令（例如相邻的添加/减法或多生产结果）是输入宽度的两倍（例如，在 16 个字节上乘以 8 个半单词结果）。点产品是乘积并积累的。SPARC VIS 指令主要针对图形，并相应地构建。

Figure K.26 Summary of logical, bitwise, permute, and pack/unpack instructions, using the same format as the previous figure. When there is a single operand the instruction applies to the entire register; for logical operations there is no difference.Interleave puts together the elements (all even, odd, leftmost or rightmost) from two different registers to create one value; it can be used for unpacking. Pack moves the even or odd elements from two different registers to the leftmost and rightmost halves of the result. Shuffle creates a from two registers based on a mask that selects which source for each item. SPLAT copies a value into each item in a register.

> 图 K.26 使用与上图相同的格式，逻辑，位，置换和打包指令的摘要。当有一个操作数时，指令适用于整个寄存器；对于逻辑操作，没有差异。间隙将两个不同寄存器的元素（甚至是奇数，最左或最右）整合在一起，以创建一个值。它可用于解开包装。Pack 将偶数或奇数元素从两个不同的寄存器移动到结果的最左侧和最右边的一半。Shuffle 根据掩模从两个寄存器中创建 A，该掩码选择每个项目的源。Splat 将一个值复制到寄存器中的每个项目中。

![](./media/image1225.png)
![](./media/image1231.png)
![](./media/image1233.png)
![](./media/image1235.png)

<img src="./media/image1237.png" style="width:1.11481in;height:0.11458in" />
<img src="./media/image1238.png" style="width:1.15674in" />
![](./media/image1239.png)
![](./media/image1241.png)
![](./media/image1244.png)
![](./media/image1251.png)
![](./media/image1260.png)
![](./media/image1267.png)

Figure K.27 Summary of floating point, using the same format as the previous figure.

> 图 K.27 浮点的摘要，使用与上图相同的格式。

### Instructions: Digital Signal-Processing Extensions of the Embedded RISCs

> ###说明：嵌入式 RISC 的数字信号处理扩展

Both Thumb2 and microMIPS32 provide instructions for DSP (Digital Signal Pro- cessing) and multimedia operations. In Thumb2, these are part of the core instruc- tion set; in microMIPS32, they are part of the DSP extension. These extensions, which are encoded as 32-bit instructions, are less extensive than the multimedia and graphics support provided in the SIMD/Vector extensions of MIPS64 or ARMv8 (AArch64). Like those more comprehensive extensions, the ones in Thumb2 and microMIPS32 also rely on packed SIMD, but they use the existing integer registers, with a small extension to allow a wide accumulator, and only operate on integer data. RISC-V has specified that the “P” extension will support packed integer SIMD using the floating point registers, but at the time of publica- tion, the specification was not completed.

> Thumb2 和 Micromips32 均提供 DSP（数字信号程序）和多媒体操作的说明。在 Thumb2 中，这些是核心指标集的一部分；在 Micromips32 中，它们是 DSP 扩展的一部分。这些扩展名编码为 32 位指令，比 MIPS64 或 ARMV8（AARCH64）中提供的多媒体和图形支持不如多媒体和图形支持。像那些更全面的扩展名一样，Thumb2 和 Micromips32 中的扩展名也依赖于包装的 SIMD，但是他们使用现有的整数寄存器，并具有较小的扩展名来允许较宽的蓄能器，并且仅在整数数据上运行。RISC-V 已指定“ P”扩展名将使用浮点寄存器支持包装的整数 SIMD，但是在公开时，该规范尚未完成。

DSP operations often include linear algebra functions and operations such as convolutions; these operations produce intermediate results that will be larger than the inputs. In Thumb2, this is handled by a set of operations that produce 64-bit results using a pair of integer registers. In microMIPS32 DSP, there are 4 64-bit accumulator registers, including the Hi-Lo register, which is already exists for doing integer multiply and divide. Both architectures provide parallel arithmetic using bytes, halfwords, and words, as in the multimedia extensions in ARMv8 and MIPS64. In addition, the MIPS DSP extension handles fractional data, such data is heavily used in DSP operations. Fractional data items have a sign bit and the remaining bits are used to represent the fraction, providing a range of values from -1.0 to 0.9999 (in decimal). MIPS DSP supports two fractional data sizes Q15 and Q31 each with one sign bit and 15 or 31 bits of fraction.

> DSP 操作通常包括线性代数函数和诸如卷积之类的操作；这些操作产生的中间结果将大于输入。在 Thumb2 中，这是由一套使用一对整数寄存器产生 64 位结果的操作来处理的。在 Micromips32 DSP 中，有 4 个 64 位蓄能器寄存器，包括 HI-LO 寄存器，这些寄存器已经存在用于进行整数乘和分割的。两种体系结构都使用字节，半字和单词提供并行算术，如 ARMV8 和 MIPS64 中的多媒体扩展中。此外，MIPS DSP 扩展处理分数数据，此类数据大量用于 DSP 操作。分数数据项具有符号位，其余位用于表示分数，提供了一个从-1.0 到 0.9999（小数点）的值范围。MIPS DSP 支持两个分数数据 Q15 和 Q31 每个符号位和 15 或 31 位的分数。

[Figure K.28](#_bookmark867) shows the common operations using the same notation as was used in [Figure K.25](#_bookmark864). Remember that the basic 32-bit instruction set provides additional functionality, including basic arithmetic, logical, and bit manipulation.

> [图 K.28]（#_ bookmark867）使用与[图 K.25]（#_ bookmark864）中使用的相同符号显示了共同的操作。请记住，基本的 32 位指令集提供了其他功能，包括基本算术，逻辑和位操作。

halfword and subtracts second) with optional saturation

> 半词和第二次减去）可选饱和

Figure K.28 Summary of two embedded RISC DSP operations, showing the data types for each operation. A blank indicates that the operation is not supported as a single instruction. Byte quantities are usually unsigned. Complex multiplication step implements multiplication of complex numbers where each component is a Q15 value. ARM uses its standard condition register, while MIPS adds a set of condition bits as part of the state in the DSP extension.

> 图 K.28 两个嵌入式 RISC DSP 操作的摘要，显示了每个操作的数据类型。空白表示该操作不受单个指令的支持。字节数量通常未签名。复杂的乘法步骤实现了每个组件为 Q15 值的复数的乘法。ARM 使用其标准条件寄存器，而 MIPS 在 DSP 扩展中添加了一组条件位。

### Concluding Remarks

> ###结论

This survey covers the addressing modes, instruction formats, and almost all the instructions found in 8 RISC architectures. Although the later sections concentrate on the differences, it would not be possible to cover 8 architectures in these few pages if there were not so many similarities. In fact, we would guess that more than 90% of the instructions executed for any of these architectures would be found in [Figures K.9 through K.13](#_bookmark850). To contrast this homogeneity, [Figure K.29](#_bookmark867) gives a sum- mary for four architectures from the 1970s in a format similar to that shown in [Figure K.1](#_bookmark842). (Since it would be impossible to write a single section in this style for those architectures, the next three sections cover the 80x86, VAX, and IBM 360/370.) In the history of computing, there has never been such widespread agree- ment on computer architecture as there has been since the RISC ideas emerged in the 1980s.

> 这项调查涵盖了 8 个 RISC 架构中发现的寻址模式，指令格式以及几乎所有指令。尽管后面的部分集中在差异上，但如果没有太多相似之处，则不可能在这几页中覆盖 8 个体系结构。实际上，我们猜测，对于这些架构中的任何一个，都将在[图 K.9 至 K.13]中找到超过 90％的说明（#_ bookmark850）。为了对比这种同质性，[图 K.29]（#_ bookmark867）为 1970 年代的四个体系结构提供了一个类似于[图 K.1]（#_ bookmark842）的格式。（由于不可能为这些架构编写此样式的单部分，因此接下来的三个部分涵盖了 80x86，VAX 和 IBM 360/370。）在计算的历史上，从来没有如此广泛的同意自 1980 年代 RISC 的想法出现以来，在计算机架构上。

Figure K.29 Summary of four 1970s architectures. Unlike the architectures in [Figure K.1](#_bookmark842), there is little agreement between these architectures in any category. (See Section K.3 for more details on the 80x86 and Section K.4 for a description of the VAX.)

> 图 K.29 四个 1970 年代建筑的摘要。与[图 K.1]（#_ bookmark842）中的体系结构不同，这些架构在任何类别中几乎没有共识。（有关 80x86 和 K.4 节的更多详细信息，请参见 K.3 节，以获取 VAX 的描述。）
