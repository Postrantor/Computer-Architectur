## Historical Perspective and References

> ##历史观点和参考

The earliest computers used fixed point rather than floating point. In “Preliminary Discussion of the Logical Design of an Electronic Computing Instrument,” [Burks,](#_bookmark810) [Goldstine, and von Neumann \[1946\]](#_bookmark810) put it like this:

> 最早的计算机使用固定点而不是浮点。在“电子计算工具的逻辑设计的初步讨论”中，[Burks，](#_ bookmark810)[Goldstine 和 von Neumann \ [1946 \]](#_ bookmark810)这样说：

_There appear to be two major purposes in a “floating” decimal point system both of which arise from the fact that the number of digits in a word is a constant fixed by design considerations for each particular machine. The first of these purposes is to retain in a sum or product as many significant digits as possible and the second of these is to free the human operator from the burden of estimating and inserting into a problem “scale factors”—multiplicative constants which serve to keep numbers within the limits of the machine._

> _在“浮动”小数点系统中似乎有两个主要目的，这两者都源于以下事实：单词中的数字数是每个特定机器的设计考虑因素固定的常数。这些目的中的第一个是保留尽可能多的重要数字或产品，其中第二个是使人类操作员免于估算和插入问题“规模因素”的负担 - 多种义务常数将数字保持在机器的范围内。

_There is, of course, no denying the fact that human time is consumed in arrang- ing for the introduction of suitable scale factors. We only argue that the time so consumed is a very small percentage of the total time we will spend in preparing an interesting problem for our machine. The first advantage of the floating point is, we feel, somewhat illusory. In order to have such a floating point, one must waste memory capacity that could otherwise be used for carrying more digits per word. It would therefore seem to us not at all clear whether the modest advan- tages of a floating binary point offset the loss of memory capacity and the increased complexity of the arithmetic and control circuits._

> _当然，不可否认，在安排适当的量表因素时会消耗人类的时间。我们只认为如此消耗的时间是我们在为机器准备一个有趣问题的总时间的一小部分。浮点的第一个优点是，我们觉得有些虚幻。为了拥有这样的浮点，必须浪费记忆能力，否则可以用来携带更多数字。因此，在我们看来，似乎尚不清楚浮动二进制点的适度优势是否抵消了记忆能力的丧失以及算术和控制电路的复杂性的增加。

This enables us to see things from the perspective of early computer designers, who believed that saving computer time and memory were more important than saving programmer time.

> 这使我们能够从早期的计算机设计师的角度看待事物，他们认为节省计算机时间和内存比节省程序员时间更重要。

The original papers introducing the Wallace tree, Booth recoding, SRT divi- sion, overlapped triplets, and so on are reprinted in [Swartzlander \[1990\]](#_bookmark834). A good explanation of an early machine (the IBM 360/91) that used a pipelined Wallace tree, Booth recoding, and iterative division is in [Anderson et al. \[1967\]](#_bookmark806). A discus- sion of the average time for single-bit SRT division is in [Freiman \[1961\]](#_bookmark814); this is one of the few interesting historical papers that does not appear in Swartzlander.

> 在[Swartzlander \ [1990 \]](#_ bookmark834)中转载了介绍华莱士树，摊位，SRT 分区，重叠的三胞胎等的原始论文。对使用管道的华莱士树，摊位重新编码和迭代划分的早期机器(IBM 360/91)的一个很好的解释是[Anderson 等人。\ [1967 \]](#_ bookmark806)。单位 SRT 部门平均时间的讨论是在[Freiman \ [1961 \]](#_ bookmark814)中；这是 Swartzlander 中没有出现的少数有趣的历史论文之一。

The standard book of [Mead and Conway \[1980\]](#_bookmark827) discouraged the use of CLAs as not being cost effective in VLSI. The important paper by [Brent and Kung \[1982\]](#_bookmark809) helped combat that view. An example of a detailed layout for CLAs can be found in [Ngai and Irwin \[1985\]](#_bookmark829) or in [Weste and Eshraghian \[1993\]](#_bookmark837), and a more theoretical treatment is given by [Leighton \[1992\]](#_bookmark824). [Takagi, Yasuura, and Yajima \[1985\]](#_bookmark835) pro- vide a detailed description of a signed-digit tree multiplier.

> [Mead and Conway \ [1980 \]](#_ bookmark827)的标准书劝阻使用 CLA 在 VLSI 中不具有成本效益。[Brent and Kung \ [1982 \]](#_ bookmark809)的重要论文帮助打击了这一观点。可以在[ngai and irwin \ [1985 \]](#_ bookmark829)或[Weste and Eshraghian \ [1993 \]](#_ bookmark837)中找到 CLA 的详细布局的示例，并给出更多理论治疗作者：[Leighton \ [1992 \]](#_ bookmark824)。[Takagi，Yasuura 和 Yajima \ [1985 \]](#_ bookmark835)详细描述了签名的树乘数。

Before the ascendancy of IEEE arithmetic, many different floating-point for- mats were in use. Three important ones were used by the IBM 370, the DEC VAX, and the Cray. Here is a brief summary of these older formats. The VAX format is closest to the IEEE standard. Its single-precision format (F format) is like IEEE single precision in that it has a hidden bit, 8 bits of exponent, and 23 bits of fraction. However, it does not have a sticky bit, which causes it to round halfway cases up instead of to even. The VAX has a slightly different exponent range from IEEE single: \_E_min is 128 rather than 126 as in IEEE, and \_E_max is 126 instead of 127. The main differences between VAX and IEEE are the lack of special values and gradual underflow. The VAX has a reserved operand, but it works like a signaling NaN: It traps whenever it is referenced. Originally, the VAX’s double precision (D format) also had 8 bits of exponent. However, as this is too small for many applications, a G format was added; like the IEEE standard, this format has 11 bits of exponent. The VAX also has an H format, which is 128 bits long.

> 在 IEEE 算术的上升升高之前，使用了许多不同的浮点。IBM 370，DEC VAX 和 CRAY 使用了三个重要的。这是这些旧格式的简要摘要。VAX 格式最接近 IEEE 标准。它的单精度格式(F 格式)就像 IEEE 单精度一样，因为它具有隐藏的位，8 位指数和 23 位分数。但是，它没有粘性，这会导致它在中途上方而不是均匀。VAX 的指数略有不同，范围与 IEEE 单曲：\ _e_min 是 128，而不是 IEEE 中的 126，而\ _e_max 为 126，而不是 126。VAX 具有保留的操作数，但它的工作方式就像信号 NAN：每当引用时会陷入困境。最初，VAX 的双精度(D 格式)也有 8 位指数。但是，由于对于许多应用来说太小了，因此添加了 G 格式。像 IEEE 标准一样，这种格式具有 11 位指数。VAX 还具有 H 格式，长 128 位。

The IBM 370 floating-point format uses base 16 rather than base 2. This means it cannot use a hidden bit. In single precision, it has 7 bits of exponent and 24 bits (6 hex digits) of fraction. Thus, the largest representable number is 1627 24 27 229, compared with 228 for IEEE. However, a number that is normalized in the hexadec- imal sense only needs to have a nonzero leading digit. When interpreted in binary, the three most-significant bits could be zero. Thus, there are potentially fewer than 24 bits of significance. The reason for using the higher base was to minimize the amount of shifting required when adding floating-point numbers. However, this is less signifi- cant in current machines, where the floating-point add time is usually fixed indepen- dently of the operands. Another difference between 370 arithmetic and IEEE arithmetic is that the 370 has neither a round digit nor a sticky digit, which effectively means that it truncates rather than rounds. Thus, in many computations, the result will systematically be too small. Unlike the VAX and IEEE arithmetic, every bit pattern is a valid number. Thus, library routines must establish conventi,onsfor what to return in

> IBM 370 浮点格式使用基本 16 而不是基础 2。这意味着它不能使用隐藏的位。在单一精确度中，它具有 7 位指数和 24 位(6 个十六进制)的分数。因此，最大的代表数为 1627 24 27 229，而 IEEE 为 228。但是，在六边形意义上进行归一化的数字只需要具有非零的领先数字。当用二进制解释时，三个最重要的位可能为零。因此，潜在的显着性不足 24 位。使用较高基数的原因是在添加浮点数时最小化所需的换档量。但是，这在当前机器中的意义较小，在当前机器中，浮点添加时间通常是操作数的独立固定的。370 算术和 IEEE 算术之间的另一个区别是，370 既没有圆形数字也没有粘性数字，这实际上意味着它截断而不是圆形。因此，在许多计算中，结果将系统地太小。与 VAX 和 IEEE 算术不同，每个位模式都是有效的数字。因此，图书馆的例程必须建立章节，以便返回什么

Arithmetic on Cray computers is interesting because it is driven by a motiva- tion for the highest possible floating-point performance. It has a 15-bit exponent field and a 48-bit fraction field. Addition on Cray computers does not have a guard digit, and multiplication is even less accurate than addition. Thinking of multipli- cation as a sum of _p_ numbers, each 2*p* bits long, Cray computers drop the low-order bits of each summand. Thus, analyzing the exact error characteristics of the mul- tiply operation is not easy. Reciprocals are computed using iteration, and division of _a_ by _b_ is done by multiplying _a_ times 1/_b_. The errors in multiplication and recip- rocation combine to make the last three bits of a divide operation unreliable. At least Cray computers serve to keep numerical analysts on their toes!

> 在 Cray 计算机上的算术很有趣，因为它是由最高的浮点性能的动机驱动的。它具有 15 位指数字段和一个 48 位分数字段。在 Cray 计算机上的添加不具有后卫数字，并且乘法的准确性甚至不如添加。将乘以作为_p_数字的总和，每个 2* p*位长，cray 计算机会丢弃每个汇总的低阶位。因此，分析操作的确切误差特性并不容易。使用迭代来计算倒数，_a_的划分_b_是通过乘以_a_ times 1/_b_来完成的。乘法和配置中的错误结合在一起，使分隔操作的最后三位不可靠。至少 Cray 计算机可以将数值分析师保持在其脚趾上！

The IEEE standardization process began in 1977, inspired mainly by W. Kahan and based partly on Kahan’s work with the IBM 7094 at the University of Toronto \[[Kahan 1968](#_bookmark819)\]. The standardization process was a lengthy affair, with gradual underflow causing the most controversy. (According to Cleve Moler, visitors to the United States were advised that the sights not to be missed were Las Vegas, the Grand Canyon, and the IEEE standards committee meeting.) The standard was finally approved in 1985. The Intel 8087 was the first major commercial IEEE implementation and appeared in 1981, before the standard was finalized. It con- tains features that were eliminated in the final standard, such as projective bits. According to Kahan, the length of double-extended precision was based on what could be implemented in the 8087. Although the IEEE standard was not based on any existing floating-point system, most of its features were present in some other system. For example, the CDC 6600 reserved special bit patterns for INDEFINITE and INFINITY, while the idea of denormal numbers appears in [Goldberg \[1967\]](#_bookmark816) as well as in [Kahan \[1968\]](#_bookmark819). Kahan was awarded the 1989 Turing prize in recognition of his work on floating point.

> IEEE 标准化过程始于 1977 年，主要受 W. Kahan 的启发，部分基于 Kahan 在多伦多大学与 IBM 7094 的合作，[[Kahan 1968](#_ bookmark819)\]。标准化过程是一项漫长的事情，逐渐引起了最大的争议。(根据克莱夫·莫勒(Cleve Moler)的说法，美国的游客被告知，不容错过的景点是拉斯维加斯，大峡谷和 IEEE 标准委员会会议。)该标准最终于 1985 年获得批准。大型商业 IEEE 实施，并于 1981 年出现，在该标准最终确定之前。它包含在最终标准中消除的功能，例如投射位。根据 Kahan 的说法，双重扩展精度的长度是基于 8087 中可以实现的。尽管 IEEE 标准并不基于任何现有的浮点系统，但其大多数功能都存在于其他系统中。例如，无限和无限的 CDC 6600 保留的特殊位模式，而 Donormal 数字的想法出现在[Goldberg \ [1967 \]](#_ bookmark816)中，以及[kahan \ [1968 \]](#_ bookmark819))。卡汉(Kahan)获得了 1989 年的图灵奖，以表彰他在浮点上的工作。

Although floating point rarely attracts the interest of the general press, news- papers were filled with stories about floating-point division in November 1994. A bug in the division algorithm used on all of Intel’s Pentium chips had just come to light. It was discovered by Thomas Nicely, a math professor at Lynchburg College in Virginia. Nicely found the bug when doing calculations involving reciprocals of prime numbers. News of Nicely’s discovery first appeared in the press on the front page of the November 7 issue of _Electronic Engineering Times._ Intel’s immediate response was to stonewall, asserting that the bug would only affect theoretical mathematicians. Intel told the press, “This doesn’t even qualify as an errata … even if you’re an engineer, you’re not going to see this.”

> 尽管浮点很少吸引普通媒体的兴趣，但 1994 年 11 月，新闻报纸上充斥着有关浮点部分区的故事。它是由弗吉尼亚州林奇堡学院的数学教授托马斯(Thomas)良好发现的。在进行涉及质数倒数的计算时，很好地找到了错误。良好发现的新闻首先出现在 11 月 7 日_Electronic Engineering Times 的首页上。英特尔告诉新闻界：“这甚至没有作为勘误的资格……即使您是工程师，也不会看到这个。”

Under more pressure, Intel issued a white paper, dated November 30, explain- ing why they didn’t think the bug was significant. One of their arguments was based on the fact that if you pick two floating-point numbers at random and divide one into the other, the chance that the resulting quotient will be in error is about 1 in 9 billion. However, Intel neglected to explain why they thought that the typical customer accessed floating-point numbers randomly.

> 在更大的压力下，英特尔发行了一份日期为 11 月 30 日的白皮书，解释了为什么他们认为该错误不大。他们的论点之一是基于以下事实：如果您随机选择两个浮点数并将一个浮点数分为另一个，则产生的商将错误的机会约为 90 亿分之一。但是，英特尔忽略了解释为什么他们认为典型客户随机访问浮点数。

Pressure continued to mount on Intel. One sore point was that Intel had known about the bug before Nicely discovered it, but had decided not to make it public. Finally, on December 20, Intel announced that they would unconditionally replace any Pentium chip that used the faulty algorithm and that they would take an unspe- cified charge against earnings, which turned out to be $300 million.

> 压力继续登上英特尔。一个痛点是英特尔在很好地发现该错误之前就知道了这个错误，但决定不公开它。最终，在 12 月 20 日，英特尔宣布，他们将无条件替代使用错误算法的任何奔腾芯片，并将对收入的收入不同意，事实证明这是 3 亿美元。

The Pentium uses a simple version of SRT division as discussed in [Section J.9](#speeding-up-integer-multiplication-and-division). The bug was introduced when they converted the quotient lookup table to a PLA. Evidently there were a few elements of the table containing the quotient digit 2 that Intel thought would never be accessed, and they optimized the PLA design using this assumption. The resulting PLA returned 0 rather than 2 in these situations. However, those entries were really accessed, and this caused the division bug. Even though the effect of the faulty PLA was to cause 5 out of 2048 table entries to be wrong, the Pentium only computes an incorrect quotient 1 out of 9 billion times on random inputs. This is explored in Exercise J.34.

> 如[j.9 节](＃加速 -  integer-multiplication and-Division)所讨论的 SRT 分割的简单版本。当错误将商查找表转换为 PLA 时，引入了该错误。显然，该表中有一些元素，其中包含英特尔认为永远不会访问的商数 2，他们使用此假设优化了 PLA 设计。在这些情况下，所得的 PLA 返回 0 而不是 2。但是，这些条目确实被访问了，这导致了分区错误。即使错误的 PLA 的效果是导致 2048 个表条目中的 5 个错误，但奔腾仅在随机输入中计算出 90 亿次中的不正确商。这是在练习 J.34 中探讨的。
