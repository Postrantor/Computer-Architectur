## Detecting and Enhancing Loop-Level Parallelism

> ##检测和增强循环级并行性

Loop-level parallelism is normally analyzed at the source level or close to it, while most analysis of ILP is done once instructions have been generated by the compiler. Loop-level analysis involves determining what dependences exist among the operands in a loop across the iterations of that loop. For now, we will consider only data dependences, which arise when an operand is written at some point and read at a later point. Name dependences also exist and may be removed by renaming techniques like those we explored in [Chapter 3](#_bookmark93).

> 通常在源级别或接近循环级的并行性分析，而一旦编译器生成了指令，大多数 ILP 的分析都是进行的。循环级别的分析涉及确定操作数之间在该循环的迭代中的操作数中存在的依赖。就目前而言，我们将仅考虑数据依赖性，这是在某个时候写入操作数并在以后阅读时会产生的。名称依赖也存在，可以通过重命名技术来删除，例如我们在[第 3 章]中探索的技术（#_ bookmark93）。

The analysis of loop-level parallelism focuses on determining whether data accesses in later iterations are dependent on data values produced in earlier iterations; such a dependence is called a _loop-carried dependence_. Most of the examples we considered in Section 3.2 have no loop-carried dependences and, thus, are loop-level parallel. To see that a loop is parallel, let us first look at the source representation:

> 循环级并行性的分析重点是确定以后迭代中的数据访问是否取决于早期迭代中产生的数据值。这样的依赖性称为_loop 婚姻依赖_。我们在第 3.2 节中考虑的大多数示例都没有循环依赖性，因此是循环级别的平行线。要看到循环是平行的，请首先看一下源代表：

```

> ````````

for (i=1000; i&gt;0; i=i-1) xi = xi + s;

> 对于（i = 1000; i＆gt; 0; i = i-1）xi = xi + s;

```

> ````````
> ````````

In this loop, there is a dependence between the two uses of xi, but this depen- dence is within a single iteration and is not loop carried. There is a dependence between successive uses of i in different iterations, which is loop carried, but this dependence involves an induction variable and can be easily recognized and elim- inated. We saw examples of how to eliminate dependences involving induction variables during loop unrolling in Section 3.2, and we will look at additional exam- ples later in this section.

> 在此循环中，XI 的两种用途之间存在一个依赖性，但是这种依赖性在单个迭代范围内，并且不携带循环。在不同的迭代中，i 的连续用途之间存在依赖性，这是循环携带的，但是这种依赖性涉及一个诱导变量，并且可以很容易地识别和消除。我们看到了如何消除在第 3.2 节中循环展开期间消除涉及感应变量的依赖的示例，我们将在本节稍后研究其他检查。

Because finding loop-level parallelism involves recognizing structures such as loops, array references, and induction variable computations, the compiler can do this analysis more easily at or near the source level, as opposed to the machine-code level. Let’s look at a more complex example.

> 因为查找环路级并行性涉及识别诸如循环，数组参考和归纳变量计算之类的结构，因此编译器可以在源级别或接近源级别上更容易地进行此分析，而不是机器代码级别。让我们看一个更复杂的例子。

Example Consider a loop like this one:

> 示例考虑这样的循环：

```

> ````````

for (i=1; i<=100; i=i+1) {

> for（i = 1; i <= 100; i = i+1）{

    Ai+1 = Ai + Ci; /* S1 */ Bi+1 = Bi + Ai+1; /* S2 */

> AI+1 = AI + CI; /* S1 */ BI+1 = BI + AI+1; /* S2 */

}

> }

```

> ````````
> ````````

Assume that A, B, and C are distinct, nonoverlapping arrays. (In practice, the arrays may sometimes be the same or may overlap. Because the arrays may be passed as parameters to a procedure, which includes this loop, determining whether arrays overlap or are identical often requires sophisticated, interprocedural analysis of the program.) What are the data dependences among the statements S1 and S2 in the loop?

> 假设 A，B 和 C 是不同的非重叠数组。（实际上，阵列有时可能是相同的或可能重叠的。因为阵列可以作为参数传递给一个过程，其中包括该循环，确定数组是否重叠或相同，通常需要对程序进行复杂的概解分析。）循环中的语句 S1 和 S2 之间的数据依赖性是什么？

_Answer_ There are two different dependences:

> 回答有两种不同的依赖性：

1. S1 uses a value computed by S1 in an earlier iteration, since iteration i com- putes Ai+1, which is read in iteration i+1. The same is true of S2 for Bi and Bi+1.

> 1. S1 使用 S1 在较早的迭代中计算出的值，因为迭代 i comput AI+1，该值在迭代 i+1 中读取。S2 对于 BI 和 BI+1 也是如此。

2. S2 uses the value, Ai+1, computed by S1 in the same iteration.

> 2. S2 使用 S1 在相同的迭代中计算的值 AI+1。

These two dependences are different and have different effects. To see how they differ, let’s assume that only one of these dependences exists at a time. Because the dependence of statement S1 is on an earlier iteration of S1, this depen- dence is loop carried. This dependence forces successive iterations of this loop to execute in series.

> 这两个依赖性不同，并且具有不同的影响。要查看它们的不同之处，让我们假设一次只存在其中一种。由于语句 S1 的依赖性是 S1 的较早迭代，因此该依赖性是循环的。这种依赖性迫使该循环的连续迭代串联执行。

The second dependence (S2 depending on S1) is within an iteration and is not loop carried. Thus, if this were the only dependence, multiple iterations of the loop could execute in parallel, as long as each pair of statements in an iteration were kept in order. We saw this type of dependence in an example in Section 3.2, where unrolling was able to expose the parallelism.

> 第二个依赖性（S2 取决于 S1）在迭代范围内，并且不携带循环。因此，如果这是唯一的依赖性，则循环的多个迭代可以并行执行，只要将迭代中的每对语句按顺序保留。我们在第 3.2 节中的一个示例中看到了这种依赖性，其中展开能够暴露并行性。

It is also possible to have a loop-carried dependence that does not prevent par- allelism, as the next example shows.

> 如下一个示例所示，也有可能具有循环依赖性的依赖性。

Example Consider a loop like this one:

> 示例考虑这样的循环：

```

> ````````

for (i=1; i<=100; i=i+1) {

> for（i = 1; i <= 100; i = i+1）{

Ai = Ai + Bi; /* S1 */

> AI = AI + BI;/ * S1 */

Bi+1 = Ci + Di; /* S2 */

> BI+1 = CI + DI; /* S2 */

}

> }

```

> ````````
> ````````

What are the dependences between S1 and S2? Is this loop parallel? If not, show how to make it parallel.

> S1 和 S2 之间的依赖性是什么？这个循环是平行的吗？如果没有，请显示如何并行。

_Answer_ Statement S1 uses the value assigned in the previous iteration by statement S2, so there is a loop-carried dependence between S2 and S1. Despite this loop-carried dependence, this loop can be made parallel. Unlike the earlier loop, this depen- dence is not circular: Neither statement depends on itself, and, although S1 depends on S2, S2 does not depend on S1. A loop is parallel if it can be written without a cycle in the dependences, since the absence of a cycle means that the dependences give a partial ordering on the statements.

> _answer_语句 S1 使用上一个迭代中分配的值按语句 S2 分配的值，因此 S2 和 S1 之间存在循环依赖性。尽管这种循环依赖性，但可以平行这个循环。与早期的循环不同，这种依赖性不是循环的：陈述都不取决于自身，尽管 S1 取决于 S2，但 S2 不取决于 S1。如果循环可以在依赖关系中没有周期的情况下编写，则循环是平行的，因为没有循环意味着依赖性给出了对语句的部分顺序。

Although there are no circular dependences in the above loop, it must be trans- formed to conform to the partial ordering and expose the parallelism. Two obser- vations are critical to this transformation:

> 尽管上述循环中没有循环依赖性，但必须进行转移以符合部分顺序并揭示并行性。两个观察者对这种转变至关重要：

1. There is no dependence from S1 to S2. If there were, then there would be a cycle in the dependences and the loop would not be parallel. Since this other dependence is absent, interchanging the two statements will not affect the exe- cution of S2.

> 1.从 S1 到 S2 没有依赖性。如果有的话，那么依赖性将有一个周期，并且循环不会平行。由于缺乏这种其他依赖性，因此互换这两个陈述不会影响 S2 的研究。

2. On the first iteration of the loop, statement S1 depends on the value of B1 computed prior to initiating the loop.

> 2.在循环的第一次迭代中，语句 S1 取决于在启动循环之前计算出的 B1 值。

These two observations allow us to replace the loop above with the following code sequence:

> 这两个观察结果使我们能够用以下代码顺序替换上述循环：

```

> ````````

A1 = A1 + B1;

> A1 = A1 + B1;

for (i=1; i<=99; i=i+1) { Bi+1 = Ci + Di;

> 对于（y = = 11; SAE 99;

Ai+1 = Ai+1 + Bi+1;

> AI+1 = AI+1+BI+1;

}

> }

B101 = C100 + D100;

> B101 = C100 + D100;

```

> ````````
> ````````

The dependence between the two statements is no longer loop carried, so iter- ations of the loop may be overlapped, provided the statements in each iteration are kept in order.

> 两个语句之间的依赖性不再载有循环，因此，只要保留每个迭代中的陈述，循环的迭代可能会重叠。

Our analysis needs to begin by finding all loop-carried dependences. This dependence information is _inexact_, in the sense that it tells us that such a depen- dence _may_ exist. Consider the following example:

> 我们的分析需要首先找到所有循环的依赖。从某种意义上说，此依赖性信息是_inexact_，它告诉我们存在这种依赖性_may_。考虑以下示例：

```

> ````````

for (i=1;i<=100;i=i+1) { Ai = Bi + Ci

> for（i = 1; i <= 100; i = i + 1）{ai = bi + ci

Di = Ai * Ei

> of = ai * ei

}

> }

```

> ````````
> ````````

The second reference to A in this example need not be translated to a load instruc- tion, since we know that the value is computed and stored by the previous state- ment; hence, the second reference to A can simply be a reference to the register into which A was computed. Performing this optimization requires knowing that the two references are _always_ to the same memory address and that there is no inter- vening access to the same location. Normally, data dependence analysis only tells that one reference _may_ depend on another; a more complex analysis is required to determine that two references _must be_ to the exact same address. In the example above, a simple version of this analysis suffices, since the two references are in the same basic block.

> 在此示例中，第二个引用不必翻译成负载指导，因为我们知道该值是由先前的陈述计算和存储的。因此，对 A 的第二个引用可以简单地引用计算 A 的寄存器。执行此优化需要知道这两个引用是_Always_到同一内存地址，并且没有对同一位置的相互访问。通常，数据依赖性分析仅告诉一个参考_may_取决于另一个参考。需要进行更复杂的分析以确定两个参考_可以_与完全相同的地址。在上面的示例中，此分析的简单版本就足够了，因为两个引用在同一基本块中。

Often loop-carried dependences are in the form of a _recurrence:_

> 通常，循环依赖性是_recurrence 的形式：_

```

> ````````

for (i=2;i<=100;i=i+1) { Yi = Yi-1 + Yi;

> for（i = 2; i <= 100; i = i + 1）{yi = yi-1 + yi;

}

> }

```

> ````````
> ````````

A recurrence is when a variable is defined based on the value of that variable in an earlier iteration, often the one immediately preceding, as in the above fragment. Detecting a recurrence can be important for two reasons: Some architectures (espe- cially vector computers) have special support for executing recurrences, and some recurrences can be the source of a reasonable amount of parallelism. To see how the latter can be true, consider this loop:

> 复发是在基于该变量的值中定义变量的早期迭代中的值（通常是在上面片段中），通常是在较早的迭代中（通常是在较早的迭代中）。检测复发可能很重要，原因有两个：某些架构（尤其是矢量计算机）对执行复发有特殊的支持，并且某些复发可以是合理数量的并行性的来源。要查看后者如何真实，请考虑以下循环：

```

> ````````

for (i=6;i<=100;i=i+1) { Yi = Yi-5 + Yi;

> for（i = 6; i <= 100; i = i + 1）{yi = yi-5 + yi;

}

> }

```

> ````````
> ````````

On the iteration _i,_ the loop references element _i_ 5. The loop is said to have a _dependence distance_ of 5. Many loops with carried dependences have a depen- dence distance of 1. The larger the distance, the more potential parallelism can be obtained by unrolling the loop. For example, if we unroll the first loop, with a dependence distance of 1, successive statements are dependent on one another; there is still some parallelism among the individual instructions, but not much. If we unroll the loop that has a dependence distance of 5, there is a sequence of five statements that have no dependences, and thus much more ILP. Although many loops with loop-carried dependences have a dependence distance of 1, cases with larger distances do arise, and the longer distance may well provide enough paral- lelism to keep a processor busy.

> 在迭代_i 上，_循环引用元素_i_ 5.据说循环的依赖性距离为 5. 5.许多带有依赖的环路的依赖性距离为 1。通过展开循环获得。例如，如果我们展开第一个循环（依赖关系距离为 1），则连续的陈述相互取决于彼此。个人指示中仍然存在一些并行性，但并不多。如果我们展开具有 5 个依赖性距离的循环，则有一个五个没有依赖性的序列，因此 ILP 更多。尽管许多具有循环依赖性的环路的依赖距离为 1，但确实会出现较大距离的情况，并且较长的距离可能会提供足够的副主义以使处理器忙碌。

### Finding Dependences

> ###查找依赖项

Finding the dependences in a program is an important part of three tasks: (1) good scheduling of code, (2) determining which loops might contain parallelism, and (3) eliminating name dependences. The complexity of dependence analysis arises because of the presence of arrays and pointers in languages like C or C++, or pass-by-reference parameter passing in FORTRAN. Since scalar variable refer- ences explicitly refer to a name, they can usually be analyzed quite easily, with aliasing because of pointers and reference parameters causing some complications and uncertainty in the analysis.

> 在程序中找到依赖性是三个任务的重要组成部分：（1）代码的良好调度，（2）确定哪些循环可能包含并行性，以及（3）消除名称依赖性。依赖分析的复杂性是由于诸如 C 或 C ++ 等语言中的数组和指针的存在，或者是通过 Fortran 中传递的引用参数。由于标量变量明确参考名称，因此通常可以很容易地对其进行分析，因此由于指示和参考参数引起了一些并发症和不确定性，因此可以通过混叠来进行分析。

How does the compiler detect dependences in general? Nearly all dependence analysis algorithms work on the assumption that array indices are _affine_. In sim- plest terms, a one-dimensional array index is affine if it can be written in the form _a i_ + _b_, where _a_ and _b_ are constants and _i_ is the loop index variable. The index of a multidimensional array is affine if the index in each dimension is affine. Sparse array accesses, which typically have the form xyi, are one of the major examples of nonaffine accesses.

> 编译器一般如何检测依赖性？几乎所有的依赖分析算法都在数组索引为_Affine_的假设上起作用。简而言之，如果可以以_a i_ + _b_的形式编写一维数组索引，则是仿射，其中_a_和_b_是常数，而_i_是循环索引变量。如果每个维度中的索引是仿射的，则多维阵列的索引是仿射。稀疏的阵列访问通常具有 XYI 形式，是非携带访问的主要示例之一。

Determining whether there is a dependence between two references to the same array in a loop is thus equivalent to determining whether two affine functions can have the same value for different indices between the bounds of the loop. For example, suppose we have stored to an array element with index value _a i_ + _b_ and loaded from the same array with index value _c i_ + _d_, where _i_ is the for-loop index variable that runs from _m_ to _n._ A dependence exists if two condi- tions hold:

> 因此，确定在循环中对同一数组的两个引用之间是否存在依赖性，等同于确定两个仿射函数是否可以在环路边界之间具有相同的值。例如，假设我们已将索引值_a i_ + _b_的数组元素存储到带有索引值_c i_ + _d_的同一数组中的数组元素，其中_i_是从_m_到_m_ _n._ A 的前面索引变量是否存在两个条件，存在依赖性：

1. There are two iteration indices, _j_ and _k_, both within the limits of the for loop. That is, _m_ ≤ _j_ ≤ _n, m_ ≤ _k_ ≤ _n_.

> 1.在 for 循环的范围内，有两个迭代索引_j_和_k_。也就是说，_m_≤_j_≤_n，m_≤_k_≤_n_。

2. The loop stores into an array element indexed by _a j_ + _b_ and later fetches from that _same_ array element when it is indexed by _c k_ + _d_. That is, _a j_ + _b c_ _k_ + _d_.

> 2.循环存储到由_a j_ + _b_索引的数组元素中，然后在_c k_ + _d_索引时从该_same_数组元素获取。也就是说，_a j_ + _b c_ _k_ + _d_。

In general, we cannot determine whether a dependence exists at compile time. For example, the values of _a_, _b_, _c_, and _d_ may not be known (they could be values in other arrays), making it impossible to tell if a dependence exists. In other cases, the dependence testing may be very expensive but decidable at compile time. For example, the accesses may depend on the iteration indices of multiple nested loops. Many programs, however, contain primarily simple indices where _a, b, c_, and _d_ are all constants. For these cases, it is possible to devise reasonable compile time tests for dependence.

> 通常，我们无法确定在编译时是否存在依赖性。例如，_a_，_b_，_c_和_d_的值可能不知道（它们可能是其他数组中的值），因此无法分辨是否存在依赖性。在其他情况下，依赖性测试可能非常昂贵，但在编译时可以决定。例如，访问可能取决于多个嵌套循环的迭代索引。但是，许多程序主要包含简单的索引，其中_a，b，c_和_d_都是常数。对于这些情况，可以设计合理的编译时间测试以依赖。

As an example, a simple and sufficient test for the absence of a dependence is the _greatest common divisor_ (GCD) test. It is based on the observation that if a loop-carried dependence exists, then GCD (_c,a_) must divide (_d b_). (Recall that an integer, _x, divides_ another integer, _y_, if we get an integer quotient when we do the division _y_/_x_ and there is no remainder.)

> 例如，对于缺乏依赖性的简单和充分的测试是_最 greateat common Divisor_（GCD）测试。这是基于这样的观察结果：如果存在循环依赖性，则 GCD（_C，A_）必须划分（_d b_）。（回想一下一个整数，_x，除法_另一个整数，_y_，如果我们在做 difere _y _/_ x_时获得整数商，没有剩余的。）

Example Use the GCD test to determine whether dependences exist in the following loop:

> 示例使用 GCD 测试来确定以下循环中是否存在依赖性：

```

> ````````

for (i=1; i<=100; i=i+1) { X2*i+3 = X2*i \* 5.0;

> for（i = 1; i <= 100; i = i+1）{x2*i+3 = x2*i \*5.0;

}

> }

```

> ````````
> ````````

_Answer_ Given the values _a_ = 2, _b_ = 3, _c_ = 2, and _d_ = 0, then

> _answer_给定值_a_ = 2，_b_ = 3，_c_ = 2，_d_ = 0，然后

GCD(_a,c_) = 2, and _d_ — _b_ =

> gcd（_a，c_）= 2，_d_  -  _b_ =

1. Since 2 does not divide —3, no dependence is possible.

> 1.由于 2 不划分-3，因此不可能。

The GCD test is sufficient to guarantee that no dependence exists; however, there are cases where the GCD test succeeds but no dependence exists. This can arise, for example, because the GCD test does not take the loop bounds into account.

> GCD 测试足以保证不存在依赖性；但是，在某些情况下，GCD 测试成功，但不存在依赖性。例如，这可能会发生，因为 GCD 测试未考虑循环界限。

In general, determining whether a dependence actually exists is NP complete. In practice, however, many common cases can be analyzed precisely at low cost. Recently, approaches using a hierarchy of exact tests increasing in generality and cost have been shown to be both accurate and efficient. (A test is _exact_ if it precisely determines whether a dependence exists. Although the general case is NP complete, there exist exact tests for restricted situations that are much cheaper.)

> 通常，确定依赖性是否真正存在的 NP 完成。但是，实际上，可以以低成本精确地分析许多常见案例。最近，使用精确测试的层次结构的方法增加了一般性和成本的方法既准确又有效。（如果确切地确定是否存在依赖性，则测试是_exact_。尽管一般情况已完成，但对于限制性情况，存在精确的测试，这些测试便宜得多。）

In addition to detecting the presence of a dependence, a compiler wants to classify the type of dependence. This classification allows a compiler to recog- nize name dependences and eliminate them at compile time by renaming and copying.

> 除了检测依赖性的存在外，编译器还希望对依赖的类型进行分类。此分类允许编译器对名称依赖性进行认可，并通过重命名和复制在编译时消除它们。

Example The following loop has multiple types of dependences. Find all the true depen- dences, output dependences, and antidependences, and eliminate the output depen- dences and antidependences by renaming.

> 示例以下循环具有多种类型的依赖性。找到所有真实的依赖，输出依赖性和抗抑郁症，并通过重命名消除输出依赖和抗抑郁。

```

> ````````

for (i=1; i<=100; i=i+1) { Yi = Xi / c; /_ S1 _/ Xi = Xi + c; /_ S2 _/ Zi = Yi + c; /_ S3 _/ Yi = c - Yi; /_ S4 _/

> for（i = 1; i <= 100; i = i+1）{yi = xi / c;/ _ s1 _/ xi = xi + c;/ _ s2 _/ zi = yi + c;/ _ s3 _/ yi = c -yi;/_ s4 _/

}

> }

_Answer_ The following dependences exist among the four statements:

> _answer_在四个语句中存在以下依赖性：

```

> ````````
> ````````

1. There are true dependences from S1 to S3 and from S1 to S4 because of Yi. These are not loop carried, so they do not prevent the loop from being consid- ered parallel. These dependences will force S3 and S4 to wait for S1 to complete.

> 1.由于 yi，从 S1 到 S3 以及从 S1 到 S4 的真实依赖性。这些不是循环携带的，因此它们不会阻止循环被认为是平行的。这些依赖性将迫使 S3 和 S4 等待 S1 完成。

2. There is an antidependence from S1 to S2, based on Xi.

> 2.基于 XI，S1 到 S2 的抗抑郁症。

3. There is an antidependence from S3 to S4 for Yi.

> 3. Yi 的 S3 到 S4 有抗抑郁。

4. There is an output dependence from S1 to S4, based on Yi.

> 4.基于 yi，S1 到 S4 的输出依赖性。

The following version of the loop eliminates these false (or pseudo) dependences:

> 循环的以下版本消除了这些错误（或伪）的依赖性：

```

> ````````

for (i=1; i<=100; i=i+1 {

> for（i = 1; i <= 100; i = i+1 {

/_ Y renamed to T to remove output dependence _/ Ti = Xi / c;

> / _ y将其重命名为t，以删除输出依赖_ / ti = xi / c;

/_ X renamed to X1 to remove antidependence _/ X1i = Xi + c;

> / _ x重命名为x1以删除抗抑郁_/ x1i = xi + c;

/_ Y renamed to T to remove antidependence _/ Zi = Ti + c;

> / _ y将其重命名为t，以删除抗抑郁_/ zi = ti + c;

Yi = c - Ti;

> Y i = 从 - TI;

}

> }

```

> ````````
> ````````

After the loop, the variable X has been renamed X1. In code that follows the loop, the compiler can simply replace the name X by X1. In this case, renaming does not require an actual copy operation but can be done by substituting names or by reg- ister allocation. In other cases, however, renaming will require copying.

> 循环后，变量 X 已更名为 X1。在循环之后的代码中，编译器可以简单地用 x1 替换名称 x。在这种情况下，重命名不需要实际的副本操作，但可以通过替换名称或通过 reg-Ister 分配来完成。但是，在其他情况下，重命名将需要复制。

Dependence analysis is a critical technology for exploiting parallelism. At the instruction level, it provides information needed to interchange memory references when scheduling, as well as to determine the benefits of unrolling a loop. For detecting loop-level parallelism, dependence analysis is the basic tool. Effectively compiling programs to either vector computers or multiprocessors depends criti- cally on this analysis. The major drawback of dependence analysis is that it applies only under a limited set of circumstances—namely, among references within a sin- gle loop nest and using affine index functions. Thus, there is a wide variety of sit- uations in which array-oriented dependence analysis _cannot_ tell us what we might want to know, including the following:

> 依赖分析是利用并行性的关键技术。在指令级别，它提供了在调度时互换内存引用所需的信息，并确定展开循环的好处。对于检测循环级并行性，依赖分析是基本工具。有效地为矢量计算机或多处理器编译程序取决于此分析。依赖分析的主要缺点是，它仅在一组有限的情况下适用，即在 single 循环巢中的参考和使用仿射索引函数中。因此，有各种各样的情况，其中以数组为导向的依赖分析_Cannot_告诉我们我们可能想知道的是什么，包括以下内容：

- When objects are referenced via pointers rather than array indices (but see discussion below)

> - 当通过指针而不是数组索引引用对象时（但请参见下面的讨论）

- When array indexing is indirect through another array, which happens with many representations of sparse arrays

> - 当数组索引通过另一个数组间接时，发生了许多稀疏阵列的表示

- When a dependence may exist for some value of the inputs but does not exist in actuality when the code is run since the inputs never take on those values

> - 当输入的某些值可能存在依赖性，但在运行代码时实际上不存在，因为输入永远不会承担这些值

- When an optimization depends on knowing more than just the possibility of a dependence but needs to know on _which_ write of a variable does a read of that variable depend

> - 当优化取决于了解依赖性的可能性，而是需要在_ pribal 上知道变量的写入该变量依赖

To deal with the issue of analyzing programs with pointers, another type of anal- ysis, often called _points-to_ analysis, is required (see Wilson and Lam 1995). The key question that we want answered from dependence analysis of pointers is whether two pointers can designate the same address. In the case of complex dynamic data struc- tures, this problem is extremely difficult. For example, we may want to know whether twopointerscanreference the _same_ nodeinalistatagivenpointinaprogram, whichin general is undecidable and in practice is extremely difficult to answer. We may, how- ever, be able to answer a simpler question: Can two pointers designate nodes in the _same_ list, even if they may be separate nodes? This more restricted analysis can still be quite useful in scheduling memory accesses performed through pointers.

> 为了处理用指针分析程序的问题，需要另一种类型的分析，通常称为_points-to_分析（参见 Wilson and Lam 1995）。我们希望从指针的依赖分析中回答的关键问题是两个指针是否可以指定相同的地址。在复杂的动态数据结构的情况下，此问题极为困难。例如，我们可能想知道_same_ nodeinalistatagivenpointInaprogragry 是否一般是不可决定的，并且在实践中很难回答。但是，我们可以回答一个更简单的问题：即使它们可能是单独的节点，两个指针也可以指定_same_列表中的节点吗？这种限制的分析仍然可以在安排通过指针执行的内存访问方面非常有用。

The basic approach used in points-to analysis relies on information from three major sources:

> 点对点分析中使用的基本方法取决于来自三个主要来源的信息：

1. Type information, which restricts what a pointer can point to.

> 1.键入信息，这限制了指针可以指向的信息。

2. Information derived when an object is allocated or when the address of an object is taken, which can be used to restrict what a pointer can point to. For example, if _p_ always points to an object allocated in a given source line and _q_ never points to that object, then _p_ and _q_ can never point to the same object.

> 2.当对象分配时或获取对象的地址时得出的信息，可用于限制指针指向的内容。例如，如果_p_总是指向给定源行中分配的对象，而_q_永远不会指向该对象，则_p_和_q_永远不会指向同一对象。

3. Information derived from pointer assignments. For example, if _p_ may be assigned the value of _q_, then _p_ may point to anything _q_ points to.

> 3.从指针分配得出的信息。例如，如果_p_可以分配_q_的值，则_p_可以指向任何_q_指向的内容。

There are several cases where analyzing pointers has been successfully applied and is extremely useful:

> 在几种情况下，分析指针已成功应用，并且非常有用：

- When pointers are used to pass the address of an object as a parameter, it is possible to use points-to analysis to determine the possible set of objects refer- enced by a pointer. One important use is to determine if two pointer parameters may designate the same object.

> - 当使用指针将对象的地址作为参数传递时，可以使用点对点分析来确定指针参考的对象集。一种重要的用途是确定两个指针参数是否可以指定同一对象。

- When a pointer can point to one of several types, it is sometimes possible to determine the type of the data object that a pointer designates at different parts of the program.

> - 当指针可以指向几种类型之一时，有时可以确定指针在程序的不同部分指定的数据对象的类型。

- It is often possible to separate out pointers that may only point to a local object versus a global one.

> - 通常可以将可能只指向本地对象而不是全局对象的指针分开。

There are two different types of limitations that affect our ability to do accu- rate dependence analysis for large programs. The first type of limitation arises from restrictions in the analysis algorithms. Often, we are limited by the lack of applicability of the analysis rather than a shortcoming in dependence analysis _per se_. For example, dependence analysis for pointers is essentially impossible for programs that use pointers in arbitrary fashion—such as by doing arithmetic on pointers.

> 有两种不同类型的局限性影响我们对大型程序进行准确依赖分析的能力。第一种限制源于分析算法中的限制。通常，我们受到分析缺乏适用性而不是依赖分析的缺点_per _per se_的限制。例如，对于以任意方式使用指针的程序，例如通过对指针进行算术，对指针的依赖分析基本上是不可能的。

The second limitation is the need to analyze behavior across procedure bound- aries to get accurate information. For example, if a procedure accepts two param- eters that are pointers, determining whether the values could be the same requires analyzing across procedure boundaries. This type of analysis, called _interproce- dural analysis_, is much more difficult and complex than analysis within a single procedure. Unlike the case of analyzing array indices within a single loop nest, points-to analysis usually requires an interprocedural analysis. The reason for this is simple. Suppose we are analyzing a program segment with two pointers; if the analysis does not know anything about the two pointers at the start of the program segment, it must be conservative and assume the worst case. The worst case is that the two pointers _may_ designate the same object, but they are not _guaranteed_ to designate the same object. This worst case is likely to propagate through the anal- ysis, producing useless information. In practice, getting fully accurate interproce- dural information is usually too expensive for real programs. Instead, compilers usually use approximations in interprocedural analysis. The result is that the infor- mation may be too inaccurate to be useful.

> 第二个限制是需要分析跨程序边界以获取准确信息的行为。例如，如果一个过程接受指示的两个参数，确定值是否可以相同，则需要在过程边界进行分析。这种类型的分析（称为_ Interproce-Dural Analysis_）比单个过程中的分析要困难得多。与分析单个循环巢中的阵列索引的情况不同，点对点分析通常需要进行分解分析。这样做的原因是简单的。假设我们正在用两个指针分析程序段；如果分析在程序段开始时对两个指针一无所知，则必须是保守的，并且假定最坏的情况。最坏的情况是，两个指针_may_指定相同的对象，但它们不是指定同一对象的保证。这种最坏的情况可能会通过分析传播，从而产生无用的信息。实际上，对于真实程序而言，获得完全准确的插入性信息通常太昂贵了。取而代之的是，编译器通常在概要分析中使用近似值。结果是，信息可能过于不准确，无法有用。

Modern programming languages that use strong typing, such as Java, make the analysis of dependences easier. At the same time the extensive use of procedures to structure programs, as well as abstract data types, makes the analysis more diffi- cult. Nonetheless, we expect that continued advances in analysis algorithms, com- bined with the increasing importance of pointer dependency analysis, will mean that there is continued progress on this important problem.

> 使用强大打字的现代编程语言，例如 Java，使对依赖的分析变得更加容易。同时，广泛使用程序来构建程序以及抽象的数据类型，使分析更加困难。尽管如此，我们期望分析算法的持续进展与指针依赖分析的重要性越来越重要，这将意味着在这个重要问题上存在继续进展。

### Eliminating Dependent Computations

> ###消除依赖计算

Compilers can reduce the impact of dependent computations so as to achieve more instruction-level parallelism (ILP). The key technique is to eliminate or reduce a dependent computation by back substitution, which increases the amount of par- allelism and sometimes increases the amount of computation required. These tech- niques can be applied both within a basic block and within loops, and we describe them differently.

> 编译器可以减少依赖计算的影响，从而获得更多的指导级并行性（ILP）。关键技术是通过替换消除或减少依赖计算，这增加了等级的数量，有时会增加所需的计算量。这些技术可以在基本块中和循环中应用，我们以不同的方式描述它们。

Within a basic block, algebraic simplifications of expressions and an optimi- zation called _copy propagation_, which eliminates operations that copy values, can be used to simplify sequences like the following:

> 在基本块中，代数简化表达式和称为_copy paspagation_的优化，它消除了复制值的操作，可用于简化以下序列：

> ===

assuming this is the only use of R1. In fact, the techniques we used to reduce multiple increments of array indices during loop unrolling and to move the incre- ments across memory addresses in Section 3.2 are examples of this type of optimization.

> 假设这是 R1 的唯一用途。实际上，我们用来减少循环展开期间数组索引的多个增量的技术，并在第 3.2 节中移动跨内存地址的分解是此类优化的示例。

In these examples, computations are actually eliminated, but it is also pos- sible that we may want to increase the parallelism of the code, possibly even increasing the number of operations. Such optimizations are called _tree height reduction_ because they reduce the height of the tree structure representing a computation, making it wider but shorter. Consider the following code sequence:

> 在这些示例中，实际上消除了计算，但是我们可能希望增加代码的并行性，甚至可能增加操作数量。这样的优化称为_tree 高度降低_，因为它们降低了代表计算的树结构的高度，使其更宽但更短。考虑以下代码序列：

> ===

Notice that this sequence requires at least three execution cycles, since all the instructions depend on the immediate predecessor. By taking advantage of asso- ciativity, we can transform the code and rewrite it as

> 请注意，此顺序至少需要三个执行周期，因为所有指令都取决于直接的前任。通过利用协同的优势，我们可以更改代码并将其重写为

> ===

This sequence can be computed in two execution cycles. When loop unrolling is used, opportunities for these types of optimizations occur frequently.

> 该序列可以在两个执行周期中计算。当使用循环展开时，这些类型的优化机会经常发生。

Although arithmetic with unlimited range and precision is associative, com- puter arithmetic is not associative, for either integer arithmetic, because of limited range, or floating-point arithmetic, because of both range and precision. Thus, using these restructuring techniques can sometimes lead to erroneous behavior, although such occurrences are rare. For this reason, most compilers require that optimizations that rely on associativity be explicitly enabled.

> 尽管具有无限范围和精度的算术是关联的，但由于范围有限或由于范围和精度，因此，由于范围有限或浮点算术，因此，算术算术不是关联的。因此，尽管这种情况很少见，但使用这些重组技术有时会导致错误的行为。因此，大多数编译器要求明确启用依赖关联性的优化。

When loops are unrolled, this sort of algebraic optimization is important to reduce the impact of dependences arising from recurrences. _Recurrences_ are expressions whose value on one iteration is given by a function that depends on the previous iterations. When a loop with a recurrence is unrolled, we may be able to algebraically optimize the unrolled loop, so that the recurrence need only be evaluated once per unrolled iteration. One common type of recurrence arises from an explicit program statement, such as:

> 当循环展开时，这种代数优化对于减少复发引起的依赖的影响很重要。_recurrences_是表达式，其对一个迭代的价值由取决于先前迭代的函数给出。当展开具有复发性的循环时，我们可能能够代数优化展开的循环，因此每次展开的迭代只需评估一次复发一次即可。一种常见的复发类型来自明确的程序语句，例如：

```

> ````````

sum = sum + x;

> sum = sum + x;

```

> ````````
> ````````

Assume we unroll a loop with this recurrence five times. If we let the value of x on these five iterations be given by x1, x2, x3, x4, and x5, then we can write the value of sum at the end of each unroll as:

> 假设我们在此复发中展开循环五次。如果我们在这五个迭代中让 x 的值由 x1，x2，x3，x4 和 x5 给出，那么我们可以在每个爆发的末尾编写总和值，为：

```

> ````````

sum = sum + x1 + x2 + x3 + x4 + x5;

> am = i am + 1 + 2 + kh + kc + 5;

```

> ````````
> ````````

If unoptimized, this expression requires five dependent operations, but it can be rewritten as:

> 如果不优化，此表达式需要五个依赖性操作，但可以重写为：

```

> ````````

sum = ((sum + x1) + (x2 + x3)) + (x4 + x5);

> am =（（i + 1） +（2 + cc）） +（kc + 5）;

```

> ````````
> ````````

which can be evaluated in only three dependent operations.

> 只能在三个依赖操作中评估。

Recurrences also arise from implicit calculations, such as those associated with array indexing. Each array index translates to an address that is computed based on the loop index variable. Again, with unrolling and algebraic optimization, the dependent computations can be minimized.

> 复发也来自隐式计算，例如与数组索引相关的计算。每个数组索引都转化为基于循环索引变量计算的地址。同样，通过展开和代数优化，可以最大程度地减少因计算。
