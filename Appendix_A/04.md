## Type and Size of Operands

How is the type of an operand designated? Usually, encoding in the opcode designates the type of an operand—this is the method used most often. Alterna- tively, the data can be annotated with tags that are interpreted by the hardware. These tags specify the type of the operand, and the operation is chosen accordingly. Computers with tagged data, however, can only be found in computer museums. Let’s start with desktop and server architectures. Usually the type of an oper- and—integer, single-precision floating point, character, and so on—effectively gives its size. Common operand types include character (8 bits), half word (16 bits), word (32 bits), single-precision floating point (also 1 word), and double- precision floating point (2 words). Integers are almost universally represented as two’s complement binary numbers. Characters are usually in ASCII, but the 16-bit Unicode (used in Java) is gaining popularity with the internationalization of computers. Until the early 1980s, most computer manufacturers chose their own floating-point representation. Almost all computers since that time follow the same standard for floating point, the IEEE standard 754, although this level of accuracy has recently been abandoned in application-specific processors. The IEEE floating-point standard is discussed in detail in Appendix J.

> 如何指定操作数的类型？通常，在 OPODE 中编码操作数的类型，这是最常使用的方法。另外，可以用硬件解释的标签注释数据。这些标签指定操作数的类型，并相应地选择操作。但是，具有标记数据的计算机只能在计算机博物馆中找到。让我们从桌面和服务器架构开始。通常，操作的类型和 integer，单精度的浮点，角色等有效地给出了大小。常见的操作数类型包括字符(8 位)，半单词(16 位)，单词(32 位)，单精度浮点(也是 1 个单词)和双精度浮点(2 个单词)。整数几乎被普遍表示为两个补充二进制数字。字符通常在 ASCII 中，但是 16 位 Unicode(用于 Java)在计算机的国际化中越来越受欢迎。直到 1980 年代初，大多数计算机制造商都选择了自己的浮点代表。自那时以来，几乎所有计算机都遵循浮点的标准，即 IEEE 标准 754，尽管最近在特定于应用程序的处理器中放弃了这种准确性。IEEE 浮点标准在附录 J 中进行了详细讨论。

Some architectures provide operations on character strings, although such oper- ations are usually quite limited and treat each byte in the string as a single character. Typical operations supported on character strings are comparisons and moves.

> 一些架构提供了对字符串的操作，尽管此类操作通常非常有限，并且将字符中的每个字节视为单个字符。字符串支持的典型操作是比较和移动。

For business applications, some architectures support a decimal format, usually called _packed decimal_ or _binary-coded decimal_—4 bits are used to encode the values 0–9, and 2 decimal digits are packed into each byte. Numeric character strings are sometimes called _unpacked decimal_, and operations—called _packing_ and _unpacking_—are usually provided for converting back and forth between them. One reason to use decimal operands is to get results that exactly match decimal numbers, as some decimal fractions do not have an exact representation in binary. For example, 0.10<sub>10</sub> is a simple fraction in decimal, but in binary it requires an infinite set of repeating digits: 0.0001100110011<sub>…2</sub>. Thus, calculations that are exact in decimal can be close but inexact in binary, which can be a problem for financial transactions. (See Appendix J to learn more about precise arithmetic.)

> 对于业务应用程序，一些架构支持十进制格式，通常称为_包装的 DECIMAL_或_BINARIOD 编码的 Decimal_-4 位用于编码值 0-9，并且将 2 个小数位数包装到每个字节中。数字字符串有时称为_unpacked decimal_，而操作(packing_ and _unpacking_)通常是为了在它们之间来回转换而提供的。使用小数操作数的原因之一是获得与十进制数字完全匹配的结果，因为某些小数分数在二进制中没有确切的表示。例如，0.10 <sub> 10 </sub>是小数点的简单分数，但是在二进制中，它需要一组无限的重复数字：0.0001100110011 <ub>…2…2 </sub>。因此，十进制中精确的计算可能是近距离的，但二进制中的计算不确定，这可能是金融交易的问题。(请参阅附录 J 了解有关精确算术的更多信息。)

The SPEC benchmarks use byte or character, half-word (short integer), word (integer and single precision floating point), double-word (long integer), and floating-point data types. [Figure A.11](#_bookmark407) shows the dynamic distribution of the sizes of objects referenced from memory for these programs. The frequency of access to different data types helps in deciding what types are most important to support effi- ciently. Should the computer have a 64-bit access path, or would taking two cycles to access a double word be satisfactory? As we saw earlier, byte accesses require an alignment network: how important is it to support bytes as primitives? [Figure A.11](#_bookmark407) uses memory references to examine the types of data being accessed.

> 规格基准测试使用字节或字符，半词(短整数)，单词(整数和单个精度浮点)，双词(长整数)和浮点数据类型。[图 A.11](#_bookmark407) 显示了这些程序的内存中引用的对象的大小的动态分布。访问不同数据类型的频率有助于确定哪些类型对于有效地支持哪些类型。计算机是否应该具有 64 位的访问路径，还是要两个周期来访问双词？正如我们之前看到的，字节访问需要一个对齐网络：支持字节作为原始内容有多重要？[图 A.11](#_bookmark407) 使用内存引用来检查访问的数据类型。

In some architectures, objects in registers may be accessed as bytes or half words. However, such access is very infrequent—on the VAX, it accounts for no more than 12% of register references, or roughly 6% of all operand accesses in these programs.

> 在某些体系结构中，寄存器中的对象可以作为字节或半词访问。但是，这种访问很少见 - 在 VAX 中，它占寄存器参考的 12％，或这些程序中所有操作数访问的大约 6％。

Figure A.11 Distribution of data accesses by size for the benchmark programs. The double-word data type is used for double-precision floating point in floating-point pro- grams and for addresses, because the computer uses 64-bit addresses. On a 32-bit address computer the 64-bit addresses would be replaced by 32-bit addresses, and so almost all double-word accesses in integer programs would become single-word accesses.

> 图 A.11 基准程序的数据访问分布。双字数据类型用于浮点程序和地址的双精度浮点，因为计算机使用 64 位地址。在 32 位地址计算机上，64 位地址将被 32 位地址替换，因此整数程序中几乎所有的双字访问都将成为单字访问。
